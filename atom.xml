<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>easy-go&#39;s blogs</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mlone.top/"/>
  <updated>2019-02-27T10:07:25.404Z</updated>
  <id>https://mlone.top/</id>
  
  <author>
    <name>easy go</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx的作用</title>
    <link href="https://mlone.top/post/d86db295.html"/>
    <id>https://mlone.top/post/d86db295.html</id>
    <published>2018-12-30T08:50:36.000Z</published>
    <updated>2019-02-27T10:07:25.404Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/qq_36178641/article/details/80110981" target="_blank" rel="noopener">正向代理和反向代理概述</a><br><a id="more"></a></p><h5 id="一、作为静态资源服务器"><a href="#一、作为静态资源服务器" class="headerlink" title="一、作为静态资源服务器"></a>一、作为静态资源服务器</h5><p>可以通过http请求访问服务器上的静态资源。（首页广告图片、商品图片显示、图片上传回显）</p><h5 id="二、反向代理与负载均衡："><a href="#二、反向代理与负载均衡：" class="headerlink" title="二、反向代理与负载均衡："></a>二、反向代理与负载均衡：</h5><p>正向代理最大的特点是客户端非常明确要访问的服务器地址；服务器只清楚请求来自哪个代理服务器，而不清楚来自哪个具体的客户端；正向代理模式屏蔽或者隐藏了真实客户端信息。</p><p><strong>反向代理</strong>，主要用于<strong>服务器集群分布式部署</strong>的情况下，反向代理隐藏了服务器的信息！</p><p>多个客户端给服务器发送的请求，nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。此时~请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，nginx扮演的就是一个反向代理角色</p><p>客户端发送的、nginx反向代理服务器接收到的<strong>请求数量</strong>，就是我们说的<strong>负载量</strong><br>请求数量按照一定的规则进行分发到不同的服务器处理的规则，就是一种<strong>均衡规则</strong></p><p>所以<strong>~将服务器接收到的请求按照规则分发的过程</strong>，称为<strong>负载均衡</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/qq_36178641/article/details/80110981&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;正向代理和反向代理概述&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
      <category term="web" scheme="https://mlone.top/tags/web/"/>
    
      <category term="nginx" scheme="https://mlone.top/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>spring与springmvc</title>
    <link href="https://mlone.top/post/724a55c9.html"/>
    <id>https://mlone.top/post/724a55c9.html</id>
    <published>2018-12-29T08:50:36.000Z</published>
    <updated>2019-02-28T08:08:27.347Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/jonesAriven/article/details/80036602" target="_blank" rel="noopener">spring与springmvc的区别与联系</a></p><a id="more"></a><h5 id="一、spring框架的介绍"><a href="#一、spring框架的介绍" class="headerlink" title="一、spring框架的介绍"></a>一、spring框架的介绍</h5><p><strong>spring是一个一站式的框架，提供了表现层（springmvc）到业务层（spring）再到数据层（springdata）的全套解决方案；</strong>spring的两大核心IOC(控制反转)和AOP(面向切面编程)更是给我们的程序解耦和代码的简介提供了支持。</p><h5 id="二、springmvc"><a href="#二、springmvc" class="headerlink" title="二、springmvc"></a>二、springmvc</h5><p> （1）<strong>springmvc给spring的表现层提供支持</strong></p><p> （2）springmvc的流程：</p><ol><li><p>用户发送请求至<strong>前端控制器DispatcherServlet；</strong></p></li><li><p>DispatcherServlet收到请求调用<strong>HandlerMapping处理器映射器；</strong></p></li><li><p>处理器映射器根据<strong>请求url</strong>找到具体的处理器，生成<strong>处理器对象</strong>及<strong>处理器拦截器</strong>(如果有则生成)一并返回给DispatcherServlet；</p></li><li><p>DispatcherServlet通过<strong>HandlerAdapter处理器适配器</strong>调用处理器，执行<strong>处理器</strong>(Controller，也叫后端控制器)；</p></li><li><p>Controller执行完成返回ModelAndView，并返回给HandlerAdapter，HandlerAdapter将结果返回给DispatcherServlet；</p></li><li><p>DispatcherServlet将ModelAndView传给<strong>ViewReslover视图解析器</strong>，ViewReslover解析后返回具体View给DispatcherServlet；</p></li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）后返回给客户</li></ol><h5 id="三、AOP与IOC"><a href="#三、AOP与IOC" class="headerlink" title="三、AOP与IOC"></a>三、AOP与IOC</h5><p>（1）AOP与IOC给spring的业务层提供支持，使程序的耦合度更低，代码更简洁</p><p>（2）AOP原理：即面向切面编程，就是提取公共部分，集中解决一些公共问题</p><p>（3）IOC原理：控制反转。在传统过程中，当某一个对象依赖于另外一个对象时，会由该对象去创建另外一个对象，有了ioc后，将创建过程交给IOC,由spring创建bean，从而只需给该对象注入即可</p><p><strong>问：*</strong>什么是AOP和IOC，它们的作用是什么?*</p><p>AOP：(Aspect Oriented Programing) 面向切面编程。</p><p>是指<strong>使用动态代理模式，在一个事务中无缝地插入多条其他处理。</strong></p><p>作用：Spring使用aop声明式事务控制，通过横向抽取方法将service层中的事务控制的代码抽取出来。</p><p>IOC： (Inverse of Control) 控制反转。</p><p>是指<strong>将原来程序中自己创建实现类对象的控制权反转到IOC容器中。只需要通过IOC来获对象的实例，将IOC当成一个黑盒子、工厂。</strong></p><p>作用：Spring提供ioc容器，对 bean进行实例化。使用bean时候从容器中取。还可以实现依赖注入(DI)，将对象需要的bean注入到其对象属性中。</p><p><strong>拓展：*</strong>AOP的概念：*</p><p>Aspected Oriented Programming 面向方面编程。</p><p>好处：AOP将程序分解成各个方面或者说关注点。这使得可以模块化，相当横向上分切了。它可以解决OOP和过程化方法不能够很好解决的横切（crosscut）问题，如：事务、安全、日志等横切关注。</p><p>实现AOP有几种方式：</p><ol><li>Spring 1.2版本中通过ProxyFactoryBean来实现aop,即通过动态代理来实现的,Aspect必须继承MethodBeforeAdvice,MethodAfterAdvice等。</li><li>Spring 2.0 AOP需要改的是FBI 这个类，而且它也不需要再实现某些接口。</li><li>三使用标注（@AspectJ）实现AOP。</li></ol><p>AOP 和 OOP的区别：</p><ol><li>面向方面编程 AOP 偏重业务处理过程的某个步骤或阶段，强调降低模块之间的耦合度，使代码拥有更好的移植性。</li><li>面向对象编程 (oop) 则是对业务分析中抽取的实体进行方法和属性的封装。<br>也可以说 AOP 是面向业务中的动词领域， OOP 面向名词领域。<br>AOP 的一个很重要的特点是源代码无关性，也就是说如果我们的系统中引用了 AOP 组件，即使我们把该组件去掉，系统代码也应该能够编译通过。要实现这一点，可以使用动态 proxy 模式。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/jonesAriven/article/details/80036602&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;spring与springmvc的区别与联系&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
      <category term="FrameWorks" scheme="https://mlone.top/tags/FrameWorks/"/>
    
      <category term="spring" scheme="https://mlone.top/tags/spring/"/>
    
      <category term="springmvc" scheme="https://mlone.top/tags/springmvc/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis与Hibernate的区别</title>
    <link href="https://mlone.top/post/3141c602.html"/>
    <id>https://mlone.top/post/3141c602.html</id>
    <published>2018-12-28T08:50:36.000Z</published>
    <updated>2019-02-28T08:45:08.964Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><h4 id="什么是mybatis？"><a href="#什么是mybatis？" class="headerlink" title="什么是mybatis？"></a>什么是mybatis？</h4><p>mybatis是一个持久层的框架，是apache下的顶级项目。一开始托管到goolecode下，再后来托管到github下(<a href="https://github.com/mybatis/mybatis-3/releases)。" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3/releases)。</a></p><p>mybatis让程序将主要精力放在sql上，通过mybatis提供的映射方式，自由灵活生成（半自动化，大部分需要程序员编写sql）满足需要sql语句。</p><p>mybatis可以将向 preparedStatement中的输入参数自动进行<strong>输入映射，</strong>将查询结果集灵活映射成java对象。<strong>（输出映射）</strong></p><h4 id="Mybatis与Hibernate的区别？"><a href="#Mybatis与Hibernate的区别？" class="headerlink" title="Mybatis与Hibernate的区别？"></a>Mybatis与Hibernate的区别？</h4><p><strong>hibernate：</strong></p><p>是一个标准ORM框架（对象关系映射）。入门门槛较高的，不需要程序写sql，sql语句自动生成了。对sql语句进行优化、修改比较困难的。</p><p><strong>应用场景：</strong>适用与需求变化不多的中小型项目，比如：后台管理系统，erp、orm、oa…</p><p><strong>mybatis：</strong></p><p>专注于sql本身，需要程序员自己编写sql语句，sql修改、优化比较方便。<br>mybatis是一个不完全 的ORM框架，虽然程序员自己写sql，mybatis 也可以实现映射（输入映射、输出映射）。</p><p><strong>应用场景：</strong>适用与需求变化较多的项目，比如：互联网项目。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
      <category term="FrameWorks" scheme="https://mlone.top/tags/FrameWorks/"/>
    
      <category term="hibernate" scheme="https://mlone.top/tags/hibernate/"/>
    
      <category term="mybatis" scheme="https://mlone.top/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Struts2学习笔记</title>
    <link href="https://mlone.top/post/85eb9bf0.html"/>
    <id>https://mlone.top/post/85eb9bf0.html</id>
    <published>2018-12-27T08:50:36.000Z</published>
    <updated>2019-02-28T08:38:03.040Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><h4 id="1-什么是Struts2？"><a href="#1-什么是Struts2？" class="headerlink" title="1.什么是Struts2？"></a>1.什么是Struts2？</h4><p>javaEE三层架构：表现层、业务层、持久层，为了提高开发效率，方便项目管理。</p><p>技术结构发展：</p><ol><li>单独使用jsp/servlet、</li><li>使用jsp+javabean：（model1模式）、</li><li>使用：jsp+servlet+javaBean（model2模式）</li></ol><p>Model2模式即MVC模式，MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写。</p><p>存在的问题：</p><ol><li>控制逻辑复杂且不通用（多个请求得写多个Servlet）。</li><li>表现（视图）技术单一，只使用jsp，能否使用其它表现层技术（freemarker，pdf、xls）。</li><li>对请求的参数的解析（需手动单独获取每个参数request.getParameter()）。</li></ol><p>Struts2 是apache的一个开源项目，它是纯java开发，它是一个非常优秀的MVC框架，基于Model2 设计模型。</p><h4 id="2-Struts2的结构优点"><a href="#2-Struts2的结构优点" class="headerlink" title="2.Struts2的结构优点"></a>2.Struts2的结构优点</h4><p>解决jsp+servlet+javabean中的问题：</p><ol><li>将控制逻辑单独封装成通用的控制器</li><li>原控制逻辑中封装请参数、调用业务逻辑代码抽取出来。</li><li>支持多视图技术。</li></ol><p>（1）控制器</p><p>struts2提供前端控制器（Struts2PreparedAndExecutFilter），将控制逻辑封装起来，接收请求。</p><p>（2）模型</p><p>封装请求参数，进行业务处理。<br>struts2提供了action接口，根据业务需求开发不同的action，比如：注册用户Action</p><p>（3）提供Result接口，支持多视图技术</p><p>Result将结果响应给用户。</p><h4 id="3-Struts2处理请求的全过程是什么"><a href="#3-Struts2处理请求的全过程是什么" class="headerlink" title="3.Struts2处理请求的全过程是什么?"></a>3.Struts2处理请求的全过程是什么?</h4><ol><li><p>当客户端浏览器向服务器端发送请求，会被Struts2的核心前端控制器（一个过滤器）所拦截，然后根据struts2.xml配置文件中的内容来决定调用哪个前端控制器action；</p></li><li><p>前端控制器action接收到请求后，会根据请求的method方法名调用函数进行处理；</p></li><li><p>处理完成后，会返回一个逻辑视图名，然后根据struts2.xml中配置的action的result来决定要跳转到哪个前端页面。</p></li></ol><h4 id="4-属性驱动"><a href="#4-属性驱动" class="headerlink" title="4.属性驱动"></a>4.属性驱动</h4><p>属性驱动是struts2提供的一种参数绑定机制，如果按照struts指定的开发规则，自动请求的参数设置（赋值）到struts的action类的属性中。</p><p>属性驱动开发规则：</p><ol><li>确定请求参数的名称。</li><li>在action类中添加属性，属性名和参数名称一致，并且添加 get/set方法。</li></ol><p>属性驱动支持不同action类属性类型：包括基本数据类型、list、map、数组、pojo。</p><p>重点掌握：1.基本类型 2.pojo  3.数组 4.list</p><h4 id="5-模型驱动"><a href="#5-模型驱动" class="headerlink" title="5.模型驱动"></a>5.模型驱动</h4><p><strong>问题描述：</strong>使用属性驱动，如果业务方法比较多，添加很多属性及get/set方法，不方便对业务方法进行维护。</p><p><strong>解决方案：</strong>将action中接收参数属性及get/set方法单独放到其它pojo中，action只剩下业务方法。可以使用struts2提供模型驱动方法开发action。</p><p><em>Ognl和值栈是实现模型驱动的基础原理。</em></p><p><em>OGNL是Xwork框架提供的功能，Xwork是struts2基础架构，Xwork是一个ioc容器。</em></p><p><em>OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，它是一个开源项目，struts2使用ognl，作为表达式语言。</em></p><p><em>使用OGNL可以方便向对象中设置属性值，从对象中获取属性值。</em></p><p><strong>模型驱动：</strong>模型驱动是将请求参数绑定到专门的模型对象中，Action实现ModelDriven接口并指定模型对象类型，模型对象类型即为pojo。</p><h4 id="6-拦截器"><a href="#6-拦截器" class="headerlink" title="6.拦截器"></a>6.拦截器</h4><p>struts2中通过拦截器实现<strong>参数绑定、参数校验、类型转换</strong>，拦截器就是<strong>在action的执行之前或之后</strong>进行拦截执行一些代码，就是对action代码的增强。</p><p><strong>拦截器的特点：</strong></p><ol><li>如果使用拦截器可以很方便访问值栈中的数据；</li><li>filter过滤器，可以拦截所有的请求；而struts2的拦截器只能拦截用户的请求，即action请求。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
      <category term="FrameWorks" scheme="https://mlone.top/tags/FrameWorks/"/>
    
      <category term="struts2" scheme="https://mlone.top/tags/struts2/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate学习笔记</title>
    <link href="https://mlone.top/post/993a1961.html"/>
    <id>https://mlone.top/post/993a1961.html</id>
    <published>2018-12-26T08:50:36.000Z</published>
    <updated>2019-02-28T08:27:22.520Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><h4 id="1-Hibernate的核心配置文件是什么及其作用"><a href="#1-Hibernate的核心配置文件是什么及其作用" class="headerlink" title="1.Hibernate的核心配置文件是什么及其作用?"></a>1.Hibernate的核心配置文件是什么及其作用?</h4><p>hibernate框架默认会加载classpath下的核心配置文件hibernate.cfg.xml</p><p>作用：</p><ol><li>加载对象关系映射文件；</li><li>配置hibernate运行的参数(属性)<br>，如会话工厂所需要的属性：</li></ol><p>数据库方言（决定了hibenrate发出哪个数据库认识的sql语句）、驱动、<br>连接url、用户名和密码，数据库连接池、事务隔离级别，开启二级缓存等。</p><h4 id="2-sessionFactory会话工厂生命周期"><a href="#2-sessionFactory会话工厂生命周期" class="headerlink" title="2.sessionFactory会话工厂生命周期"></a>2.sessionFactory会话工厂生命周期</h4><p>整个运行过程中只有一个sessionFactory实例即可，使用单例模式管理sessionFactory。<br>sessionFactory是线程安全的！</p><h4 id="3-Hibernate中有哪几种关联关系？"><a href="#3-Hibernate中有哪几种关联关系？" class="headerlink" title="3.Hibernate中有哪几种关联关系？"></a>3.Hibernate中有哪几种关联关系？</h4><p><strong>4种：</strong></p><p>一对一，一对多，多对一，多对多</p><h4 id="4-Hibernate对象的三大状态："><a href="#4-Hibernate对象的三大状态：" class="headerlink" title="4.Hibernate对象的三大状态："></a>4.Hibernate对象的三大状态：</h4><ul><li><p><strong>瞬时态 transient</strong></p><p>  new了一个对象，此时对象就是瞬时态；</p><p>  瞬时态对象和数据库记录没有对应关系，和session没有关系。</p></li><li><p><strong>持久态 persistent</strong></p><p>  瞬时态对象执行save方法后变成持久态；</p><p>  持久态对象和数据库记录存在对应关系，和session有关系。</p><p>  修改对象的属性，会直接将数据保存到数据库中。</p></li><li><p><strong>托管态Detached</strong></p><p>  当session关闭后，持久态对象变为托管态。</p><p>  托管态对象和session没有关系，可能和数据库存在对应也可能不对应。</p></li></ul><h4 id="5-QBC"><a href="#5-QBC" class="headerlink" title="5.QBC"></a>5.QBC</h4><p>QBC（Query By Criteria）按条件查询，通过Criteria构造查询条件，即通过调用Criteria的api实现各种查询。</p><p>通过Criteria对象拼装 查询条件，调用Criteria的add方法拼接查询条件，最终hibernate通过criteria对象自动生成sql语句。</p><h4 id="6-一级缓存与二级缓存"><a href="#6-一级缓存与二级缓存" class="headerlink" title="6.一级缓存与二级缓存"></a>6.一级缓存与二级缓存</h4><p><strong>一级缓存：</strong></p><ol><li>session级别的缓存，是线程级别的缓存；</li><li>在session中有一块内存区域，存储了持久态的对象；</li><li>第一次从数据库查询到数据存到session, 当session不关闭，再次查询不会向数据库发出sql；</li><li>当session关闭了，一级缓存就会被清空。</li></ol><p><strong>二级缓存：</strong></p><p>sessionFactory级别的缓存，是进程级别的缓存；</p><p>可以跨session，多个session可以公用二级缓存的数据。</p><p><strong>二级缓存区域：</strong></p><p><strong>1. 类级别缓冲区，存储了散装对象</strong></p><p>数据结构：map<br>[ key：对象的主键值+对象的全类路径，value：对象内容 ]</p><p><strong>2. 查询缓存区域，存储了查询结果集</strong></p><p>任意执行一个sql语句，将sql结果进行缓存</p><p>数据结构：map [ key：sql语句本身+输入参数，value就是List&lt;对象的主键值&gt; ]</p><h4 id="7-延迟加载"><a href="#7-延迟加载" class="headerlink" title="7.延迟加载"></a>7.延迟加载</h4><p><strong>什么是延迟加载？</strong></p><p>当查询信息，建议只查询需要的信息，对于不需要信息当需要时再去查询，这叫延迟加载。</p><p>好处：提高查询性能。</p><p>例子：对象导航查询。</p><ol><li><p>只查询基本信息，不查询关联属性;</p></li><li><p>当调用cstCustomer对象的get方法获取关联属性，再向数据库发出sql，去加载数据。</p></li></ol><p><strong>Get与Load：</strong></p><p>load执行原理：</p><ol><li>执行load查询，得到的是一个代理对象，没有发出sql</li><li>当调用get方法时，通过代理对象向数据库发出sql</li></ol><p><strong>延迟加载原理：</strong></p><ol><li>生成一个代理对象</li><li>执行加载时，通过代理对象向数据库发出sql</li></ol><h4 id="8-抓取策略"><a href="#8-抓取策略" class="headerlink" title="8.抓取策略"></a>8.抓取策略</h4><p><strong>什么是抓取策略？</strong></p><p>指当应用程序需要在（Hibernate实体对象图的）关联关系间进行导航的时候， Hibernate如何获取关联对象的策略。</p><p>策略包括：</p><ol><li>延迟加载</li><li>立即加载，将加载到数据抓取到对象的属性中。</li></ol><p><strong>（1）类级别的抓取策略</strong><br>(这里的lazy是class标签的属性，默认为true)</p><ol><li>延迟加载<br> 在hbm.xml中class标签内设置lazy=”true”（延迟加载），相当于load方法;</li><li>立即加载<br> 在hbm.xml中class标签内设置lazy=”false”，立即加载，load和get方法效果一样。</li></ol><p><strong>（2）关联级别的抓取策略（重点掌握）</strong></p><p><strong>一对多、多对多：</strong><br>（这里的fetch和lazy位于class标签下的<set>标签上，fetch=”select” lazy=”true”：此为一方的默认值）</set></p><p>set元素提供 lazy属性 和 fetch 用于设置 抓取策略</p><ol><li>fetch=”select”(默认)，lazy=”true”(默认)：fetch=”select”每get请求发出sql，lazy=”true”表示延迟加载<br>（一方lazy的值可设为true或false或extra）;</li><li>fetch=”join”（lazy不起作用）：批量抓取，自动生成左外连接语句，将关联的多方数据抓取到一方的属性中。</li><li>(一般不用) fetch=”select”（或不写），lazy=”false”，立即加载（注意：但这里的并不是生成左外连接sql，而是新建的查询sql语句去查外联表）。</li></ol><p>最佳实践：</p><p>在进行一对多、多对多关联查询时候，只查询基本信息而不需要关联多方数据的，一般情况下最好采用延迟加载的抓取策略。（就像查询客户列表时并不需要立即加载其联系人信息，就将两个表的关系映射配置为延迟加载，即默认设置）</p><p><strong>多对一：</strong><br>（这里的fetch和lazy位于class标签下的<many-to-one>标签上，fetch=”select” lazy=”proxy”：此为多方的默认值）<br>根据客户查询客户来源，多对一。</many-to-one></p><p>hbm采用 <many-to-one>元素，提供lazy属性和fetch属性，用来配置抓取策略</many-to-one></p><ol><li>fetch=”join”：自动生成左外连接，将关联一方属性对象抓取到多方的属性，查询客户信息，将many-to-one中fetch设置join，通过qbc查询客户时自动生成一个客户表和数据字典表的关联查询语句。</li><li>fetch=”select”，lazy=”proxy”：延迟加载</li><li>(扩展) fetch=”select”（或不写），lazy=”false”：立即加载。比如在查询联系人信息时，会连带其所属的客户信息一并查询出来（注意：但这里的并不是生成左外连接sql，而是新建的查询sql语句去查客户表）。</li></ol><h4 id="9-HQL"><a href="#9-HQL" class="headerlink" title="9.HQL"></a>9.HQL</h4><p>HQL是Hibernate Query Language缩写， 语法很像SQL语法，以完全面向对象的方式操作数据库。<br>（QBC能做的HQL都能做，而反之不然）</p><p><strong>HQL对象导航方式：</strong>Hql可以实现对象导航查询。</p><p>注意：如果使用投影查询，得到List中是舜时态对象，不能使用对象导航。</p><p><strong>HQL关联查询：</strong><br>因为经过测试：</p><ol><li>HQL对hbm.xml设置 fetch参数无效；</li><li>HQL对hbm.xml设置lazy=true，lazy=false有效。<br>所以通过HQL实现fetch=”join”的功能。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="FrameWorks" scheme="https://mlone.top/categories/FrameWorks/"/>
    
    
      <category term="FrameWorks" scheme="https://mlone.top/tags/FrameWorks/"/>
    
      <category term="hibernate" scheme="https://mlone.top/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>forward和redirect的区别</title>
    <link href="https://mlone.top/post/a78a807b.html"/>
    <id>https://mlone.top/post/a78a807b.html</id>
    <published>2018-12-25T11:26:25.000Z</published>
    <updated>2019-02-27T10:07:25.401Z</updated>
    
    <content type="html"><![CDATA[<p>请求转发和重定向</p><a id="more"></a><p>forward：请求转发，属于同一请求，浏览器的url不会改变，request域中的数据不会丢失。</p><p>redirect：重定向，属于不同的请求，浏览器的url改变，request域中的数据清空。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请求转发和重定向&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
      <category term="web" scheme="https://mlone.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>JSP有哪些内置对象</title>
    <link href="https://mlone.top/post/23a05b25.html"/>
    <id>https://mlone.top/post/23a05b25.html</id>
    <published>2018-12-25T09:26:25.000Z</published>
    <updated>2019-02-27T10:07:25.398Z</updated>
    
    <content type="html"><![CDATA[<p>JSP共9个内置对象：</p><a id="more"></a><p>page、request、session 、application、（四大域对象）</p><p>response、out、config、exception、</p><p>pageContext（可以获取其他八个内置对象；可以操作域；可以全域查找findAttribute）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JSP共9个内置对象：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
      <category term="jsp" scheme="https://mlone.top/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>Cookie与Session</title>
    <link href="https://mlone.top/post/5321d6b2.html"/>
    <id>https://mlone.top/post/5321d6b2.html</id>
    <published>2018-12-25T08:50:36.000Z</published>
    <updated>2019-02-27T10:09:49.796Z</updated>
    
    <content type="html"><![CDATA[<p>描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。<br><a id="more"></a></p><p><strong>Cookie：</strong>保存在本地客户端。</p><p>如果不设置有效时间则默认为一次会话时间，即浏览器关闭即销毁。</p><p>应用：比如，存储用户的登录信息，用户名、密码。</p><p><strong>Session：</strong>保存在服务器端，保存一次会话。</p><p>当浏览器访问服务器时，服务器会创建一个session会话与当前客户端进行连接。</p><p>何时销毁：</p><ol><li>程序调用HttpSession.invalidate()方法主动进行销毁；</li><li>距离客户端上一次发送请求超过了Session的最大有效时间；</li><li>服务器进程被停止。</li></ol><p>应用：保存用户状态，比如购物车中添加商品。</p><p><strong>Session的机制：</strong></p><p>一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息。</p><p>当程序需要为某个客户端的请求创建一个session的时候，服务器会首先检查这个客户端的请求中是否包含session标识－session id，如果已包含则说明以前为此客户创建过session，服务器就会根据session id把这个session检索出来使用；</p><p>如果客户请求中不包含session id，则为此客户新建一个session并同时生成一个相关联的session id，这个session id将在本次响应中返回给客户端保存。</p><p><strong>二者区别：</strong></p><ul><li>存储数据量方面：session 能够存储任意的 java 对象，cookie 只能存储 String 类型的对象</li><li>一个在客户端一个在服务端，因为Cookie在客户端所以可以编辑伪造，不是十分安全</li><li>Session过多时会消耗服务器资源，大型网站会有专门Session服务器，Cookie存在客户端没问题</li><li>域的支持范围不一样，比方说a.com的Cookie在a.com下都能用，而<a href="http://www.a.com的Session在api.a.com下都不能用，解决这个问题的办法是*JSONP跨域请求或者跨域资源共享" target="_blank" rel="noopener">www.a.com的Session在api.a.com下都不能用，解决这个问题的办法是*JSONP跨域请求或者跨域资源共享</a>*</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;描述Cookie和Session的作用，区别和各自的应用范围，Session工作原理。&lt;br&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
      <category term="web" scheme="https://mlone.top/tags/web/"/>
    
      <category term="cookie" scheme="https://mlone.top/tags/cookie/"/>
    
      <category term="session" scheme="https://mlone.top/tags/session/"/>
    
  </entry>
  
  <entry>
    <title>Servlet的生命周期</title>
    <link href="https://mlone.top/post/ce1ea3ff.html"/>
    <id>https://mlone.top/post/ce1ea3ff.html</id>
    <published>2018-12-25T06:26:25.000Z</published>
    <updated>2019-02-27T10:07:25.399Z</updated>
    
    <content type="html"><![CDATA[<p>共四个阶段：</p><a id="more"></a><p>（1）Servlet被类的加载器ClassLoad加载,</p><p>（2）调用其中的init()方法进行初始化，</p><p>（3）调用其中的响应方法，如doGet()、doPost()</p><p>（4）当请求不会再被调用或者当服务器关闭时，会调用其中的destroy()方法进行销毁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;共四个阶段：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaWeb" scheme="https://mlone.top/categories/JavaWeb/"/>
    
    
      <category term="servlet" scheme="https://mlone.top/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>整数中1出现的次数</title>
    <link href="https://mlone.top/post/42e11ab6.html"/>
    <id>https://mlone.top/post/42e11ab6.html</id>
    <published>2018-12-22T09:55:12.000Z</published>
    <updated>2019-02-26T15:09:31.998Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p><p><strong>代码：</strong> <a href="https://www.nowcoder.com/profile/448404/codeBookDetail?submissionId=1505827" target="_blank" rel="noopener">https://www.nowcoder.com/profile/448404/codeBookDetail?submissionId=1505827</a></p><pre><code>public class Solution {    public int NumberOf1Between1AndN_Solution(int n) {        int count=0;        while(n&gt;0){ //遍历n到1            String str = String.valueOf(n); //整数转字符串            char[] arr = str.toCharArray(); //字符串转字符数组            for(int i=0; i&lt;arr.length; i++){                if(arr[i]==&apos;1&apos;)                    count++;            }            n--;        }        return count;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>把字符串转换成整数</title>
    <link href="https://mlone.top/post/9b7ea8ca.html"/>
    <id>https://mlone.top/post/9b7ea8ca.html</id>
    <published>2018-12-20T09:55:12.000Z</published>
    <updated>2019-02-26T15:06:04.137Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><p><strong>代码：</strong></p><pre><code>class Solution {    public int StrToInt(String str) {        if(str.equals(&quot;&quot;) || str.length()==0) return 0; //非空判断        char[] cs = str.toCharArray();        int res = 0;        int symbol = 1;         if(cs[0] == &apos;-&apos;) symbol=-1;        for(int i=(cs[0]==&apos;-&apos; || cs[0]==&apos;+&apos;) ? 1:0; i&lt;cs.length; i++){            if(cs[i]&lt;&apos;0&apos; || cs[i]&gt;&apos;9&apos;) //if(cs[i]&lt;48 || cs[i]&gt;57)                return 0;            res = (res&lt;&lt;1)+(res&lt;&lt;3)+(cs[i]&amp;0xf);//res=res*10+cs[i]-&apos;0&apos;;            /**             * 左移是乘以2的次方(res&lt;&lt;1)+(res&lt;&lt;3) = res*2+res*8 = res*10             * 字符&apos;0&apos;到&apos;9&apos;的ascii值的低4个二进制位刚好就是0到9所以cs[i]&amp;0xf等于cs[i]-&apos;0&apos;。              * 位运算会比乘法运算效率高那么一点点点点...             *              * ASCII码是7位或8位的，如&apos;0&apos;--&gt;十进制48--&gt;二进制0011 0000             * 而十六进制等于四位二进制，如0xf--&gt;二进制1111             * 所以&apos;0&apos; &amp; 0xf == 00110000 &amp; 1111 == 0000 = 十进制0             * 而&apos;0&apos;-&apos;0&apos; == 48 -48 == 0 （减号两边的字符&apos;0&apos;会先被转换为十进制ascii码值48，然后再做运算）             */        }         return res*symbol;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>数组中重复的数字</title>
    <link href="https://mlone.top/post/8f265477.html"/>
    <id>https://mlone.top/post/8f265477.html</id>
    <published>2018-12-19T09:55:12.000Z</published>
    <updated>2019-02-26T15:09:52.509Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><p><strong>代码：</strong></p><p><strong>方式一：</strong>（最愚蠢的做法，类似“不正统的冒泡排序2”）时间复杂度为T=O(n^2)</p><p><em>从numbers[i] (0&lt;=i&lt;=n-2)开始，分别与余下的numbers[i+1]~ numbers[n-1]进行比对，一旦找到重复的元素，就将其放到duplicate[0]中并返回true，否则返回false。<br>length为数组numbers的长度（似乎有点多余？）。</em></p><pre><code>public class Solution {    public boolean duplicate(int numbers[],int length,int [] duplication) {        if( numbers==null || numbers.length==0)            return false; //非空判断        length = numbers.length;        for(int i=0; i&lt;length-1; i++){            for(int j=i+1; j&lt;length; j++){                if(numbers[i]==numbers[j]){                    duplication[0]=numbers[i];                    return true;                }            }        }        return false;    }}</code></pre><p><strong>方式二：</strong>将数组元素转换成字符串装进StringBuffer中，然后从首末两端查找同一元素，若找到的两个下标不同，则说明该元素重复。时间复杂度为T=O(n),但是消耗内存空间。</p><pre><code>public class Solution {    public boolean duplicate(int numbers[],int length,int [] duplication) {    StringBuffer sb = new StringBuffer();         for(int i = 0; i &lt; length; i++){                sb.append(numbers[i] + &quot;&quot;);            }        for(int j = 0; j &lt; length; j++){            if(sb.indexOf(numbers[j]+&quot;&quot;) != sb.lastIndexOf(numbers[j]+&quot;&quot;)){                duplication[0] = numbers[j];                return true;            }        }        return false;    }}</code></pre><p><strong>方式三：</strong>（建议这种）题目里写了数组里数字的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志，当一个数字被访问过后将标志位置为true。T=O(n)</p><pre><code>//boolean只占一位，所以还是比较省的public boolean duplicate(int numbers[], int length, int[] duplication) {    boolean[] k = new boolean[length];    for (int i = 0; i &lt; k.length; i++) {        if (k[numbers[i]] == true) {            duplication[0] = numbers[i];            return true;        }        k[numbers[i]] = true;    }    return false;}</code></pre><p><strong>方式四：</strong>（最机智的解法，但是我没咋明白）不需要额外的数组，题目里写了数组里数字的范围保证在0 ~ n-1 之间，所以可以利用现有数组设置标志，当一个数字被访问过后，可以设置对应位上的数 + n，之后再遇到相同的数时，会发现对应位上的数已经大于等于n了，那么直接返回这个数即可。T=O(n)</p><pre><code>public boolean duplicate(int numbers[],int length,int [] duplication) {        if( numbers==null || numbers.length==0)            return false;        for(int i=0; i&lt;length; i++){            int index = numbers[i];            if (index&gt;=length)                  index-=length;            if(numbers[index]&gt;=length){                duplication[0]=index;                return true;            }            numbers[index] = numbers[index]+length;        }        return false;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>字符串的全排列</title>
    <link href="https://mlone.top/post/6eef7a7f.html"/>
    <id>https://mlone.top/post/6eef7a7f.html</id>
    <published>2018-12-18T09:55:12.000Z</published>
    <updated>2019-02-26T15:10:29.896Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p><strong>解析：</strong>基于回溯法思想</p><p>参考：<a href="https://www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/fe6b651b66ae47d7acce78ffdd9a96c7</a></p><p><img src="/assets/blogImg/5/7.png" alt="图片7"></p><p>全排列就是从第一个数字起，每个数分别与它后面的数字交换：</p><p><em>固定第一个字符，递归取得首位后面的各种字符串组合；</em></p><p><em>再把第一个字符与后面每一个字符交换，并同样递归获得首位后面的字符串组合。</em></p><p><strong>代码：</strong></p><pre><code>import java.util.List;import java.util.Collections;import java.util.ArrayList;public class Solution {    public ArrayList&lt;String&gt; Permutation(String str) {        List&lt;String&gt; res = new ArrayList&lt;&gt;(); //创建结果集        if (str != null &amp;&amp; str.length() &gt; 0) { //参数非空判定            PermutationHelper(str.toCharArray(), 0, res);//扔进参数，一顿操作            Collections.sort(res); //按字典顺序对结果集进行排序        }        return (ArrayList)res; //返回结果集    }    //操作函数    public void PermutationHelper(char[] cs, int i, List&lt;String&gt; list) {        if (i == cs.length - 1) { //递归终止条件，当下标i已经移到char数组的末尾的时候，考虑添加这一组字符串到结果集中            String val = String.valueOf(cs);            if (!list.contains(val)) //排除结果集中的重复字符串元素                list.add(val);        } else {           //这一段就是“回溯法”            //递归的思想与栈的入栈和出栈是一样的,某一个状态遇到return结束了之后，会回到被调用的地方继续执行            for (int j = i; j &lt; cs.length; j++) {                swap(cs, i, j);                PermutationHelper(cs, i+1, list); //递归子序列                swap(cs, i, j); //将元素再调换回来，以免影响下趟循环（j=i+1）            }        }    }    //交换字符数组中两下标元素的位置    public void swap(char[] cs, int i, int j) {        char temp = cs[i];        cs[i] = cs[j];        cs[j] = temp;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="排列组合" scheme="https://mlone.top/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>不用加减乘除作加法</title>
    <link href="https://mlone.top/post/e61a0090.html"/>
    <id>https://mlone.top/post/e61a0090.html</id>
    <published>2018-12-17T09:55:12.000Z</published>
    <updated>2019-02-26T15:05:47.056Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><p><strong>解析：</strong></p><p>首先看十进制是如何做的： 5+7=12，分三步走</p><ul><li>第一步：相加各位的值，不算进位，得到2。</li><li>第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 </li><li>第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。</li></ul><p>同样我们可以用三步走的方式计算二进制值相加： 5-101，7-111 </p><ul><li>第一步：相加各位的值，不算进位，得到010，二进制每位相加就相当于各位做异或操作，101^111。</li><li>第二步：计算进位值，得到1010，相当于各位做与操作得到101，再向左移一位得到1010，(101&amp;111)&lt;&lt;1。</li><li>第三步重复上述两步， 各位相加 010^1010=1000，进位值为100=(010&amp;1010)&lt;&lt;1。<br>继续重复上述两步：1000^100 = 1100，进位值为0，跳出循环，1100为最终结果。</li></ul><p><strong>代码：</strong></p><pre><code>public class Solution {    public int Add(int num1,int num2) {        while(num2!=0){            int temp=num1^num2; //计算当前位值            num2=(num1&amp;num2)&lt;&lt;1; //计算进位值            num1=temp;        }        return num1;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>递归求前n项和</title>
    <link href="https://mlone.top/post/952e1d5a.html"/>
    <id>https://mlone.top/post/952e1d5a.html</id>
    <published>2018-12-16T09:55:12.000Z</published>
    <updated>2019-02-26T15:05:35.120Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A ? B:C）</p><p><strong>代码：</strong></p><pre><code>public class Solution {    public int Sum_Solution(int n) {        if(n==1) return 1;        return n+Sum_Solution(n-1);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="递归" scheme="https://mlone.top/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>包含min函数的栈</title>
    <link href="https://mlone.top/post/11cbd9c1.html"/>
    <id>https://mlone.top/post/11cbd9c1.html</id>
    <published>2018-12-16T08:55:12.000Z</published>
    <updated>2019-02-26T15:05:58.677Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O(1)）</p><p><strong>代码：</strong></p><pre><code>import java.util.Stack;import java.util.Iterator;public class Solution {    Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();    public void push(int node) {        stack.push(node);    }    public void pop() {        stack.pop();    }    public int top() {        return stack.peek();    }    public int min() {        int min=stack.peek();        int tmp;        Iterator&lt;Integer&gt; iterator = stack.iterator();        while(iterator.hasNext()){            tmp=iterator.next();            if(tmp&lt;min)                min=tmp;        }        return min;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>顺时针打印矩阵</title>
    <link href="https://mlone.top/post/952c518.html"/>
    <id>https://mlone.top/post/952c518.html</id>
    <published>2018-12-15T08:55:12.000Z</published>
    <updated>2019-02-26T15:10:41.307Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><p><img src="/assets/blogImg/5/6.png" alt="图片6"></p><p><strong>代码：</strong></p><pre><code>import java.util.ArrayList;public class Solution {    public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) {        if(matrix==null || matrix.length==0) //非空判定            return null;       ArrayList&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();       printOuterRace(matrix, 0, 0, matrix.length-1, matrix[0].length-1, result);       return result;    }    //顺时针打印矩阵最外圈元素：右--&gt;下--&gt;左--&gt;上    public void printOuterRace(int[][] matrix,int startRow,int startCol,int endRow,int endCol,ArrayList&lt;Integer&gt; result) {        if(startRow&lt;endRow &amp;&amp; startCol&lt;endCol){ //（1）多行多列            for(int i=startCol; i&lt;=endCol; i++) result.add(matrix[startRow][i]); //向右输出首行            for(int i=startRow+1; i&lt;=endRow-1; i++) result.add(matrix[i][endCol]); //向下输出尾列            for(int i=endCol; i&gt;=startCol; i--) result.add(matrix[endRow][i]); //向左输出尾行            for(int i=endRow-1; i&gt;=startRow+1; i--) result.add(matrix[i][startCol]); //向上输出首列            printOuterRace(matrix,startRow+1,startCol+1,endRow-1,endCol-1,result); //继续打印下一圈元素        }        else if(startRow==endRow &amp;&amp; startCol&lt;endCol){ //（2）就一行            for(int i=startCol; i&lt;=endCol; i++) result.add(matrix[startRow][i]);        }        else if(startRow&lt;endRow &amp;&amp; startCol==endCol){ //（3）就一列            for(int i=startRow; i&lt;=endRow; i++) result.add(matrix[i][startCol]);        }        else if(startRow==endRow &amp;&amp; startCol==endCol){ //（4）就一个元素            result.add(matrix[startRow][startCol]);        }        else //（5）角标越界            return;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="遍历" scheme="https://mlone.top/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的镜像</title>
    <link href="https://mlone.top/post/5bf14681.html"/>
    <id>https://mlone.top/post/5bf14681.html</id>
    <published>2018-12-13T08:55:12.000Z</published>
    <updated>2019-02-26T15:05:30.064Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>操作给定的二叉树，将其变换为源二叉树的镜像：</p><p><img src="/assets/blogImg/5/5.png" alt="图片5"></p><p><strong>代码：</strong>即是Swap函数的函数递归版</p><pre><code>/**public class TreeNode {    int val = 0;    TreeNode left = null;    TreeNode right = null;    public TreeNode(int val) {        this.val = val;    }}*/public class Solution {    public void Mirror(TreeNode root) {        TreeNode temp;        if(root!=null){            temp=root.left;            root.left=root.right;            root.right=temp;          //  if(root.left!=null)                Mirror(root.left);          //  if(root.right!=null)                Mirror(root.right);        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>树的子结构</title>
    <link href="https://mlone.top/post/53dd15fc.html"/>
    <id>https://mlone.top/post/53dd15fc.html</id>
    <published>2018-12-12T08:55:12.000Z</published>
    <updated>2019-02-26T15:10:55.831Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）。</p><p><strong>代码：</strong></p><pre><code>public class Solution {    public static boolean HasSubtree(TreeNode root1, TreeNode root2) {        boolean result = false;        //当两树都不为null的时候，才进行比较。否则直接返回false        if (root2 != null &amp;&amp; root1 != null) {            //如果两树的当前根节点值相等            if(root1.val == root2.val)                //就判断以root1为根节点的Tree1是否包含（或相等）Tree2                result = doesTree1HaveTree2(root1,root2);            //如果不包含，向左递归            if (!result)                result = HasSubtree(root1.left,root2);            //如果不包含，向右递归            if (!result)                result = HasSubtree(root1.right,root2);        }            //返回查找结果            return result;    }</code></pre><p>//Tree1以node1为起点，Tree2以node2为起点，分别开始向下进行匹配。判断Tree1是否包含（或相等）Tree2</p><pre><code>    public static boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2) {        //如果Tree2已经遍历完了且都能对应的上Tree1，返回true        if (node2 == null)            return true;        else if(node1 == null)            //如果Tree2还没有遍历完，Tree1却遍历完了（说明Tree2比Tree1大），返回false            return false;        //如果其中有一个点没有对应上，就返回false        if (node1.val != node2.val)                   return false;        else            //如果根节点对应的上，那么就分别再去匹配左右子结点的值，看是否也能对应的上。（左比左，右比右）            return doesTree1HaveTree2(node1.left,node2.left) &amp;&amp; doesTree1HaveTree2(node1.right,node2.right);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>合并两个排序的链表</title>
    <link href="https://mlone.top/post/faa1cd64.html"/>
    <id>https://mlone.top/post/faa1cd64.html</id>
    <published>2018-12-10T08:55:12.000Z</published>
    <updated>2019-02-26T15:12:13.854Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><p><strong>方式一：</strong>（迭代）参考归并排序的Merge函数</p><pre><code>/*public class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*/public class Solution {    public ListNode Merge(ListNode list1,ListNode list2) {        if(list1==null) //参数非空判定            return list2;        if(list2==null)            return list1;        ListNode root; //保留合并后的链表头        if(list1.val&lt;=list2.val)  root=list1;        else   root=list2;        ListNode p1=list1;        ListNode p2=list2; //定义两个指针分别指向两个链表        ListNode head=new ListNode(-1); //创建一个结点来使后置结点指向下一个较小结点                                       //这里的val值无论是-1或其他值都无所谓        while((p1!=null)&amp;&amp;(p2!=null)){            if(p1.val&lt;=p2.val){                head.next=p1; //让head(上个较小结点)的后置结点指向当前较小结点                head=p1; //更新head使其指向当前较小结点                p1=p1.next; //指针p1后移一位            }else{                head.next=p2;                head=p2;                p2=p2.next;            }        }        if(p1!=null)  head.next=p1; //若list1有剩余        if(p2!=null)  head.next=p2; //若list2有剩余        return root;    }}</code></pre><p><strong>方式二：</strong>（递归）可由上面的迭代代码理解下列递归代码</p><pre><code>public class Solution {    public ListNode Merge(ListNode list1,ListNode list2) {        if(list1==null) //参数非空判定；递归终止条件            return list2;        if(list2==null)            return list1;        ListNode phead; //定义一个指针用来指向当前较小结点            if(list1.val&lt;=list2.val){                phead=list1;                phead.next=Merge(list1.next,list2);            }else{                phead=list2;                phead.next=Merge(list1,list2.next);            }        return phead;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>翻转链表</title>
    <link href="https://mlone.top/post/230b8655.html"/>
    <id>https://mlone.top/post/230b8655.html</id>
    <published>2018-12-10T06:55:12.000Z</published>
    <updated>2019-02-26T15:12:31.006Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入一个链表，反转链表后，输出新链表的表头：</p><p><strong>代码：</strong></p><pre><code>/*public class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*/public class Solution {    public ListNode ReverseList(ListNode head) {         if(head==null) //传入参数head是反转前的链表头0            return null;         ListNode pre = null; //用于存储当前节点head的前置节点         ListNode next = null; //用于存储当前节点head指向的下一节点         while(head!=null){ //判断是否到达链表末尾，如果当前节点head为null，则代表其前置节点pre节点是尾节点                            //pre节点即上次（最后一次）进行while循环操作的“当前head节点”             next = head.next; //先拿到head指向的下一节点1             head.next = pre; //再将head指向其前置节点             pre = head; //把当前节点head作为下一次循环的前置节点             head = next; //把下一节点1当做下次循环的当前节点             // 以上几步的顺序不能变，否则会导致链表断裂: 0&lt;-1 2-&gt;3         }        return pre;    }    // 反转前0-&gt;1-&gt;2-&gt;3    // 翻转后0&lt;-1&lt;-2&lt;-3}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>链表中倒数第K个结点</title>
    <link href="https://mlone.top/post/d67309a5.html"/>
    <id>https://mlone.top/post/d67309a5.html</id>
    <published>2018-12-10T05:55:12.000Z</published>
    <updated>2019-02-26T15:12:44.495Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入一个链表，输出该链表中倒数第k个结点。</p><p><strong>解析：</strong>先算出链表长度total，然后返回第total-K+1个结点。</p><p><strong>代码：</strong></p><pre><code>/*public class ListNode {    int val;    ListNode next = null;    ListNode(int val) {        this.val = val;    }}*/public class Solution {    public ListNode FindKthToTail(ListNode head,int k) {        int total=0;        if(head==null)            return null; //这里的参数非null判断其实不加也行，若head为null则下面的代码也会返回null        ListNode node=head;        while(node!=null){            total++;            node=node.next;        }        if(k&lt;=total){            node=head;            for(int i=1; i&lt;=total-k; i++){                node=node.next;            }            return node;        }        return null;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>调整数组顺序，使奇数位于偶数前面</title>
    <link href="https://mlone.top/post/8ddb6e50.html"/>
    <id>https://mlone.top/post/8ddb6e50.html</id>
    <published>2018-12-09T05:55:12.000Z</published>
    <updated>2019-02-26T15:12:55.511Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><p><strong>解析：</strong></p><p>类似大元素下沉的冒泡排序：<strong>前后两两相比较，前偶后奇则调换位置</strong>，每趟排序一个偶数沉底。</p><p>（不能使用小数/奇数上浮的冒泡排序，它无法保证偶数的相对位置保持不变。）</p><p><strong>代码：</strong></p><pre><code>public class Solution {    public void reOrderArray(int [] array) {        for(int i=array.length-1; i&gt;0; i--){            for(int j=0; j&lt;i; j++){                if((array[j]%2==0)&amp;&amp;(array[j+1]%2==1)){                    int temp = array[j];                    array[j] = array[j+1];                    array[j+1] = temp;                }            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>数值的整数次方</title>
    <link href="https://mlone.top/post/a5d3b8f.html"/>
    <id>https://mlone.top/post/a5d3b8f.html</id>
    <published>2018-12-08T03:55:12.000Z</published>
    <updated>2019-02-26T15:13:04.903Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p><strong>解析： </strong>     </p><p><em>1.全面考察指数的正负、底数是否为零等情况。</em></p><p><em>2.写出指数的二进制表达，例如13表达为二进制1101。</em></p><p><em>3.举例:10^1101 = 10^0001</em>10^0100<em>10^1000。</em></p><p><em>4.通过&amp;1和&gt;&gt;1来逐位读取1101，为1时将该位代表的乘数累乘到最终结果。</em></p><p><strong>代码：</strong></p><pre><code>class Solution {    public double Power(double base, int exponent) {        int exp;        if(exponent==0) //指数为0            return 1;        else if(exponent&lt;0){ //指数为负整数            if(base==0) //底数为0，即分母为0                throw new RuntimeException(&quot;指数为负整数，则底数不能为0！&quot;);            exp = -exponent;        }        else            exp = exponent; //指数为正整数        double sum=1;        while(exp!=0){            if((exp&amp;1)==1){ //括号不能少                sum=sum*base; //base * base^2 * base^4 * base^8 = base^(1+2+4+8) = base^1111            }            base=base*base; //翻倍：base、base^2、base^4、base^8            exp=exp&gt;&gt;1; //右移一位        }        return exponent&gt;0?sum:1/sum;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="https://mlone.top/post/33147ff9.html"/>
    <id>https://mlone.top/post/33147ff9.html</id>
    <published>2018-12-08T02:55:12.000Z</published>
    <updated>2019-02-26T15:07:50.313Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。</p><p><strong>解法一：</strong>（十进制整数–&gt;二进制字符串–&gt;字符数组）</p><pre><code>public class Solution {    public int NumberOf1(int n) {        char[] arr = Integer.toBinaryString(n).toCharArray();        int count=0;        for(int i=0; i&lt;arr.length; i++){            if(arr[i]==&apos;1&apos;) //==可用于基本数据类型值的比较；或判断两个引用变量是否指向内存中的同一地址                count++;        }        return count;    }}</code></pre><p><strong>解法二：</strong>（绝妙解法，同样适用于负整数）</p><pre><code>public class Solution {    public int NumberOf1(int n) {        int count=0;        while(n!=0){            count++;            n = n&amp;(n-1);        }        return count;    }}</code></pre><p><strong>解析：</strong></p><p>如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。</p><p>举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&amp;1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>矩形覆盖</title>
    <link href="https://mlone.top/post/5f2a74af.html"/>
    <id>https://mlone.top/post/5f2a74af.html</id>
    <published>2018-12-07T06:55:12.000Z</published>
    <updated>2019-02-26T15:13:19.084Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p><strong>解析：</strong></p><p>（1）当 n = 1时，只存在一种情况：</p><p><img src="/assets/blogImg/5/1.jpg" alt="图1"></p><p>（2）当 n = 2时，存在两种情况：</p><p><img src="/assets/blogImg/5/2.jpg" alt="图2"></p><p>（3）当 n &gt;= 3时，分为两步考虑：</p><p>（3.1） 第一次摆放一块 2*1 的小矩阵，则余下的摆放方法总共为f(target - 1)</p><p><img src="/assets/blogImg/5/3.png" alt="图3"></p><p>（3.2）第一次摆放一块1*2的小矩阵，则余下的摆放方法总共为f(target-2)</p><p>因为，摆放了一块1<em>2的小矩阵（用√√表示），对应下方的1</em>2（用××表示）摆放方法就确定了，所以为f(targte-2)</p><p><img src="/assets/blogImg/5/4.png" alt="图4"></p><p>故得出结论：<strong><em>f(target) = f(target - 1)+ f(target - 2)</em></strong></p><p><strong>代码：</strong></p><pre><code>public class Solution {    public int RectCover(int target) {        if(target&lt;=0)            return 0;        else if(target==1 || target==2)            return target;        else            return RectCover(target-1)+RectCover(target-2);        }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>变态跳台阶</title>
    <link href="https://mlone.top/post/b34e4534.html"/>
    <id>https://mlone.top/post/b34e4534.html</id>
    <published>2018-12-07T05:55:12.000Z</published>
    <updated>2019-02-26T15:05:53.943Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><p><strong>规律：</strong></p><p>因为n级台阶，第一步有n种跳法：跳1级、跳2级…跳n级：</p><p>跳1级，剩下n-1级，则剩下跳法是f(n-1)；</p><p>跳2级，剩下n-2级，则剩下跳法是f(n-2)；</p><p>…</p><p>跳n-1级，剩下1级，则剩下跳法是f(1)；</p><p>跳n级，剩下0级，则就1种跳法.</p><p>所以<em>f(n)=f(n-1)+f(n-2)+…+f(1)+1</em></p><p>又因为f(n-1)=f(n-2)+f(n-3)+…+f(1)+1  所以<em>f(n)=2</em>f(n-1)*</p><p><strong>解法一：</strong>（函数递归）</p><p>使用规律：<em>f(n)=2</em>f(n-1)*</p><pre><code>public class Solution {    public int JumpFloorII(int target) {        if(target&lt;=0) return 0; //f(0)        if(target==1) return 1; //f(1)        return JumpFloorII(target-1)*2; //f(n)    }}</code></pre><p><strong>解法二：</strong>（迭代）</p><p>使用规律：<em>f(n)=f(n-1)+f(n-2)+…+f(1)+1</em></p><pre><code>public class Solution {    public int JumpFloorII(int target) {        if(target&lt;=0) return 0;        if(target==1) return 1;        int[] arr = new int[target+1]; //动态分配堆内存        arr[0]=1;        arr[1]=1;        for(int i=2; i&lt;=target; i++){            for(int j=0; j&lt;i; j++){                arr[i]+=arr[j]; //f(n)=f(n-1)+f(n-2)+...+f(1)+1            }        }        return arr[target];    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
  </entry>
  
  <entry>
    <title>跳台阶</title>
    <link href="https://mlone.top/post/ffada3b2.html"/>
    <id>https://mlone.top/post/ffada3b2.html</id>
    <published>2018-12-07T03:55:12.000Z</published>
    <updated>2019-02-26T15:13:31.714Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）</p><p><strong>解法一：</strong>（下台阶）</p><pre><code>public class Solution {    public int JumpFloor(int target) {        if(target&lt;=0)            return 0; //target&lt;=0，不合法的输入值        if(target==1)            return 1; //1级台阶只有1种跳法：1（向下递归终止条件1，开始向上返回递归）        if(target==2)            return 2; //2级台阶有2种跳法:1,2（向下递归终止条件2，开始向上返回递归）        else // target&gt;=3            return JumpFloor(target-2)+JumpFloor(target-1); //从上往下计算，即“下台阶”    }}</code></pre><p><strong>解法二：</strong></p><p>规律：JumpFloor(target)= JumpFloor(target-2)+JumpFloor(target-1)）</p><p>可得数列<em>JumpFloor(1)、JumpFloor(2)、… JumpFloor(n)</em> 为“斐波那契数列”（0除外）。</p><pre><code>public class Solution {    public int JumpFloor(int target) {        if(target&lt;=0)            return 0; //target&lt;=0，不合法的输入值        if(target==1)            return 1; //1级台阶只有1种跳法：1（向下递归终止条件1，开始向上返回递归）        if(target==2)            return 2; //2级台阶有2种跳法:1,2（向下递归终止条件2，开始向上返回递归）        else {//target&gt;=3            int j1=1,j2=2;            int j3=0;            while(target&gt;=3){ //当做斐波那契数列处理，从第3项开始                j3 = j1 + j2;                j1 = j2;                j2 = j3;                target--;            }            return j3;        }        }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="https://mlone.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>斐波那契数列的第n项</title>
    <link href="https://mlone.top/post/5e64c5aa.html"/>
    <id>https://mlone.top/post/5e64c5aa.html</id>
    <published>2018-12-07T02:55:12.000Z</published>
    <updated>2019-02-26T15:13:47.302Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>求斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39<br>（时间限制：1秒   空间限制：32768K）</p><p><strong>解法一：</strong>函数递归（运行时间：1008ms  占用内存：9320k）</p><pre><code>public class Solution1 {    public int Fibonacci(int n) {        if(n=0) return 0;        if(n=1) return 1; //0、1        return Fibonacci(n-2)+Fibonacci(n-1);    }}</code></pre><p><strong>解法二</strong>：迭代for循环+1个数组（运行时间：15ms  占用内存：9308k）效率明显提高</p><pre><code>public class Solution2 {    public int Fibonacci(int n) {        if(n=0) return 0;        if(n=1) return 1; //0、1        int[] arr = new int[n+1];        arr[0]=0;        arr[1]=1;        for(int i=2; i&lt;=n; i++){            arr[i]=arr[i-1]+arr[i-2];        }        return arr[n];    }}</code></pre><p><strong>解法三：</strong>迭代for循环+3个变量（运行时间：16ms  占用内存：9260k）内存降了100KB</p><pre><code>public class Solution3 {    public int Fibonacci(int n) {        if(n=0) return 0;        if(n=1) return 1; //0、1        int i0 = 0, i1 = 1;        int i2 = 0;        for(int i=2; i&lt;=n; i++){ //从第2项到第n项            i2 = i0 + i1;            i0 = i1; //向后平移一位，进入下次循环            i1 = i2;        }        return i2;    }}</code></pre><p><strong>解法四：</strong>迭代while循环+3个变量（运行时间：17ms  占用内存：9236k）变化不大</p><pre><code>public class Solution4 {    public int Fibonacci(int n) {        if(n=0) return 0;        if(n=1) return 1; //0、1        int i0 = 0, i1 = 1;        int i2 = 0;        while(n&gt;=2){            i2 = i0 + i1;            i0 = i1; //向后平移一位，进入下次循环            i1 = i2;            n--;        }        return i2;    }}</code></pre><p><strong>解法五：</strong>动态规划，迭代while循环+2个变量（运行时间：17ms  占用内存：9204k）变化不大</p><pre><code>public class Solution5 {    public int Fibonacci(int n) {        int i0=0, i1=1;        while(n&gt;0){            i1 = i0 + i1; //向后平移一位，进入下次循环            i0 = i1 - i0;            n--;        }        return i0;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="动态规划" scheme="https://mlone.top/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>自然数组</title>
    <link href="https://mlone.top/post/9aaffcef.html"/>
    <id>https://mlone.top/post/9aaffcef.html</id>
    <published>2018-12-06T02:55:12.000Z</published>
    <updated>2019-02-26T15:14:07.841Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>二分查找的进一步应用：对于一个自然数（从0开始）数组，从中随机删除一个元素，请使用二分查找算法找出这个未知元素。</p><p>例如：</p><ul><li>角标：0,1,2,3,4,5,6,7,…</li><li>元素：0,1,2,4,5,6,7,8,…</li></ul><p><strong>坑1：</strong>如果待查询的范围最后只剩两个数(即最后一次迭代循环)：[2,4]，那么mid 一定会指向下标靠前的数字，<br>即arr[low=mid=high-1]=2,arr[high]=4</p><p><strong>代码：</strong></p><pre><code>public static int BSearchTest(int[] arr){    int low=0,high=arr.length-1;    while(low&lt;high){ //当只剩余一个元素时终止while迭代循环        int mid = (low+high)/2;        if(arr[mid]==mid) //（临界）情况1：[2,4]            low = mid+1; //由坑1）导致的坑2：）这里mid必须+1，不能为low=mid，否则最后一次迭代会陷入无限循环                         //然后剩余最后一个元素arr[low=mid=high]=4.跳出while循环返回arr[high]-1或arr[low]-1        else if(arr[mid]&gt;mid) //（临界）情况2：[2,4,5]            high = mid; //然后进入情况1    }    return arr[low]-1; //arr[high]-1}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>旋转数组中的最小数字</title>
    <link href="https://mlone.top/post/a9f65c43.html"/>
    <id>https://mlone.top/post/a9f65c43.html</id>
    <published>2018-12-06T02:55:12.000Z</published>
    <updated>2019-02-26T15:14:17.224Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。</p><p> NOTE：给出的所有元素都大于0，若数组大小为0，请返回0：</p><p><strong>解析：</strong></p><p>采用二分法解答这个问题，</p><p>mid = low + (high - low)/2</p><p>需要考虑三种情况：</p><p>(1)array[mid] &gt; array[high]:</p><p>出现这种情况的array类似[3,4,5,6,0,1,2]，此时最小数字一定在mid的右边。</p><p>low = mid + 1</p><p>(2)array[mid] == array[high]:</p><p>出现这种情况的array类似 [1,0,1,1,1] 或者[1,1,1,0,1]，此时最小数字不好判断在mid左边还是右边,这时只好一个一个试 ，</p><p>high = high - 1</p><p>(3)array[mid] &lt; array[high]:</p><p>出现这种情况的array类似[2,2,3,4,5,6,6],此时最小数字一定就是array[mid]或者在mid的左边。因为右边必然都是递增的。</p><p>high = mid</p><p><strong>注意这里有个坑（坑1）：如果待查询的范围最后只剩两个数(即最后一次迭代循环)，那么mid 一定会指向下标靠前的数字：</strong></p><p>比如 array = [4,6]</p><p>array[low] = 4 ;array[mid] = 4 ; array[high] = 6 ;</p><p>如果high = mid - 1，就会产生错误， 因此high = mid</p><p>但情形(1)中low = mid + 1就不会错误</p><p><strong>考虑临界情况：(最后一次迭代循环)</strong></p><p>情形1：<em>[max,min]时，array[mid]max，而array[high]min，此时满足if条件：array[mid]&gt; array[high]，将执行low=mid+1；然后只剩余一个元素：array[low=mid=high]=min，跳出while循环返回array[low]或array[high]即可。</em></p><p>情形2：<em>[min,max]时，array[mid]min，而array[high]min，此时满足if条件：array[mid]&lt; array[high]，将执行high=mid；然后只剩余一个元素：array[low=mid=high]=min，跳出while循环返回array[low]或array[high]即可。</em></p><p><strong>综合1、2，即将最后一个元素锁定到min即可，即设法当跳出循环时使其满足array[low=high]=min</strong></p><p><strong>代码：（二分查找的迭代形式）</strong></p><pre><code>public class Solution {    public int minNumberInRotateArray(int [] array) {        int low = 0 ; int high = array.length - 1;           while(low &lt; high){            int mid = (low + high)/2;                    if(array[mid] &gt; array[high])               //这里mid必须+1，否则面对剩余两个元素：[max,min]情况时会陷入无限循环low = mid + 1; //由坑1导致的坑2            else if(array[mid] == array[high])                high = high - 1;            else                high = mid;        }        return array[low];    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈来实现一个队列</title>
    <link href="https://mlone.top/post/e7d7743b.html"/>
    <id>https://mlone.top/post/e7d7743b.html</id>
    <published>2018-12-06T01:55:12.000Z</published>
    <updated>2019-02-26T15:14:28.416Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型：</p><p><strong>代码：</strong></p><pre><code>import java.util.Stack;public class Solution {    Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();    public void push(int node) {        stack1.push(node);    }    public int pop() {        while(!stack1.isEmpty()){            stack2.push(stack1.pop());        }        int first = stack2.pop();        while(!stack2.isEmpty()){            stack1.push(stack2.pop());        }        return first;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>重建二叉树</title>
    <link href="https://mlone.top/post/97fc4ab0.html"/>
    <id>https://mlone.top/post/97fc4ab0.html</id>
    <published>2018-12-06T00:55:12.000Z</published>
    <updated>2019-02-26T15:15:13.495Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回：</p><p><strong>代码：</strong></p><pre><code>/** * Definition for binary tree * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */public class Solution {     public TreeNode reConstructBinaryTree(int [] pre,int [] in) {        TreeNode root=reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);        return root;     }    //前序遍历{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}    private TreeNode reConstructBinaryTree(int [] pre,int startPre,int endPre,int [] in,int startIn,int endIn) {        if(startPre&gt;endPre||startIn&gt;endIn)            return null;        TreeNode root=new TreeNode(pre[startPre]);        for(int i=startIn;i&lt;=endIn;i++)            if(in[i]==pre[startPre]){                root.left=reConstructBinaryTree(pre,startPre+1,startPre+i-startIn,in,startIn,i-1);                root.right=reConstructBinaryTree(pre,i-startIn+startPre+1,endPre,in,i+1,endIn);break;       }        return root;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>从尾到头打印链表</title>
    <link href="https://mlone.top/post/b724efa.html"/>
    <id>https://mlone.top/post/b724efa.html</id>
    <published>2018-12-05T15:55:12.000Z</published>
    <updated>2019-02-26T15:05:42.069Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList：</p><p><strong>解法一：（使用栈）</strong></p><pre><code>  /** *    public class ListNode { *        int val; *        ListNode next = null; * *        ListNode(int val) { *            this.val = val; *        } *    } */import java.util.ArrayList;import java.util.Stack;public class Solution {    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        while(listNode!=null){            stack.push(listNode.val);            listNode = listNode.next;        }        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        while(!stack.isEmpty()){            list.add(stack.pop());        }        return list;    }}</code></pre><p><strong>解法二：（使用函数递归）</strong></p><pre><code>import java.util.ArrayList;public class Solution {    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();    public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) {        if(listNode != null){            this.printListFromTailToHead(listNode.next);            list.add(listNode.val);        }        return list;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="遍历" scheme="https://mlone.top/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>替换空格</title>
    <link href="https://mlone.top/post/cd96fb91.html"/>
    <id>https://mlone.top/post/cd96fb91.html</id>
    <published>2018-12-05T14:55:12.000Z</published>
    <updated>2019-02-26T15:15:24.140Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy：</p><p><strong>代码：</strong></p><pre><code>public class Solution {    public String replaceSpace(StringBuffer str) {        if(str == null){            return null;        }        for(int i=0; i&lt;str.length(); i++){            if(str.charAt(i)==&apos; &apos;){                str.replace(i,i+1,&quot;%20&quot;); //这个replace方法是StringBuffer的，并非String的            }        }        return str.toString();    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>二维数组中的查找</title>
    <link href="https://mlone.top/post/2aa4f70.html"/>
    <id>https://mlone.top/post/2aa4f70.html</id>
    <published>2018-12-05T13:55:12.000Z</published>
    <updated>2019-02-26T15:04:16.475Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数：</p><p><strong>解析：</strong></p><p><em>把每一行看成有序递增的数组，利用二分查找，通过遍历每一行得到答案。</em></p><p>时间复杂度T=O(nlogn)</p><p><strong>代码：</strong></p><pre><code>public class Solution {    public boolean Find(int target, int [][] array) {        for(int i=0; i&lt;array.length; i++){ //一个for循环+二分查找            int left = 0;            int right = array[i].length-1;            int mid;            while(left&lt;=right){                mid = (left+right)/2;                if(target&lt;array[i][mid])                    right = mid-1;                else if(target&gt;array[i][mid])                    left = mid+1;                else                    return true;            }        }        return false;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="剑指offer" scheme="https://mlone.top/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>求二叉树的最大路径和</title>
    <link href="https://mlone.top/post/c88e8ab0.html"/>
    <id>https://mlone.top/post/c88e8ab0.html</id>
    <published>2018-12-04T13:55:12.000Z</published>
    <updated>2019-02-26T14:55:25.770Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://blog.csdn.net/mine_song/article/details/69951308" target="_blank" rel="noopener">https://blog.csdn.net/mine_song/article/details/69951308</a></p><a id="more"></a><p><strong>代码：</strong></p><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */public class Solution {    // 全局变量，记录最大路径和private int maxVal = Integer.MIN_VALUE;    public int maxPathSum(TreeNode root) {        if (root == null)            return 0;        maxCore(root);        return maxVal;    }    // 该函数返回是左右的最大路径和，而非左+右+root的最大值    // 使用curValue，来标记左+右+root    private int maxCore(TreeNode root) {        if (root == null)            return 0;        // 求以root为根的当前子树的最大路径和        // 如果左右子树都是负数，        // 那么就最大路径就是当前结点值（无论正负）        int curValue = root.val;        int lmax = maxCore(root.left);        int rmax = maxCore(root.right);        if (lmax &gt; 0)            curValue += lmax;        if (rmax &gt; 0)            curValue += rmax;        maxVal = Math.max(curValue, maxVal);        // 返回以当前root为根的子树的最大路径和        // 左右有可能都为负数，所以需要参与比较大小        int thisMax = Math.max(root.val,                 Math.max(lmax + root.val,                         rmax + root.val));        return thisMax;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：&lt;a href=&quot;https://blog.csdn.net/mine_song/article/details/69951308&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/mine_song/article/details/69951308&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="贪心法" scheme="https://mlone.top/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>求二叉树的最大直径</title>
    <link href="https://mlone.top/post/feb46f07.html"/>
    <id>https://mlone.top/post/feb46f07.html</id>
    <published>2018-12-04T12:55:12.000Z</published>
    <updated>2019-02-26T14:55:25.769Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://blog.csdn.net/mine_song/article/details/69951308" target="_blank" rel="noopener">https://blog.csdn.net/mine_song/article/details/69951308</a></p><a id="more"></a><p><strong>基本思想：</strong></p><ul><li>二叉树的直径：二叉树中从一个结点到另一个节点<strong>最长</strong>的路径，叫做二叉树的直径</li><li>采用分治和递归的思想：</li></ul><p>　　根节点为root的二叉树的直径 = Max(左子树直径，右子树直径，左子树的最大深度（不包括根节点）+右子树的最大深度（不包括根节点）+1)</p><p><strong>代码：</strong></p><pre><code>/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */public class Solution {    // 全局变量，用于记录最大直径    int diameter = 0;    public int diameterOfBinaryTree(TreeNode root) {        getDepth(root);        return diameter;    }    // 此函数是返回树的最大深度    private int getDepth(TreeNode root) {        if (root == null) //作用1.传入实参非空判定；             return 0;      //作用2.若到达叶子结点就直接返回0（向下递归终止条件，开始向上返回递归）        int l = getDepth(root.left); //向左递归        int r = getDepth(root.right); //向右递归        diameter = Math.max(diameter, l + r); //记录直径        return Math.max(l, r) + 1; //返回结果    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：&lt;a href=&quot;https://blog.csdn.net/mine_song/article/details/69951308&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/mine_song/article/details/69951308&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="贪心法" scheme="https://mlone.top/tags/%E8%B4%AA%E5%BF%83%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>统计txt文件中出现的某个字符串次数</title>
    <link href="https://mlone.top/post/e9735223.html"/>
    <id>https://mlone.top/post/e9735223.html</id>
    <published>2018-12-02T13:34:19.000Z</published>
    <updated>2019-02-26T12:49:58.944Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代码：</strong></p><a id="more"></a><p>参考：<a href="https://www.cnblogs.com/mlan/p/7811382.html" target="_blank" rel="noopener">https://www.cnblogs.com/mlan/p/7811382.html</a></p><pre><code>public class strCounts {    //主函数    public static int process(File file, String key){        FileInputStream fis = null;        int sum = 0;        try{           fis = new FileInputStream(file);           int len = 0;           byte[] buf = new byte[1024];           String str = null;           while((len = fis.read(buf)) !=-1){               str = new String(buf, 0, len,&quot;GBK&quot;);               int count = getKeyStringCount(str,key);                sum = sum + count;           }        }catch(FileNotFoundException e){            e.printStackTrace();        } catch (UnsupportedEncodingException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally{           try {               fis.close();           } catch (IOException e) {               e.printStackTrace();           }       }       return sum;    }</code></pre><p>// 统计主串str中子串key出现的次数（注意，这不同于模式匹配算法！）</p><pre><code>public static int getKeyStringCount(String str, String key) {             int count = 0;     int index = 0;    //indexOf(key,index):返回指定子串的第一次出现的字符串中的索引，从指定的索引开始       while((index = str.indexOf(key,index))!=-1){              index = index + key.length();         count++;                    }                 return count; }</code></pre><p>//测试</p><pre><code>    public static void main(String[] args) {       File file = new File(&quot;D:/test.txt&quot;);       String key = &quot;aa&quot;;       int sum = process(file, key);       System.out.println(&quot;文件中字符串&quot;+key+&quot;出现的次数为：&quot;+sum+&quot;次&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>统计txt文件中出现的某个字符数</title>
    <link href="https://mlone.top/post/63e0e4de.html"/>
    <id>https://mlone.top/post/63e0e4de.html</id>
    <published>2018-12-02T12:34:19.000Z</published>
    <updated>2019-02-26T12:49:58.945Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代码：</strong></p><a id="more"></a><pre><code>public class charCounts {    public static int process(File file, char c){        int count=0;        BufferedReader br = null;        try{            br = new BufferedReader(new FileReader(file));            String temp = &quot;&quot;;            while((temp=br.readLine()) != null){                char[] des = temp.trim().toCharArray();                for(int i=0; i&lt;des.length; i++){                    if(des[i]==c){                        count++;                    }                }            }        }catch(FileNotFoundException e){            e.printStackTrace();        }catch(IOException e){            e.printStackTrace();        }finally{            try{                br.close();            }catch(IOException e){                e.printStackTrace();            }        }        return count;    }</code></pre><p>//测试</p><pre><code>    public static void main(String[] args){        String path = &quot;D:/test.txt&quot;; //或&quot;D://test.txt&quot;或&quot;D:\\test.txt&quot;        File file = new File(path);        char des = &apos;a&apos;;        int count = process(file,des);        System.out.println(&quot;字符&quot;+des+&quot;在文中出现的次数为：&quot;+count);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>模式匹配的KMP算法</title>
    <link href="https://mlone.top/post/53e89967.html"/>
    <id>https://mlone.top/post/53e89967.html</id>
    <published>2018-12-01T13:34:19.000Z</published>
    <updated>2019-02-26T12:51:19.865Z</updated>
    
    <content type="html"><![CDATA[<p>来源：《数据结构：使用C++语言描述》</p><a id="more"></a><p><strong>代码：</strong></p><p>参考：<a href="blog.csdn.net/scgaliguodong123_/article/details/49148017">blog.csdn.net/scgaliguodong123_/article/details/49148017 </a></p><p> 模式匹配的KMP算法：</p><p>  　　比简单模式匹配算法多了个失败函数，利用失败数组next去除匹配过程中毫无意义的回溯对比。</p><pre><code>public class KMPMatch {    /**     * @param s 主串     * @param t 子串     * @param pos 从主串的pos下标开始进行模式匹配     * @return     */    public int indexKMP(String s, String t, int pos) {        int i = pos; //下标i指向主串（只进不退）        int j = 0; //下标j指向子串（若匹配失败就退回到“合适的”位置）        int[] next = getNext(t); //由子串t获构建 失败数组next        while (i &lt; s.length() &amp;&amp; j &lt; t.length()) {            if (j == -1 || s.charAt(i) == t.charAt(j)) {                 i++;                j++;            } else { //匹配失败，重新进行匹配                j = next[j]; //下标j退回到合适的位置，i值不变            }        }        if (j &gt;= t.length()) {            return i - t.length();        } else {            return 0;        }    }</code></pre><p>//失败函数    </p><pre><code>/** * 失败函数：构建“失败next数组” *   设长度为m的子串T=&quot;t1t2...t(m-1)&quot;，k为相同的前、后缀子串长，next数组定义为 *             *           |--&gt; -1, 当j=0时 *   next[j]=|--&gt; max{ k|0&lt;k&lt;j且 t1 t2 ... t(k-1) = t(j-k) t(j-k+1) ... t(j-1)} *           |--&gt; 0, 其他情况 * @param t 子串 * @return */public int[] getNext(String t) {    int[] next = new int[t.length()];    int i = 0;    int j = -1;    next[i] = j; //令next[0]=-1    while (i &lt; t.length()-1) {        if (j == -1 || t.charAt(i) == t.charAt(j)) {            i++;            j++;            next[i] = j; //初次next[1]=0        } else {            j = next[j]; //若字符不相等，则j值进行回溯        }    }    //将next数组打印出来，看看是什么样子的    System.out.println(Arrays.toString(next));    return next;}</code></pre><p>// 测试</p><pre><code>    public static void main(String[] args) {        KMPMatch test = new KMPMatch();        System.out.println(test.indexKMP(&quot;goodgoogle&quot;, &quot;google&quot;, 0));    }}</code></pre><p>输出：</p><pre><code>[-1, 0, 0, 0, 1, 0]4</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：《数据结构：使用C++语言描述》&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>简单模式匹配算法</title>
    <link href="https://mlone.top/post/cdfa5b00.html"/>
    <id>https://mlone.top/post/cdfa5b00.html</id>
    <published>2018-12-01T12:34:19.000Z</published>
    <updated>2019-02-26T12:49:58.943Z</updated>
    
    <content type="html"><![CDATA[<p>来源：《数据结构：使用C++语言描述》</p><a id="more"></a><p><strong>代码：</strong></p><p>参考：<a href="blog.csdn.net/scgaliguodong123_/article/details/49148017">blog.csdn.net/scgaliguodong123_/article/details/49148017 </a></p><pre><code>public class SimpleMatch {    /**     * 从主串s中匹配子串t，若匹配成功则返回子串t第一次出现的起始下标；若匹配失败返回-1.     *      * @param s 主串     * @param t 子串     * @param pos 从主串的pos下标开始进行模式匹配     * @return     */    public int Index(String s, String t, int pos) {        int i = pos;// 下标i指向主串        int j = 0;// 下标j指向子串        while (i &lt; s.length() &amp;&amp; j &lt; t.length()) {            if (s.charAt(i) == t.charAt(j)) {                i++;                j++;            } else { //重头开始比对                i = i - j + 1;// 下标i回到主串的下一位置pos++                 j = 0;// 下标j回到子串首端            }        }        if (j &gt;= t.length()) {             return i - t.length(); //匹配成功，返回比对成功的主串开始下标        } else {            return -1; //匹配失败        }    }</code></pre><p>//测试</p><pre><code>    public static void main(String[] args) {        SimpleMatch test = new SimpleMatch();        System.out.println(test.Index(&quot;goodgoogle&quot;, &quot;google&quot;, 0)); //4        System.out.println(test.Index(&quot;goodgoogle&quot;, &quot;google&quot;, 2)); //4    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：《数据结构：使用C++语言描述》&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>欧几里得算法(辗转相除法)</title>
    <link href="https://mlone.top/post/4859ffd9.html"/>
    <id>https://mlone.top/post/4859ffd9.html</id>
    <published>2018-11-29T04:35:35.000Z</published>
    <updated>2019-02-26T12:49:58.939Z</updated>
    
    <content type="html"><![CDATA[<p>求最大公约数</p><a id="more"></a><p>来源：《算法分析与设计：采用C++语言描述》</p><p><strong>代码</strong></p><pre><code>public class GcdTest {    /** 欧几里得迭代算法 **/    public int Gcd(int m, int n){        if(m==0) return n;        if(n==0) return m;        if(m&gt;n){int tmp=m; m=n; n=tmp;}        while(m&gt;0){            int c=n%m;            n=m;            m=c;        }        return n;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;求最大公约数&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>求第K小元素(也即是求最小的K个数)第二篇</title>
    <link href="https://mlone.top/post/a4eccdbd.html"/>
    <id>https://mlone.top/post/a4eccdbd.html</id>
    <published>2018-11-28T04:35:35.000Z</published>
    <updated>2019-02-26T12:49:58.940Z</updated>
    
    <content type="html"><![CDATA[<p>来源：<a href="https://www.nowcoder.com/profile/448404/codeBookDetail?submissionId=1505827" target="_blank" rel="noopener">https://www.nowcoder.com/profile/448404/codeBookDetail?submissionId=1505827</a></p><a id="more"></a><p><strong>基本思想</strong></p><p>   　　基本思想与上一篇相同、分划函数相同，主函数也是分治思想，不过没有随机取主元。</p><p><strong>代码：</strong></p><pre><code>public class SelectTest2 {    public int[] GetLeastNumbers_Solution(int[] input, int k) {        int[] res = new int[k];        int len=input.length;        if(len==0||k&gt;len||k==0) return res;        if(len==k) return input;        int start=0;        int end=len-1;        int j=Partition(input,start,end);        while(j!=k-1){            if(j&gt;k-1)                j=Partition(input,start,j-1); //结合Partition函数，此处应为right=j-1，当K=0时不会发生下标越界            else                j=Partition(input,j+1,end); //此处应为left=j+1，因为当K=l.length时，函数直接return input，不会再执行Partition函数，从而不会发生下标越界；                                            //若此处为left=j，则右递归的主元一直都会是l[j]，会导致此处无尽循环。        }        for(int i=0; i&lt;k; i++)            res[i]=input[i];        return res;    }</code></pre><p>//分划函数 </p><pre><code>public static int Partition(int[] l, int left, int right){    //前置条件：left&lt;=right    int i=left, j=right+1; //哨兵位（防止越界）    do{        do i++; while(l[i]&lt;l[left]&amp;&amp;i&lt;right);  //从首端向后找到&gt;=l[left]的元素l[i]则停止；或i=right时停止        do j--; while(l[j]&gt;l[left]); //从末端向前找到&lt;=l[left]的元素l[j]则停止；或当j=left时l[j]=l[left]自动停止        if(i&lt;j) Swap(l, i, j); //若大元素在小元素的前面则调换二者位置    }while(i&lt;j); //若未越界则继续查找和调换    Swap(l, left, j); //调换l[left]和l[j]    return j;}/** 调换两个元素的位置 **/public static void Swap(int[] l, int i, int j) {    int temp = l[i];    l[i] = l[j];    l[j] = temp;}</code></pre><p>//测试</p><pre><code>    public static void main(String[] args){        int[] input = {4,5,1,6,2,7,3,8};        SelectTest2 s = new SelectTest2();        int[] res = s.GetLeastNumbers_Solution(input,6);        System.out.println(Arrays.toString(input));        System.out.println(Arrays.toString(res));    } }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：&lt;a href=&quot;https://www.nowcoder.com/profile/448404/codeBookDetail?submissionId=1505827&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.nowcoder.com/profile/448404/codeBookDetail?submissionId=1505827&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>求第K小元素(也即是求最小的K个数)</title>
    <link href="https://mlone.top/post/2b97d2a0.html"/>
    <id>https://mlone.top/post/2b97d2a0.html</id>
    <published>2018-11-27T04:35:35.000Z</published>
    <updated>2019-02-26T12:49:58.942Z</updated>
    
    <content type="html"><![CDATA[<p>来源：《算法分析与设计：采用C++语言描述》</p><a id="more"></a><p><strong>基本思想：</strong></p><p>求第k小元素（也即是求最小的K个元素）平均T=O(n)，最坏Tmax=O(n^2) –&gt;与快速排序相同</p><p>   　　<em>对于求最大、最小元问题，在MaxMin.java中已经得到渐进时间复杂度为O(n)的算法，即线性时间算法。</em></p><p>当1&lt;k&lt;=n/logn时，可以使用堆排序求第k小元素：</p><p>   　　<em>首先构造一个堆，其时间为O(n)，然后依次输出前k个小元素，得到第k小元素。</em></p><p>   　　<em>由于没输出一个元素的时间为O(logn)，所以，求第k小元素的元素的时间为O(n+klogn)，这也是线性时间。</em></p><p>   　　<em>然而，对于任意给定的k，当1&lt;=k&lt;=n时，要设计求第k小元素的线性时间算法，并不十分容易，需要做一番努力。</em></p><p><strong>代码：（由C++改写的Java代码）</strong></p><pre><code>public class SelectTest {    /**     * 假定表中元素各不相同，并且随机选择主元，即在下标区间[left,right]中随机选择一个下标r，以该下标处的元素为主元。     * 函数Partition对区间[left,right]的元素实施分划操作，经过一趟分划，主元的下标为j，     * 区间[left,j-1]中的元素均小于主元，区间[j+1,right]中的元素均大于主元。     * 此时，若k=j+1，则表示下标为j的元素就是第k小元素；若k&lt;j+1,则在范围[left,j-1]中继续寻找，     * 否则在范围[j+1,right]范围内继续寻找。     *      * @param l 要查找的数组     * @param k 查找的第k小元素     * @param x 找到元素后就存储到x[0]中     * @return      */    public static int Select(int[] l, int k){        if(l.length&lt;=0 || k&lt;=0 || k&gt;l.length) //越界判断            throw new RuntimeException(&quot;OutOfBounds&quot;);        int left=0, right=l.length-1;        //-----------------迭代分划---------------------------        //返回伪随机的，均匀分布 int值介于0（含）和指定值（不包括）        Random random = new Random();        do{    //条件：left&lt;=right            int j = random.nextInt(right-left+1) + left; //注意：这里是--&gt;在范围[left,right]内随机选择主元            Swap(l, left, j); //将主元位置调换到left处（数组首端）            j = Partition(l, left, right); //执行分划操作            if(k==j+1)  return l[j];            else if(k&lt;j+1) right=j-1; //结合Partition函数，此处应为right=j-1，当K=0时不会发生下标越界            else left=j; //结合Partition函数，此处不能为left=j+1，否则当K=l.length时会发生下标越界；                         //而且由于是随机选择主元，left=j并不会导致右递归的主元一直都是l[j]        }while(true);    }</code></pre><p>//分划函数</p><pre><code>/** * 分划函数 *   将下标在[left,right]范围内的序列，以主元l[left]为中心 *   分划成左右两个子序列，最后返回分划点j。 *  */public static int Partition(int[] l, int left, int right){    //前置条件：left&lt;=right    int i=left, j=right+1; //哨兵位（防止越界）    do{        do i++; while(l[i]&lt;l[left]&amp;&amp;i&lt;right); //从首端向后找到&gt;=l[left]的元素l[i]则停止；或i=right时停止        do j--; while(l[j]&gt;l[left]); //从末端向前找到&lt;=l[left]的元素l[j]则停止；或当j=left时l[j]=l[left]自动停止        if(i&lt;j) Swap(l, i, j); //若大元素在小元素的前面则调换二者位置    }while(i&lt;j); //若未越界则继续查找和调换    Swap(l, left, j); //调换l[left]和l[j]    return j;}/** 调换两个元素的位置 **/public static void Swap(int[] l, int i, int j) {    int temp = l[i];    l[i] = l[j];    l[j] = temp;}</code></pre><p>//测试</p><pre><code>public static void main(String[] args) {    int[] l = new int[20];    int k=17;    //循环添加100内的随机数字到集合中    for(int i=0; i&lt;20; i++){        Random random = new Random();        int value = random.nextInt(100);        l[i] = value;    }    System.out.println(&quot;原始所有元素：&quot;);    System.out.println(Arrays.toString(l));    int res = Select(l,k);    System.out.println(&quot;第&quot;+k+&quot;小元素为：&quot;+res);    //----------------------------    System.out.println(&quot;分划后的所有元素：&quot;);    System.out.println(Arrays.toString(l));    System.out.println(&quot;最小的&quot;+k+&quot;个元素为：&quot;);    for(int i=0; i&lt;k; i++)        System.out.print(l[i]+&quot;\0&quot;);</code></pre><p>改进：</p><pre><code>        /**         * Select进阶版：         * 线性时间选择算法         *   下面讨论在最坏情况下具有线性时间的求第k小元素的算法。         *   经过精心挑选分划元素，可以使分划所得的两个子集合的大小相对接近，从而避免上述最坏情况的发生，         *   使得求第k小元素的最坏情况时间具有线性时间O(n)。         *            *   略...（算法设计与分析P84）         */    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源：《算法分析与设计：采用C++语言描述》&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://mlone.top/post/c2a5fdc5.html"/>
    <id>https://mlone.top/post/c2a5fdc5.html</id>
    <published>2018-11-24T04:35:35.000Z</published>
    <updated>2019-02-26T12:49:58.936Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代码：</strong></p><a id="more"></a><p>//堆排序</p><pre><code>public static void sort(int[] arr) {    // 1.构建大顶堆    for (int i = arr.length / 2 - 1; i &gt;= 0; i--) {        // 从第一个非叶子结点从下至上，从右至左调整结构        adjustHeap(arr, i, arr.length);    }    // 2.调整堆结构+交换堆顶元素与末尾元素    for (int j = arr.length - 1; j &gt; 0; j--) {        swap(arr, 0, j);// 将堆顶元素与末尾元素进行交换        adjustHeap(arr, 0, j);// 重新对堆进行调整    }}</code></pre><p>//调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）</p><pre><code>public static void adjustHeap(int[] arr, int i, int length) {    int temp = arr[i];// 先取出当前元素i    for (int k = i * 2 + 1; k &lt; length; k = k * 2 + 1) {// 从i结点的左子结点开始，也就是2i+1处开始        if (k + 1 &lt; length &amp;&amp; arr[k] &lt; arr[k + 1]) {// 如果左子结点小于右子结点，k指向右子结点            k++;        }        if (arr[k] &gt; temp) {// 如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）            arr[i] = arr[k];            i = k;        } else {            break;        }    }    arr[i] = temp;// 将temp值放到最终的位置}</code></pre><p>//交换元素</p><pre><code>    public static void swap(int[] arr, int a, int b) {        int temp = arr[a];        arr[a] = arr[b];        arr[b] = temp;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://mlone.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://mlone.top/post/e8eb0481.html"/>
    <id>https://mlone.top/post/e8eb0481.html</id>
    <published>2018-11-23T06:35:35.000Z</published>
    <updated>2019-02-26T14:55:25.748Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代码：</strong></p><a id="more"></a><p>// 递归形式</p><pre><code>/** * 对半搜索递归算法  T=log(n) * @param x 要搜索的元素值x * @param l 在数组l中进行搜索 * @param left 搜索的下标范围最小值 * @param right 搜索的下标范围最大值 * @return */public static int BSearch(int x, int[] l, int left, int right){    if(left&lt;=right){ //若表（子表）非空        int m = (left+right)/2; //对半分割        if(x&lt;l[m])  //搜索左半子表            return BSearch(x, l, left, m-1);        else if(x&gt;l[m]) //搜索右半子表            return BSearch(x, l , m+1, right);        else //搜索成功，返回下标            return m;    }    return -1; //搜索失败}</code></pre><p>// 迭代形式</p><pre><code>/** * 对半搜索的迭代算法  T=log(n) * @param x 要搜索的元素值x * @param l 在数组l中进行搜索 * @return */public static int BSearch(int x, int[] l){    int m, left=0, right=l.length-1;    while(left&lt;=right){        m=(left+right)/2; //int m = (left+right)/2        if(x&lt;l[m]) //朝左搜索            right = m-1;        else if(x&gt;l[m]) //朝右搜索            left = m+1;        else //x==l[m]，搜索成功            return m;    }    return -1; //搜索失败}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="查找" scheme="https://mlone.top/tags/%E6%9F%A5%E6%89%BE/"/>
    
      <category term="分治法" scheme="https://mlone.top/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>归并排序</title>
    <link href="https://mlone.top/post/1599bffe.html"/>
    <id>https://mlone.top/post/1599bffe.html</id>
    <published>2018-11-22T06:35:35.000Z</published>
    <updated>2019-02-26T13:50:14.469Z</updated>
    
    <content type="html"><![CDATA[<p>即 两路合并排序 T=O(nlogn)</p><a id="more"></a><p><strong>代码：</strong></p><pre><code>public class MergeSortTest {    /**     * Merge合并操作，将两个有序序列合并成一个有序序列：     *         比较两个序列中的最小值，输出其中较小者，然后重复此过程，     *         直到其中一个序列为空时，如果另一个还有元素未输出，则将剩余元素依次输出即可。     *      * @param l     * @param left 有序序列1：l[left],...,l[mid]     * @param mid     * @param right 有序序列2：l[mid+1],...,l[right]     */    public static void Merge(int[] l, int left, int mid, int right){        int[] temp = new int[right-left+1]; //定义缓存数组        int i=left, j=mid+1, k=0; //定义3个指针        while((i&lt;=mid)&amp;&amp;(j&lt;=right))            if(l[i]&lt;=l[j])    temp[k++] = l[i++];            else    temp[k++] = l[j++];        while(i&lt;=mid) temp[k++] = l[i++]; //若前组有剩余        while(j&lt;=right)    temp[k++] = l[j++]; //若后组有剩余        for(i=left,k=0; i&lt;=right; i++,k++)            l[i] = temp[k]; //将合并后的新序列赋给原数组    }</code></pre><p>//归并排序</p><pre><code>//缺省参数：则默认排序所有元素public static void MergeSort(int[] l){     MergeSort(l, 0, l.length-1);}//重载：排序部分范围内的元素public static void MergeSort(int[] l, int left, int right){     if(left&lt;right){ //若序列长度超过1，则将其分割成两个子序列        int mid = (left+right)/2; //将待排序的序列一分为二        MergeSort(l, left, mid); //对左子序列排序        MergeSort(l, mid+1, right); //对右子序列排序        //将两个有序子序列合并成一个有序序列        Merge(l, left, mid, right);         /*         * 其实，只有最后当left==right，即一直向下递归分割，直到子序列长度为1时，         * 才会开始向上递归返回，执行该代码行，调用Merge合并函数。         */    }}</code></pre><p>//测试</p><pre><code>    public static void main(String[] args) {        int[] l = new int[20];        //循环添加100内的随机数字到集合中        for(int i=0; i&lt;20; i++){            Random random = new Random();            int value = random.nextInt(100);            l[i] = value;        }        System.out.println(&quot;排序前：&quot;);        for(int i=0; i&lt;20; i++)            System.out.print(l[i]+&quot;\0&quot;);        //归并排序        MergeSort(l);        System.out.println(&quot;\n排序后：&quot;);        for(int i=0; i&lt;20; i++)            System.out.print(l[i]+&quot;\0&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;即 两路合并排序 T=O(nlogn)&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="https://mlone.top/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
      <category term="排序" scheme="https://mlone.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="https://mlone.top/post/ff8068c0.html"/>
    <id>https://mlone.top/post/ff8068c0.html</id>
    <published>2018-11-22T04:35:35.000Z</published>
    <updated>2019-02-26T13:49:58.311Z</updated>
    
    <content type="html"><![CDATA[<p>平均T=O(nlogn) 最坏Tmax=O(n^2)</p><a id="more"></a><p><strong>基本思想：</strong></p><p>简记：</p><p>　　<em>以最左端元素为分划元素（主元），然后</em></p><p>　　<em>左找大，右找小；</em></p><p>　　<em>调换后继续找；</em></p><p>　　<em>越界后停止查找和调换。最后，</em></p><p>　　<em>调位主元和l[j]，再在主元前后继续分划。</em></p><p><strong>代码：</strong></p><pre><code>public class QuickSortTest {        /**     * 分划函数     *   将下标在[left,right]范围内的序列，以主元l[left]为中心     *   分划成左右两个子序列，最后返回分划点j。     */    private static int Partition(int[] l, int left, int right){        //前置条件：left&lt;=right        int i=left, j=right+1; //哨兵位（防止越界）        do{            //&apos;i++&apos;即表示已将主元l[left]排除在外            do i++; while(l[i]&lt;l[left]&amp;&amp;left&lt;right); //从首端（left+1起）向后找到&gt;=主元的元素时停止；这里需要手动添加循环终止条件：left&lt;right，当left=right时停止循环，否则它不会自己停下来，造成角标越界。            do j--; while(l[j]&gt;l[left]); //从末端（right起）向前找到&lt;=主元的元素时停止；或当自减的j=left时，l[j]=主元自动停止循环。            if(i&lt;j) Swap(l, i, j); //若大元素在小元素的前面则调换二者位置        }while(i&lt;j); //若未越界则继续查找和调换        Swap(l, left, j); //调换l[left]和l[j]        return j;     }    /** 调换两个元素的位置 **/    private static void Swap(int[] l, int i, int j) {        int temp = l[i];        l[i] = l[j];        l[j] = temp;    }    public static void QuickSort(int[] l){ //缺省参数：则排序所有元素        QuickSort(l, 0, l.length-1);    }    //重载：对l[left~right]范围内的元素进行排序    public static void QuickSort(int[] l, int left, int right){        if(left&lt;right){ //当序列长度大于1时，则进行分划（此处也避免了Partition函数向右划分到末端时的角标越界，当left=right=l.length-1时自动跳出循环）            int j = Partition(l, left, right); //对[left,right]范围内的序列进行分割            QuickSort(l, left, j-1); //对左子序列实施快排            QuickSort(l, j+1, right); //对右子序列实施快排            //每分划一次则确定一个元素位置；分划完成即排序完成            //递归总次数：log2^(l.length)        }    }}</code></pre><p>另一种写法：</p><p>（基本思想是一样的，只是将主元从arr[left]换成了arr[right]，且分划函数Partition的主循环也从三个do-while循环换成了三个while循环）</p><pre><code>public class quickSortTest {    private static void recQuickSort(int arr[], int left, int right) {        if (right - left &lt;= 0) {            return;        } else {            int pivot = arr[right]; //一般使用数组最右边的元素作为枢纽            int partition = partitionIt(arr, left, right, pivot);            recQuickSort(arr, left, partition - 1);            recQuickSort(arr, partition + 1, right);        }    }    /**      *  划分：     *     划分是快速排序的根本机制，划分本身也是一个有用的操作。     *     划分数据就是把数据分为两组，使所有关键字大于特定值的数据项在一组，所有关键字小于特定值的数据项在另一组。     */    private static int partitionIt(int[] arr, int left, int right, int pivot) {        int leftPtr = left-1;        int rightPtr = right; //使用最右边的元素作为主元枢纽，划分时就要将最右端的数据项排除在外        while (true) {            while (arr[++leftPtr] &lt; pivot); //从前往后找到不比arr[right]小的元素时停止；或当自增的leftPtr=right时，arr[leftPtr]=pivot=arr[right]会自动停止循环            while (rightPtr &gt; 0 &amp;&amp; arr[--rightPtr] &gt; pivot); //从后往前找不比arr[right]大的元素时停止；这个需要手动添加循环终止条件rightPtr&gt;0以防角标越界。            if (leftPtr &gt;= rightPtr) {                break;            } else {                // 交换leftPtr和rightPtr位置的元素                int temp = arr[leftPtr];                arr[leftPtr] = arr[rightPtr];                arr[rightPtr] = temp;            }        }        // 交换leftPtr和right位置的元素        int temp = arr[leftPtr];        arr[leftPtr] = arr[right];        arr[right] = temp;        return leftPtr;// 返回枢纽位置    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;平均T=O(nlogn) 最坏Tmax=O(n^2)&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="https://mlone.top/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
      <category term="排序" scheme="https://mlone.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="分划" scheme="https://mlone.top/tags/%E5%88%86%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>简单排序之冒泡排序</title>
    <link href="https://mlone.top/post/dcef8104.html"/>
    <id>https://mlone.top/post/dcef8104.html</id>
    <published>2018-11-20T04:35:35.000Z</published>
    <updated>2019-02-26T12:09:42.880Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序：  T=O(N^2)</p><a id="more"></a><p><strong>基本思想：</strong></p><p>　　<em>第一趟在序列A[0]~A[n-1]中从前往后进行相邻两个元素的比较，若后者小则交换位置，</em></p><p>　　<em>第一趟排序结束后，最大元素会被交换到A[n-1]中，即下沉；</em></p><p>　　<em>下一趟排序在A[0]~A[n-2]中进行…</em></p><p>　　<em>如果在某趟排序中未交换元素，说明子序列已经有序，则并不再进行下一趟排序。所以最多进行n-1次排序。</em></p><p><strong>代码：</strong></p><p>//（正统）冒泡排序1，从前往后，前后元素两两比较，前大后小则交换，每趟循环一个最大元素沉底</p><pre><code>private static void bubbleSort1(int[] arr){    int i=arr.length-1;    int last; //flag    while(i&gt;0){        last=0; //每次进入循环就将last置0        for(int j=0; j&lt;i; j++){            if(arr[j]&gt;arr[j+1]){                Swap(arr,j,j+1);                last=j; //变量last用于记录上次发生元素调换的位置下标            }        }        i=last; //（i--）若在某趟排序中未发生元素交换，则last=0                //此时i=last=0（说明当前序列已经有序，排序无需再往下进行）则while循环终止，排序完成    }}</code></pre><p>//（1.1）由程序（1）去掉last变量后的精简版（最大/平均时间复杂度都是O(n^2)）</p><pre><code>private static void bubbleSort1_1(int[] arr){    for(int i=arr.length-1; i&gt;0; i-- ){        for(int j=0; j&lt;i; j++){            if(arr[j]&gt;arr[j+1]){                Swap(arr,j,j+1);            }        }    }}</code></pre><p>//（不正统）冒泡排序2，从前往后，arr[i]分别与arr[i+1]~arr[n-1]相比较，小于arr[i]则调换，每趟循环有一个最小元素浮顶</p><pre><code>private static void bubbleSort2(int[] arr){    for(int i = 0; i &lt; arr.length - 1; i++){         for(int j = i + 1; j &lt; arr.length; j++){               if(arr[j]&lt;arr[i]){                    Swap(arr,i,j);               }         }    }}</code></pre><p>//调换数组中两元素的位置</p><pre><code>private static void Swap(int[] arr, int i, int j){    int temp = arr[i];    arr[i] = arr[j];    arr[j] = temp;}</code></pre><p><strong>冒泡排序的效率：</strong></p><p>　　选择排序改进了冒泡排序，将必要的交换次数从O(N^2)减少到O(N)，不幸的是比较次数依然是O(N^2)级</p><p>　　然而，选择排序依然为大数据量的排序提出了一个非常重要的改进，因为这些大量的记录需要在内存中移动，</p><p>　　这就使交换的时间和比较的时间相比起来，交换的时间更为重要。</p><p>　　一般来说，Java语言中不是这种情况，Java中只是改变了引用位置，而实际对象的位置并没有发生改变</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;冒泡排序：  T=O(N^2)&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://mlone.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单排序之插入排序</title>
    <link href="https://mlone.top/post/5e5c2f5d.html"/>
    <id>https://mlone.top/post/5e5c2f5d.html</id>
    <published>2018-11-20T03:35:35.000Z</published>
    <updated>2019-02-26T12:09:42.881Z</updated>
    
    <content type="html"><![CDATA[<p>直接插入排序 T=O(N^2)</p><a id="more"></a><p><strong>基本思想：</strong></p><p>　　<em>将A[0]作为一个有序序列，然后将剩余n-1个元素依次插入该有序序列，</em></p><p>　　<em>每插入一个元素后依然保持该序列有序，经过n-1次插入操作后可排序完成。</em></p><p>　　<em>插入排序，在一般情况下，比冒泡排序快一倍，比选择排序快一点</em>。</p><p><strong>代码：</strong></p><pre><code>public class InsertSortTest {    private static void insertSort(int[] arr) {        for (int i = 1; i &lt; arr.length; i++) {             int j = i; //从后向前查找元素A[i]要插入序列A[i-1]~A[0]中的位置            int temp = arr[i]; //先将带插入元素存入临时变量            while (j &gt; 0 &amp;&amp; temp &lt; arr[j - 1]) {                 arr[j] = arr[j - 1]; //遇到比A[i]大的元素就将它后移一位                --j;            }            arr[j] = temp; //下标j最终就是带插入元素的插入位置        }    }}</code></pre><p><strong>插入排序的效率：</strong></p><p>　　这个算法中，第一趟排序最多比较一次，第二趟排序最多比较两次，以此类推，最后一趟最多比较N-1次，</p><p>　　对于随机顺序的数据，插入排序也需要O(N^2)时间级，可是当数据基本有序，插入排序几乎只需要O(N)时间，</p><p>　　这对于把一个基本有序的文件进行排序是个简单有效的方法。</p><p>　　对于逆序排列的数据，每次比较和移动都会执行，所以插入排序不比冒泡排序快。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;直接插入排序 T=O(N^2)&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://mlone.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单排序之选择排序</title>
    <link href="https://mlone.top/post/8bd97a76.html"/>
    <id>https://mlone.top/post/8bd97a76.html</id>
    <published>2018-11-20T02:35:35.000Z</published>
    <updated>2019-02-26T12:09:42.883Z</updated>
    
    <content type="html"><![CDATA[<p>简单选择排序 T=O(N^2)</p><a id="more"></a><p><strong>基本思想：</strong></p><p>　　<em>第一趟在初始序列A[0]~A[n-1]中找出最小值元素的下标， 然后将该最小元素与A[0]调换位置，</em></p><p>　　<em>下一趟排序在A[1]~A[n-1]中找出最小值元素的下标， 然后将该最小元素与A[1]调换位置…</em></p><p>　　<em>经过n-1次调换后可排序完成。</em></p><p><strong>代码：</strong></p><pre><code>public class ChooseSortTest {    private static void chooseSort(int[] arr) {        for (int i = 0; i &lt; arr.length; i++) {            int least = i; //先假设待排序列中第一个元素最小            for (int j = i + 1; j &lt; arr.length; j++) {                 if (arr[j] &lt; arr[least]) { //比对查找待排序列中的最小元素下标                    least = j;                }            }            //将待排序列中的最小元素调到序列最前端            Swap(arr,i,least);        }    }    //调换数组中两元素的位置    private static void Swap(int[] arr, int i, int j){        int temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }}</code></pre><p><strong>选择排序的效率：</strong></p><p>　　选择排序和冒泡排序执行了相同次数的比较：N*(N-1)/2.对于10个数据项，需进行45次比较。</p><p>　　然而，10个数据项只需要10次数据交换，而对于100个数据项，需要4950次比较，但只进行不到100次交换。</p><p>　　当N值很大时，比较的次数是主要的，所以结论是选择排序和冒泡排序一样运行了O(N^2)时间，但是，选择排序无疑更快，因为它进行的交换少得多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单选择排序 T=O(N^2)&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://mlone.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序" scheme="https://mlone.top/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>常用sql语句总结2</title>
    <link href="https://mlone.top/post/c3683cbd.html"/>
    <id>https://mlone.top/post/c3683cbd.html</id>
    <published>2018-11-13T06:15:00.000Z</published>
    <updated>2019-02-27T07:15:04.267Z</updated>
    
    <content type="html"><![CDATA[<p>来源于：<a href="https://www.nowcoder.com/ta/sql" target="_blank" rel="noopener">牛客网</a><br><a id="more"></a></p><h5 id="11-从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t："><a href="#11-从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t：" class="headerlink" title="11.从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t："></a>11.从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t：</h5><pre><code>CREATE TABLE IF NOT EXISTS &quot;titles&quot; (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);</code></pre><p><strong>答：</strong></p><pre><code>SELECT title, COUNT(title) AS t FROM titles GROUP BY title HAVING t &gt;= 2</code></pre><p>或</p><pre><code>SELECT title, COUNT(emp_no) AS t FROM titles GROUP BY title HAVING t &gt;= 2</code></pre><p>或</p><pre><code>SELECT title, COUNT(*) AS t FROM titles GROUP BY title HAVING t &gt;= 2</code></pre><p><strong>解析：</strong></p><p>此题应注意以下三点：</p><ol><li>用COUNT()函数和GROUP BY语句可以统计同一title值的记录条数</li><li>根据题意，输出每个title的个数为t，故用AS语句将COUNT(title)的值转换为t</li><li>由于WHERE后不可跟COUNT()函数，故用HAVING语句来限定t&gt;=2的条件</li></ol><h5 id="12-接上题，从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp-no进行忽略："><a href="#12-接上题，从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp-no进行忽略：" class="headerlink" title="12.接上题，从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp_no进行忽略："></a>12.接上题，从titles表获取按照title进行分组，每组个数大于等于2，给出title以及对应的数目t。注意对于重复的emp_no进行忽略：</h5><p><strong>答：</strong></p><pre><code>SELECT title, COUNT(DISTINCT emp_no) AS t FROM titlesGROUP BY title HAVING t &gt;= 2</code></pre><h5 id="13-查找employees表所有emp-no为奇数，且last-name不为Mary的员工信息，并按照hire-date逆序排列："><a href="#13-查找employees表所有emp-no为奇数，且last-name不为Mary的员工信息，并按照hire-date逆序排列：" class="headerlink" title="13.查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列："></a>13.查找employees表所有emp_no为奇数，且last_name不为Mary的员工信息，并按照hire_date逆序排列：</h5><pre><code>CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));</code></pre><p><strong>答：</strong></p><pre><code>SELECT * FROM employees WHERE emp_no % 2 = 1 AND last_name != &apos;Mary&apos; ORDER BY hire_date DESC;</code></pre><h5 id="14-统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg："><a href="#14-统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg：" class="headerlink" title="14.统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg："></a>14.统计出当前各个title类型对应的员工当前薪水对应的平均工资。结果给出title以及平均工资avg：</h5><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p>.</p><pre><code>CREATE TABLE IF NOT EXISTS &quot;titles&quot; (`emp_no` int(11) NOT NULL,`title` varchar(50) NOT NULL,`from_date` date NOT NULL,`to_date` date DEFAULT NULL);</code></pre><p><strong>答：</strong></p><p>方式一：</p><pre><code>SELECT t.title AS title, AVG(s.salary) as avgFROM salaries AS s, titles AS t WHERE t.emp_no = s.emp_noAND t.to_date = &apos;9999-01-01&apos;AND s.to_date = &apos;9999-01-01&apos;GROUP BY title</code></pre><p>方式二：</p><pre><code>SELECT t.title AS title, AVG(s.salary) as avgFROM salaries AS s INNER JOIN titles AS t ON t.emp_no = s.emp_noAND t.to_date = &apos;9999-01-01&apos;AND s.to_date = &apos;9999-01-01&apos;GROUP BY title</code></pre><h5 id="15-获取当前（to-date-’9999-01-01’）薪水第二多的员工的emp-no以及其对应的薪水salary："><a href="#15-获取当前（to-date-’9999-01-01’）薪水第二多的员工的emp-no以及其对应的薪水salary：" class="headerlink" title="15.获取当前（to_date=’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salary："></a>15.获取当前（to_date=’9999-01-01’）薪水第二多的员工的emp_no以及其对应的薪水salary：</h5><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p><strong>答：</strong></p><p>方式一：</p><pre><code>SELECT emp_no, MAX(salary) FROM salaries WHERE salary NOT IN (SELECT MAX(salary) FROM salaries) AND to_date=&apos;9999-01-01&apos;</code></pre><p>或</p><pre><code>SELECT emp_no, MAX(salary) FROM salaries WHERE salary &lt; (SELECT MAX(salary) FROM salaries) AND to_date=&apos;9999-01-01&apos;</code></pre><p>方式二：（但是这种方式不能解决多个人工资相同的问题）</p><pre><code>SELECT emp_no,salary FROM salaries s WHERE s.to_date = &apos;9999-01-01&apos;ORDER BY s.salary DESC LIMIT 1,1</code></pre><p><strong>改进：</strong></p><p>（子查询里面也需要限制to_date=’9999-01-01’，不然得到的不是当前第二多的工资）</p><pre><code>SELECT emp_no, salary FROM salaries WHERE to_date = &apos;9999-01-01&apos; AND salary = (SELECT DISTINCT salary FROM salaries WHERE to_date = &apos;9999-01-01&apos; ORDER BY salary DESC LIMIT 1,1)</code></pre><p>避免了2个问题：</p><ol><li>首先这样可以解决多个人工资相同的问题；</li><li>另外，筛选出第二多的工资时要注意distinct salary，否则不能选出第二多的工资。</li></ol><p><em>为什么要加distinct？limit不是只限制只拿一条吗？</em><br>——先执行distinct 后执行limit。</p><p><strong>另：</strong></p><ol><li><p>“Where” 是一个约束声明，使用Where来约束来之数据库的数据，Where是在结果返回之前起作用的，且Where条件语句中不能使用聚合函数。</p></li><li><p>“Having”是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having条件语句中可以使用聚合函数。</p></li></ol><p>SQL中提供的聚合函数可以用来统计、求和、求最值等等。<br>分类：</p><ul><li>–COUNT：统计行数量</li><li>–SUM：获取单个列的合计值</li><li>–AVG：计算某个列的平均值</li><li>–MAX：计算列的最大值</li><li>–MIN：计算列的最小值</li></ul><h5 id="16-查找当前薪水-to-date-’9999-01-01’-排名第二多的员工编号emp-no、薪水salary、last-name以及first-name，不准使用order-by："><a href="#16-查找当前薪水-to-date-’9999-01-01’-排名第二多的员工编号emp-no、薪水salary、last-name以及first-name，不准使用order-by：" class="headerlink" title="16.查找当前薪水(to_date=’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by："></a>16.查找当前薪水(to_date=’9999-01-01’)排名第二多的员工编号emp_no、薪水salary、last_name以及first_name，不准使用order by：</h5><pre><code>CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`))；</code></pre><p>.</p><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p><strong>答：</strong></p><p>方式一：（注意这里只限定“当前薪水”即可，不用再加 AND e. to_date = ‘9999-01-01’）</p><pre><code>SELECT e.emp_no, MAX(s.salary) AS salary, e.last_name, e.first_nameFROM salaries s, employees e WHERE s.emp_no = e.emp_no AND salary NOT IN (SELECT MAX(salary) FROM salaries WHERE to_date = &apos;9999-01-01&apos;)AND s.to_date = &apos;9999-01-01&apos;;</code></pre><p>方式二：（使用内连接）</p><pre><code>SELECT e.emp_no, MAX(s.salary) AS salary, e.last_name, e.first_nameFROM salaries s INNER JOIN employees e ON s.emp_no = e.emp_no AND salary NOT IN (SELECT MAX(salary) FROM salaries WHERE to_date = &apos;9999-01-01&apos;)AND s.to_date = &apos;9999-01-01&apos;;</code></pre><h5 id="17-查找所有员工的last-name和first-name以及对应的dept-name，也包括暂时没有分配部门的员工："><a href="#17-查找所有员工的last-name和first-name以及对应的dept-name，也包括暂时没有分配部门的员工：" class="headerlink" title="17.查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工："></a>17.查找所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工：</h5><pre><code>CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));</code></pre><p><strong>答：</strong></p><pre><code>SELECT e.last_name, e.first_name, d.dept_name FROM employees as e LEFT JOIN dept_emp AS de ON e.emp_no = de.emp_noLEFT JOIN departments AS d ON de.dept_no = d.dept_no</code></pre><p><strong>解析：</strong></p><p>本题思路为运用两次LEFT JOIN连接嵌套:</p><ol><li>第一次LEFT JOIN连接employees表与dept_emp表，得到所有员工的last_name和first_name以及对应的dept_no，也包括暂时没有分配部门的员工；</li><li>第二次LEFT JOIN连接上表与departments表，即连接dept_no与dept_name，得到所有员工的last_name和first_name以及对应的dept_name，也包括暂时没有分配部门的员工。</li></ol><h5 id="18-查找员工编号emp-no为10001其自入职以来的薪水salary涨幅值growth："><a href="#18-查找员工编号emp-no为10001其自入职以来的薪水salary涨幅值growth：" class="headerlink" title="18.查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth："></a>18.查找员工编号emp_no为10001其自入职以来的薪水salary涨幅值growth：</h5><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p>本题严谨的思路如下：</p><ol><li>先分别找到emp_no=10001的员工的第一次工资记录与最后一次工资记录</li><li>再将最后一次工资记录减去第一次工资记录得到入职以来salary的涨幅，最后用别名growth代替</li></ol><p><strong>答：</strong></p><pre><code>SELECT ( (SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date DESC LIMIT 1) -(SELECT salary FROM salaries WHERE emp_no = 10001 ORDER BY to_date ASC LIMIT 1)) AS growth</code></pre><p>本题的另一种解法也能通过测试，但实际上不严谨，只有在员工最后一条工资记录为最大值时成立，如果最后一次的工资调整为降薪，则此思路通不过。具体思路如下：</p><p>直接找到emp_no=10001的员工的工资记录，将其最大工资减去最小工资得到涨幅</p><pre><code>SELECT (MAX(salary)-MIN(salary)) AS growth FROM salaries WHERE emp_no = &apos;10001&apos;</code></pre><h5 id="19-查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp-no以及其对应的薪水涨幅growth，并按照growth进行升序："><a href="#19-查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp-no以及其对应的薪水涨幅growth，并按照growth进行升序：" class="headerlink" title="19.查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序："></a>19.查找所有员工自入职以来的薪水涨幅情况，给出员工编号emp_no以及其对应的薪水涨幅growth，并按照growth进行升序：</h5><pre><code>CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p><strong>答：</strong></p><p>方式一：（全部使用from并列查询）</p><pre><code>SELECT sCurrent.emp_no, (sCurrent.salary-sStart.salary) AS growthFROM (SELECT s.emp_no, s.salary FROM employees e, salaries s WHERE e.emp_no = s.emp_no AND s.to_date = &apos;9999-01-01&apos;) AS sCurrent,(SELECT s.emp_no, s.salary FROM employees e, salaries s WHERE e.emp_no = s.emp_no AND s.from_date = e.hire_date) AS sStartWHERE sCurrent.emp_no = sStart.emp_noORDER BY growth;</code></pre><p>方式二：（全部使用内连接inner join）</p><pre><code>SELECT sCurrent.emp_no, (sCurrent.salary-sStart.salary) AS growthFROM (SELECT s.emp_no, s.salary FROM employees e INNER JOIN salaries s ON e.emp_no = s.emp_no WHERE s.to_date = &apos;9999-01-01&apos;) AS sCurrentINNER JOIN (SELECT s.emp_no, s.salary FROM employees e INNER JOIN salaries s ON e.emp_no = s.emp_no WHERE s.from_date = e.hire_date) AS sStartON sCurrent.emp_no = sStart.emp_noORDER BY growth;</code></pre><p><strong>解析：</strong></p><p>连接employees与salaries，建立两张表。</p><p>先得到一个员工当前工资表sCurrent：</p><p><em>（SELECT s.emp_no, s.salary FROM employees e, salaries s WHERE e.emp_no = s.emp_no AND s.to_date = ‘9999-01-01’）；</em></p><p>和一个员工入职时的工资表sStart：</p><p><em>（SELECT s.emp_no, s.salary FROM employees e, salaries s WHERE e.emp_no = s.emp_no AND s.from_date = e.hire_date）；</em></p><p>然后连接这两个表，</p><p>最后限定在同一员工下<em>（sCurrent.emp_no = sStart.emp_no）</em>用当前工资减去入职工资<em>（sCurrent.salary - sStart.salary）</em>计算得到入职以来的薪水涨幅<em>growth</em>，并排序<em>ORDER BY growth</em> <em>(默认升序ASC)。</em></p><h5 id="20-统计各个部门对应员工涨幅的次数总和，给出部门编码dept-no、部门名称dept-name以及次数sum："><a href="#20-统计各个部门对应员工涨幅的次数总和，给出部门编码dept-no、部门名称dept-name以及次数sum：" class="headerlink" title="20.统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sum："></a>20.统计各个部门对应员工涨幅的次数总和，给出部门编码dept_no、部门名称dept_name以及次数sum：</h5><pre><code>CREATE TABLE `departments` (`dept_no` char(4) NOT NULL,`dept_name` varchar(40) NOT NULL,PRIMARY KEY (`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p><strong>答：</strong>本题关键是要将 每个部门分组，并分别统计工资记录总数</p><p>方式一：</p><pre><code>SELECT d.dept_no, d.dept_name, COUNT(s.salary) AS sum FROM departments d, dept_emp de, salaries s WHERE d.dept_no = de.dept_no AND de.emp_no = s.emp_no GROUP BY d.dept_no;</code></pre><p>方式二：</p><pre><code>SELECT d.dept_no, d.dept_name, COUNT(s.salary) AS sum FROM departments dINNER JOIN dept_emp de ON d.dept_no = de.dept_no INNER JOIN salaries s ON de.emp_no = s.emp_noGROUP BY d.dept_no;</code></pre><h5 id="21-对所有员工的当前-to-date-’9999-01-01’-薪水按照salary进行按照1-N的排名，相同salary并列且按照emp-no升序排列："><a href="#21-对所有员工的当前-to-date-’9999-01-01’-薪水按照salary进行按照1-N的排名，相同salary并列且按照emp-no升序排列：" class="headerlink" title="21.对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列："></a>21.对所有员工的当前(to_date=’9999-01-01’)薪水按照salary进行按照1-N的排名，相同salary并列且按照emp_no升序排列：</h5><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p>本题的主要思想是复用salaries表进行比较排名，具体思路如下：</p><ol><li>从两张相同的salaries表（分别为s1与s2）进行对比分析，先将两表限定条件设为to_date = ‘9999-01-01’，挑选出当前所有员工的薪水情况。</li><li>本题的精髓在于 s1.salary &lt;= s2.salary，意思是在输出s1.salary的情况下，有多少个s2.salary大于等于s1.salary，比如当s1.salary=94409时，有3个s2.salary（分别为94692,94409,94409）大于等于它，但由于94409重复，利用COUNT(DISTINCT s2.salary)去重可得工资为94409的rank等于2。其余排名以此类推。</li><li>千万不要忘了GROUP BY s1.emp_no，否则输出的记录只有一条（可能是第一条或者最后一条，根据不同的数据库而定），因为用了合计函数COUNT()。</li><li>最后先以 s1.salary 逆序排列，再以 s1.emp_no 顺序排列输出结果。</li></ol><p><strong>答：</strong></p><pre><code>SELECT s1.emp_no, s1.salary, COUNT(DISTINCT s2.salary) AS rankFROM salaries AS s1, salaries AS s2WHERE s1.salary &lt;= s2.salary AND s1.to_date = &apos;9999-01-01&apos; AND s2.to_date = &apos;9999-01-01&apos; GROUP BY s1.emp_no ORDER BY s1.salary DESC, s1.emp_no ASC;</code></pre><p><em>最后在支持ROW_NUMBER、RANK、DENSE_RANK等函数的SQL Server数据库中，有以下参考代码，可惜在本题的SQLite数据库中不支持。</em></p><pre><code>SELECT emp_no, salaries, DENSE_RANK() OVER(ORDER BY salary DESC) AS rankWHERE to_date = &apos;9999-01-01&apos; ORDER BY salary DESC, emp_no ASC</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源于：&lt;a href=&quot;https://www.nowcoder.com/ta/sql&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SQL" scheme="https://mlone.top/categories/SQL/"/>
    
    
      <category term="sql" scheme="https://mlone.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>常用sql语句总结1</title>
    <link href="https://mlone.top/post/5a616d07.html"/>
    <id>https://mlone.top/post/5a616d07.html</id>
    <published>2018-11-12T06:15:00.000Z</published>
    <updated>2019-02-27T07:16:15.050Z</updated>
    
    <content type="html"><![CDATA[<p>来源于：<a href="https://www.nowcoder.com/ta/sql" target="_blank" rel="noopener">牛客网</a><br><a id="more"></a></p><h5 id="1-sql查找表中多余的重复记录，重复记录是根据单个字段（itemId）来判断"><a href="#1-sql查找表中多余的重复记录，重复记录是根据单个字段（itemId）来判断" class="headerlink" title="1.sql查找表中多余的重复记录，重复记录是根据单个字段（itemId）来判断:"></a>1.sql查找表中多余的重复记录，重复记录是根据单个字段（itemId）来判断:</h5><p><strong>答：</strong></p><pre><code>select * from tb_Itemwhere itemId in (select itemId from tb_Item group by itemId having count(itemId) &gt; 1 )</code></pre><h5 id="2-1-查找最晚入职员工的所有信息"><a href="#2-1-查找最晚入职员工的所有信息" class="headerlink" title="2.1 查找最晚入职员工的所有信息:"></a>2.1 查找最晚入职员工的所有信息:</h5><pre><code>CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));</code></pre><p><strong>答：</strong></p><pre><code>select * from employeeswhere hire_date =(select max(hire_date) from employees)</code></pre><h5 id="2-2-查找入职员工时间排名倒数第三的员工所有信息（接上题）"><a href="#2-2-查找入职员工时间排名倒数第三的员工所有信息（接上题）" class="headerlink" title="2.2 查找入职员工时间排名倒数第三的员工所有信息（接上题）"></a>2.2 查找入职员工时间排名倒数第三的员工所有信息（接上题）</h5><p><strong>答：</strong>对入职时间进行降序排列，从第2条记录开始，选取1条记录信息。</p><pre><code>SELECT * FROM employees ORDER BY hire_date DESC LIMIT 2,1</code></pre><h5 id="3-查找各个部门当前-to-date-’9999-01-01’-领导当前薪水详情以及其对应部门编号dept-no"><a href="#3-查找各个部门当前-to-date-’9999-01-01’-领导当前薪水详情以及其对应部门编号dept-no" class="headerlink" title="3.查找各个部门当前(to_date=’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_no"></a>3.查找各个部门当前(to_date=’9999-01-01’)领导当前薪水详情以及其对应部门编号dept_no</h5><pre><code>CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p><strong>答：</strong>（注意这里两个表的日期要同步）</p><p>解1：</p><pre><code>select s.*, d.dept_nofrom salaries s, dept_manager dwhere s.emp_no = d.emp_no and s.to_date = &apos;9999-01-01&apos;and d.to_date = &apos;9999-01-01&apos;</code></pre><p>解2：（使用关联查询）</p><pre><code>select s.*, d.dept_nofrom salaries as sinner join dept_manager as don s.emp_no = d.emp_no and s.to_date = &apos;9999-01-01&apos;and d.to_date = &apos;9999-01-01&apos;</code></pre><p>解3：（只是加了一个where）</p><pre><code>select s.*, d.dept_nofrom salaries sinner join dept_manager don s.emp_no = d.emp_no where s.to_date = &apos;9999-01-01&apos;and d.to_date = &apos;9999-01-01&apos;</code></pre><h5 id="4-1-查找所有已经分配部门的员工的last-name和first-name"><a href="#4-1-查找所有已经分配部门的员工的last-name和first-name" class="headerlink" title="4.1 查找所有已经分配部门的员工的last_name和first_name"></a>4.1 查找所有已经分配部门的员工的last_name和first_name</h5><pre><code>CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));</code></pre><p><strong>答：</strong></p><p>解1：</p><pre><code>select e.last_name, e.first_name, d.dept_nofrom employees e inner join dept_emp don e.emp_no = d.emp_no</code></pre><p>解2：（//只有一列是公有的，用自然连接）</p><pre><code>select e.last_name, e.first_name, d.dept_nofrom employees e natural join dept_emp d</code></pre><h5 id="4-2-查找所有员工的last-name和first-name以及对应部门编号dept-no，也包括展示没有分配具体部门的员工（接上题）"><a href="#4-2-查找所有员工的last-name和first-name以及对应部门编号dept-no，也包括展示没有分配具体部门的员工（接上题）" class="headerlink" title="4.2 查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工（接上题）"></a>4.2 查找所有员工的last_name和first_name以及对应部门编号dept_no，也包括展示没有分配具体部门的员工（接上题）</h5><p><strong>答：</strong></p><pre><code>SELECT e.last_name, e.first_name, d.dept_no FROM employees e LEFT JOIN dept_emp dON e.emp_no = d.emp_no</code></pre><p><strong>注意：</strong></p><ul><li>INNER JOIN 两边表同时有对应的数据，即任何一边缺失数据就不显示。</li><li>LEFT JOIN 会读取左边数据表的全部数据，即便右边表无对应数据。</li><li>RIGHT JOIN 会读取右边数据表的全部数据，即便左边表无对应数据。</li></ul><h5 id="4-3查找所有员工入职时候的薪水情况，给出emp-no以及salary，-并按照emp-no进行逆序（接上题）"><a href="#4-3查找所有员工入职时候的薪水情况，给出emp-no以及salary，-并按照emp-no进行逆序（接上题）" class="headerlink" title="4.3查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序（接上题）"></a>4.3查找所有员工入职时候的薪水情况，给出emp_no以及salary， 并按照emp_no进行逆序（接上题）</h5><p><strong>答：</strong></p><p>此题应注意以下四个知识点：</p><ol><li>由于测试数据中，salaries.emp_no 不唯一（因为号码为 emp_no 的员工会有多次涨薪的可能，所以在 salaries 中对应的记录不止一条），employees.emp_no 唯一，即 salaries 的数据会多于 employees，因此需先找到 employees.emp_no 在 salaries 表中对应的记录salaries.emp_no，则有限制条件 e.emp_no = s.emp_no</li><li>根据题意注意到 salaries.from_date 和 employees.hire_date 的值应该要相等，因此有限制条件 e.hire_date = s.from_date</li><li>根据题意要按照 emp_no 值逆序排列，因此最后要加上 ORDER BY e.emp_no DESC</li><li>为了代码良好的可读性，运用了 Alias 别名语句，将 employees 简化为 e，salaries 简化为s，即 employees AS e 与 salaries AS s，其中 AS 可以省略</li></ol><p>方法一：利用 INNER JOIN 连接两张表</p><pre><code>SELECT e.emp_no, s.salary FROM employees AS e INNER JOIN salaries AS sON e.emp_no = s.emp_no AND e.hire_date = s.from_dateORDER BY e.emp_no DESC</code></pre><p>方法二：直接用逗号并列查询两张表</p><pre><code>SELECT e.emp_no, s.salary FROM employees AS e, salaries AS sWHERE e.emp_no = s.emp_no AND e.hire_date = s.from_dateORDER BY e.emp_no DESC</code></pre><h5 id="5-查找薪水涨幅超过15次的员工号emp-no以及其对应的涨幅次数t："><a href="#5-查找薪水涨幅超过15次的员工号emp-no以及其对应的涨幅次数t：" class="headerlink" title="5.查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t："></a>5.查找薪水涨幅超过15次的员工号emp_no以及其对应的涨幅次数t：</h5><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p><strong>答：</strong></p><pre><code>SELECT emp_no, COUNT(emp_no) AS t FROM salaries GROUP BY emp_no HAVING t &gt; 15</code></pre><p>解析：</p><p>此题应注意以下四点：</p><ol><li>用COUNT()函数和GROUP BY语句可以统计同一emp_no值的记录条数</li><li>根据题意，输出的涨幅次数为t，故用AS语句将COUNT(emp_no)的值转换为t</li><li>由于COUNT()函数不可用于WHERE语句中，故使用HAVING语句来限定t&gt;15的条件</li><li>最后存在一个理解误区，涨幅超过15次，salaries中相应的记录数应该超过16（从第2条记录开始算作第1次涨幅），不过题目为了简单起见，将第1条记录当作第1次涨幅，所以令t&gt;15即可</li></ol><p><em>注意： 严格来说，下一条salary高于本条才算涨幅，但本题只要出现了一条记录就算一次涨幅，salary相同可以理解为涨幅为0，salary变少理解为涨幅为负</em></p><h5 id="6-找出所有员工当前-to-date-’9999-01-01’-具体的薪水salary情况，对于相同的薪水只显示一次-并按照逆序显示："><a href="#6-找出所有员工当前-to-date-’9999-01-01’-具体的薪水salary情况，对于相同的薪水只显示一次-并按照逆序显示：" class="headerlink" title="6.找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示："></a>6.找出所有员工当前(to_date=’9999-01-01’)具体的薪水salary情况，对于相同的薪水只显示一次,并按照逆序显示：</h5><p><strong>答：</strong></p><p>方式一：</p><pre><code>SELECT DISTINCT salary FROM salaries WHERE to_date=&apos;9999-01-01&apos; ORDER BY salary DESC;</code></pre><p>方式二：</p><pre><code>SELECT salary FROM salaries WHERE to_date=&apos;9999-01-01&apos; GROUP BY salary ORDER BY salary DESC;</code></pre><p><strong>解析：</strong></p><p>对于distinct,groupby的性能</p><ol><li>数据量非常巨大时候，比如1000万中有300W重复数据，这时候的distinct的效率略好于group by；</li><li>对于相对重复量较小的数据量比如1000万中1万的重复量，用groupby的性能会远优于distnct；</li><li>简书上的一篇博客说的不错，大家可以穿送过去看一看<a href="http://www.jianshu.com/p/34800d06f63d" target="_blank" rel="noopener">传送门</a></li></ol><h5 id="7-获取所有部门当前manager的当前薪水情况，给出dept-no-emp-no以及salary，当前表示to-date-’9999-01-01’："><a href="#7-获取所有部门当前manager的当前薪水情况，给出dept-no-emp-no以及salary，当前表示to-date-’9999-01-01’：" class="headerlink" title="7.获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’："></a>7.获取所有部门当前manager的当前薪水情况，给出dept_no, emp_no以及salary，当前表示to_date=’9999-01-01’：</h5><pre><code>CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p><strong>答：</strong></p><p>方式一：（where关联查询语句）</p><pre><code>SELECT d.dept_no, d.emp_no, s.salary FROM salaries AS s, dept_manager AS dWHERE d.emp_no = s.emp_no AND s.to_date = &apos;9999-01-01&apos;AND d.to_date = &apos;9999-01-01&apos;;</code></pre><p>方式二：（内连接）</p><pre><code>SELECT d.dept_no, d.emp_no, s.salary FROM salaries AS s INNER JOIN dept_manager AS d ON d.emp_no = s.emp_noWHERE d.to_date = &apos;9999-01-01&apos; AND s.to_date = &apos;9999-01-01&apos;</code></pre><p>或：</p><pre><code>SELECT d.dept_no, d.emp_no, s.salary FROM salaries AS s INNER JOIN dept_manager AS d ON d.emp_no = s.emp_noAND d.to_date = &apos;9999-01-01&apos;AND s.to_date = &apos;9999-01-01&apos;</code></pre><h5 id="8-获取所有非manager的员工emp-no："><a href="#8-获取所有非manager的员工emp-no：" class="headerlink" title="8.获取所有非manager的员工emp_no："></a>8.获取所有非manager的员工emp_no：</h5><pre><code>CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `employees` (`emp_no` int(11) NOT NULL,`birth_date` date NOT NULL,`first_name` varchar(14) NOT NULL,`last_name` varchar(16) NOT NULL,`gender` char(1) NOT NULL,`hire_date` date NOT NULL,PRIMARY KEY (`emp_no`));</code></pre><p><strong>答：</strong></p><p>方式一：（使用NOT IN选出在employees但不在dept_manager中的emp_no记录）</p><pre><code>SELECT emp_no FROM employeesWHERE emp_no NOT IN (SELECT emp_no FROM dept_manager)</code></pre><p>方式二：（先使用LEFT JOIN连接两张表，再从此表中选出dept_no值为NULL对应的emp_no记录）</p><pre><code>SELECT e.emp_no FROM employees e LEFT JOIN dept_manager d ON e.emp_no = d.emp_no WHERE dept_no IS NULL</code></pre><h5 id="9-获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to-date-’9999-01-01’。结果第一列给出当前员工的emp-no-第二列给出其manager对应的manager-no。"><a href="#9-获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to-date-’9999-01-01’。结果第一列给出当前员工的emp-no-第二列给出其manager对应的manager-no。" class="headerlink" title="9.获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。"></a>9.获取所有员工当前的manager，如果当前的manager是自己的话结果不显示，当前表示to_date=’9999-01-01’。结果第一列给出当前员工的emp_no,第二列给出其manager对应的manager_no。</h5><pre><code>CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `dept_manager` (`dept_no` char(4) NOT NULL,`emp_no` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));</code></pre><p><strong>答：</strong></p><p>方式一：（使用where条件语句）</p><pre><code>SELECT de.emp_no, dm.emp_no AS manager_noFROM dept_manager AS dm, dept_emp AS deWHERE de.dept_no = dm.dept_no AND de.to_date=&apos;9999-01-01&apos;AND dm.to_date=&apos;9999-01-01&apos;AND de.emp_no &lt;&gt; dm.emp_no</code></pre><p>方式二：（使用inner join内连接）</p><pre><code>SELECT de.emp_no, dm.emp_no AS manager_no FROM dept_emp AS de INNER JOIN dept_manager AS dmON de.dept_no = dm.dept_no WHERE dm.to_date = &apos;9999-01-01&apos; AND de.to_date = &apos;9999-01-01&apos; AND de.emp_no &lt;&gt; dm.emp_no</code></pre><p><strong>解析：</strong></p><p>本题应注意以下三点：</p><ol><li>用 INNER JOIN 连接两张表，因为要输出自己的经理，得知自己与经理的部门要相同，故有限制条件 de.dept_no = dm.dept_no</li><li>再用 WHERE 限制当前员工与当前经理的条件，即 dm.to_date 等于 ‘9999-01-01’ 、de.to_date 等于 ‘9999-01-01’ 、 de.emp_no 不等于 dm.emp_no</li><li>为了增强代码可读性，将 dept_emp 用别名 de 代替，dept_manager 用 dm 代替，最后根据题意将 de.emp_no 用别名 manager_no 代替后输出</li></ol><h5 id="10-获取所有部门中当前员工薪水最高的相关信息，给出dept-no-emp-no以及其对应的salary："><a href="#10-获取所有部门中当前员工薪水最高的相关信息，给出dept-no-emp-no以及其对应的salary：" class="headerlink" title="10.获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary："></a>10.获取所有部门中当前员工薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary：</h5><pre><code>CREATE TABLE `dept_emp` (`emp_no` int(11) NOT NULL,`dept_no` char(4) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`dept_no`));</code></pre><p>.</p><pre><code>CREATE TABLE `salaries` (`emp_no` int(11) NOT NULL,`salary` int(11) NOT NULL,`from_date` date NOT NULL,`to_date` date NOT NULL,PRIMARY KEY (`emp_no`,`from_date`));</code></pre><p><strong>答：</strong></p><p>方式一：</p><pre><code>SELECT de.dept_no, de.emp_no, max(s.salary) salary FROM dept_emp de,salaries s WHERE de.emp_no = s.emp_no AND de.to_date = &apos;9999-01-01&apos;AND s.to_date = &apos;9999-01-01&apos;GROUP BY de.dept_no;</code></pre><p>方式二：</p><pre><code>SELECT d.dept_no, s.emp_no, MAX(s.salary) AS salaryFROM salaries AS s INNER JOIN dept_emp As d ON d.emp_no = s.emp_no WHERE d.to_date = &apos;9999-01-01&apos; AND s.to_date = &apos;9999-01-01&apos;GROUP BY d.dept_no</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来源于：&lt;a href=&quot;https://www.nowcoder.com/ta/sql&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="SQL" scheme="https://mlone.top/categories/SQL/"/>
    
    
      <category term="sql" scheme="https://mlone.top/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>java反射机制</title>
    <link href="https://mlone.top/post/3ecb78ee.html"/>
    <id>https://mlone.top/post/3ecb78ee.html</id>
    <published>2018-11-10T10:39:32.000Z</published>
    <updated>2019-02-25T10:35:06.300Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/yrstudy/p/6500982.html" target="_blank" rel="noopener">https://www.cnblogs.com/yrstudy/p/6500982.html</a></p><a id="more"></a><p>往往当我们面对一项新的知识时，我们往往需要知道三个方面，它是什么，它能做什么，它比原有知识强在哪里，我们该怎么使用它。当你能够解决这些问题时，便意味着你已经对这项知识入门了。</p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>  Java Reflaction in Action有这么一句话，可以解释。反射是运行中的程序检查自己和软件运行环境的能力，它可以根据它发现的进行改变。通俗的讲就是反射可以在运行时根据指定的类名获得类的信息。</p><h2 id="二、为什么"><a href="#二、为什么" class="headerlink" title="二、为什么"></a>二、为什么</h2><p>   我们为什么要使用反射，它的作用是什么，它在实际的编程中有什么应用。</p><p>　　首先我们先明确两个概念，静态编译和动态编译。</p><p>　　静态编译：在编译时确定类型，绑定对象,即通过。 </p><p>　　动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。   </p><p>　　我们可以明确的看出动态编译的好处，而反射就是运用了动态编译创建对象。</p><p>　　那么我们再来看看实际中反射又有什么好处那？</p><p>　　往往对比能更加直观的向我们展示两者的不同。</p><p>　　先从某个代码案例上来解释（套用一篇博文的一个例子：<a href="http://blog.csdn.net/justdoit_potato/article/details/51011843）" target="_blank" rel="noopener">http://blog.csdn.net/justdoit_potato/article/details/51011843）</a></p><p>若是不用反射，它是这样的:</p><pre><code>interface fruit{      public abstract void eat();  }  class Apple implements fruit{      public void eat(){          System.out.println(&quot;Apple&quot;);      }  }  class Orange implements fruit{      public void eat(){          System.out.println(&quot;Orange&quot;);      }  }  // 构造工厂类  // 也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了  class Factory{      public static fruit getInstance(String fruitName){          fruit f=null;          if(&quot;Apple&quot;.equals(fruitName)){              f=new Apple();          }          if(&quot;Orange&quot;.equals(fruitName)){              f=new Orange();          }          return f;      }  }  class hello{      public static void main(String[] a){          fruit f=Factory.getInstance(&quot;Orange&quot;);          f.eat();      }  } </code></pre><p>可以发现，每当我们要添加一种新的水果的时候，我们将不得不改变Factory中的源码，而往往改变原有正确代码是一种十分危险的行为。而且随着水果种类的增加，你会发现你的factory类会越来越臃肿，</p><p>不得不说这是一种十分–的做法。（初学者可能会问，我们为什么不直接在main方法中new水果那，我们可能会需要getInstance方法做一些别的事情。。。所以不直接new）；</p><p>而反射无疑是一种聪明的办法，看代码:</p><pre><code>interface fruit{         public abstract void eat();  }  class Apple implements fruit{      public void eat(){          System.out.println(&quot;Apple&quot;);      }  }  class Orange implements fruit{      public void eat(){          System.out.println(&quot;Orange&quot;);      }  }  class Factory{      public static fruit getInstance(String ClassName){          fruit f=null;          try{              f=(fruit)Class.forName(ClassName).newInstance();          }catch (Exception e) {              e.printStackTrace();          }          return f;      }  }  class hello{      public static void main(String[] a){          fruit f=Factory.getInstance(&quot;Reflect.Apple&quot;);          if(f!=null){              f.eat();          }      }  }</code></pre><p>在出现新品种水果的时候，你完全不用去修改原有代码。</p><p>　　从上面的案例中，我们可以清楚的体会到反射的优越性。</p><p>　　那么有的人又会问，这个例子能完全明白，但是如果放到实际的编程，应用中，我们又会在什么情况下用到反射那？</p><p>　　举一个看到过的例子，在实际开发中，我们需要把一个包中的class new出来，但是这个包中的类总是需要变动，那么怎么办，难道总是修改main方法中xxx=new xxx()吗。这样无疑是麻烦的。而运用反射。我们可以相应的增加一个配置文件，在里面记录包中所有的类名，包中类增加时就加一个类名，删除时就删除一个类名。让main方法去读取这个配置文件中的类名，通过反射获得实例，完全不用我们去修改main方法中的代码。</p><p>　　反射还有什么用那？他甚至可以修改其他类中的私有属性。android开发中，我们需要改变一个私有标志位的时候，android源码并没有提供set方法，我们又不能改变源码，怎么办，反射可以完美解决这个问题。</p><p>　　说了这么多，那么我们的开发中，为什么不全部都用反射那？一个原因，开销，它的开销是什么昂贵的，随意尽量在最需要的地方使用反射。</p><h2 id="三、怎么用"><a href="#三、怎么用" class="headerlink" title="三、怎么用"></a>三、怎么用</h2><p>说完是什么，为什么，我们必然需要掌握如何使用反射，先看反射中涉及了那些方法。</p><p>　 Class c=Class.forName(“className”); 注明：<em>className必须为全限定名，也就是：包名+类名，比如，cn.netjava.pojo.UserInfo; </em></p><pre><code>Object obj=c.newInstance();//创建对象的实例 OK，有了对象就什么都好办了，想要什么信息就有什么信息了。 **获得构造函数的方法：**Constructor getConstructor(Class[] params)//根据指定参数获得public构造器Constructor[] getConstructors()//获得public的所有构造器Constructor getDeclaredConstructor(Class[] params)//根据指定参数获得public和非public的构造器Constructor[] getDeclaredConstructors()//获得public的所有构造器 **获得类方法的方法：**Method getMethod(String name, Class[] params),根据方法名，参数类型获得方法Method[] getMethods()//获得所有的public方法Method getDeclaredMethod(String name, Class[] params)//根据方法名和参数类型，获得public和非public的方法Method[] getDeclaredMethods()//获得所以的public和非public方法 </code></pre><p>   <strong> 获得类中属性的方法：</strong><br>    Field getField(String name)//根据变量名得到相应的public变量</p><pre><code>Field[] getFields()//获得类中所以public的方法Field getDeclaredField(String name)//根据方法名获得public和非public变量Field[] getDeclaredFields()//获得类中所有的public和非public方法</code></pre><p>看到这些方法，你就可以明白，反射是多么的强大了，当你正确使用这些方法的时候，基本上是掌握了反射的技巧。</p><p>参考博文：<a href="http://www.cnblogs.com/jqyp/archive/2012/03/29/2423112.html" target="_blank" rel="noopener">http://www.cnblogs.com/jqyp/archive/2012/03/29/2423112.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/yrstudy/p/6500982.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yrstudy/p/6500982.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="反射" scheme="https://mlone.top/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>java中的Class类</title>
    <link href="https://mlone.top/post/1dc53dc8.html"/>
    <id>https://mlone.top/post/1dc53dc8.html</id>
    <published>2018-11-10T09:39:32.000Z</published>
    <updated>2019-02-25T10:31:26.105Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/yepei/p/5649276.html" target="_blank" rel="noopener">https://www.cnblogs.com/yepei/p/5649276.html</a></p><a id="more"></a><p>Class 类是在Java语言中定义一个特定类的实现。一个类的定义包含成员变量，成员方法，还有这个类实现的接口，以及这个类的父类。Class类的对象用于表示当前运行的 Java 应用程序中的类和接口。 比如：每个数组均属于一个 Class 类对象，所有具有相同元素类型和维数的数组共享一个Class 对象。基本的 Java 类型(boolean, byte, char, short,int, long, float 和 double) 和 void 类型也可表示为 Class 对象。</p><p>以下示例使用 Class 对象显示一个对象的 Class 名：</p><pre><code>void printClassName(Object obj) {    System.out.println(&quot;The class of &quot; + obj + &quot; is &quot; + obj.getClass().getName()); }</code></pre><p> 我们都知道所有的java类都是继承了object这个类，在object这个类中有一个方法：getclass().这个方法是用来取得该类已经被实例化了的对象的该类的引用，这个引用指向的是Class类的对象（呵呵，有点别扭）。我们自己无法生成一个Class对象（构造函数为private)，而这个Class类的对象是在当各类被调入时，由 Java 虚拟机自动创建 Class 对象，或通过类装载器中的 defineClass 方法生成。 我们生成的对象都会有个字段记录该对象所属类在CLass类的对象的所在位置。如下图所示：</p><p><img src="\assets\blogImg\4\6.png" alt="图6"></p><p> 我们可以把每个Class类的对象当做众多类的代理。而且在每个Class类对象中有会有字段记录他引用的这个类的类加载器。如果该字段为null,表示该类的加载器为bootstrap loader.具体原因见我之前分享过的一篇“《ClassLoader工作机制 》”一文。</p><p><img src="\assets\blogImg\4\7.png" alt="图7"></p><p>我们知道java中有多个加载器，每个加载器能载入多个类，所以只要取得Class类对象，就可利用其getClassLoader()方法取得该类加载器的引用。</p><p>jvm为每种类管理者独一的Class对象。因此我们可以用双等号操作符来比较对象：a1.getClass()==A.class;应该返回的是true。</p><p><strong>forName(String classname)</strong>和 forName(Stringclassname，{<em>}boolean initialze,</em>ClassLoader <em>loader)</em>方法。</p><p>该方法返回给定串名相应的Class对象。若给定一个类或接口的完整路径名，那么此方法将试图定位、装载和连接该类。若成功，返回该类对象。否则，抛出ClassNotFoundException异常。例如，下面代码段返回名为java.lang.Thread的运行Class描述器。Classt=Class.forName(“java.lang.Thread”);此方法是需要指定类加载器的，当用到仅有一个String参数的forName方法时，Class对象将默认调用当前类加载器作为加载器和将第二参数为true。第二个参数说明：如果是false时，调用forName方法只是在命令类加载器载入该类，而不初始化该类的静态区块，只有当该类第一次实例化时，静态区块才被调用。当为true时，则载入时就调用静态区块。</p><p><strong>getClassLoader()</strong></p><p>获取该类的类装载器</p><p><strong>getComponentType()</strong></p><p>如果当前类表示一个数组，则返回表示该数组组件的Class对象，否则返回null。</p><p><strong>getConstructor(Class[])</strong></p><p>返回当前Class对象表示的类的指定的公有构造子对象。</p><p><strong>getConstructors()</strong></p><p>返回当前Class对象表示的类的所有公有构造子对象数组。</p><p><strong>getDeclaredConstructor(Class[])</strong></p><p>返回当前Class对象表示的类的指定已说明的一个构造子对象。</p><p><strong>getDeclaredConstructors()</strong></p><p>返回当前Class对象表示的类的所有已说明的构造子对象数组。</p><p><strong>getDeclaredField(String)</strong></p><p>返回当前Class对象表示的类或接口的指定已说明的一个域对象。</p><p><strong>getDeclaredFields()</strong></p><p>返回当前Class对象表示的类或接口的所有已说明的域对象数组。</p><p><strong>getDeclaredMethod(String,Class[])</strong></p><p>返回当前Class对象表示的类或接口的指定已说明的一个方法对象。</p><p><strong>getDeclaredMethods()</strong></p><p>返回Class对象表示的类或接口的所有已说明的方法数组。</p><p><strong>getField(String)</strong></p><p>返回当前Class对象表示的类或接口的指定的公有成员域对象。</p><p><strong>getFields()</strong></p><p>返回当前Class对象表示的类或接口的所有可访问的公有域对象数组。</p><p><strong>getInterfaces()</strong></p><p>返回当前对象表示的类或接口实现的接口。</p><p><strong>getMethod(String,Class[])</strong></p><p>返回当前Class对象表示的类或接口的指定的公有成员方法对象。</p><p><strong>getMethods()</strong></p><p>返回当前Class对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。</p><p><strong>getModifiers()</strong></p><p>返回该类或接口的Java语言修改器代码。</p><p><strong>getName()</strong></p><p>返回Class对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。</p><p><strong>getResource(String)</strong></p><p>按指定名查找资源。</p><p><strong>getResourceAsStream(String)</strong></p><p>用给定名查找资源。</p><p><strong>getSigners()</strong></p><p>获取类标记。</p><p><strong>getSuperclass()</strong></p><p>如果此对象表示除Object外的任一类,那么返回此对象的父类对象。</p><p><strong>isArray()</strong></p><p>如果Class对象表示一个数组则返回true,否则返回false。</p><p><strong>isAssignableFrom(Class)</strong></p><p>判定Class对象表示的类或接口是否同参数指定的Class表示的类或接口相同，或是其父类。</p><p><strong>isInstance(Object)</strong></p><p>此方法是Java语言instanceof操作的动态等价方法。</p><p><strong>isInterface()</strong></p><p>判定指定的Class对象是否表示一个接口类型。</p><p><strong>isPrimitive()</strong><br>判定指定的Class对象是否表示一个Java的基类型。</p><p><strong>newInstance()</strong></p><p>创建类的新实例。</p><p><strong>toString()</strong></p><p>将对象转换为字符串。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/yepei/p/5649276.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yepei/p/5649276.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GC执行finalize方法的过程</title>
    <link href="https://mlone.top/post/f6af4d9c.html"/>
    <id>https://mlone.top/post/f6af4d9c.html</id>
    <published>2018-11-05T06:33:50.000Z</published>
    <updated>2019-02-25T09:50:59.913Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/Smina/p/7189427.html" target="_blank" rel="noopener">https://www.cnblogs.com/Smina/p/7189427.html</a></p><a id="more"></a><p>注：本文的目的并不是鼓励使用finalize方法，而是大致理清其作用、问题以及GC执行finalize的过程。</p><h2 id="1-finalize的作用"><a href="#1-finalize的作用" class="headerlink" title="1. finalize的作用"></a>1. finalize的作用</h2><ul><li>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</li><li>finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性</li><li>不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题]</li></ul><h2 id="2-finalize的问题"><a href="#2-finalize的问题" class="headerlink" title="2. finalize的问题"></a>2. finalize的问题</h2><ul><li>一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法</li><li>System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</li><li>Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</li><li>finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</li><li>对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</li><li>finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)</li></ul><h2 id="3-finalize的执行过程-生命周期"><a href="#3-finalize的执行过程-生命周期" class="headerlink" title="3. finalize的执行过程(生命周期)"></a>3. finalize的执行过程(生命周期)</h2><p>(1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p><p>(2) 具体的finalize流程：</p><ul><li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li><li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li><li>finalized: 表示GC已经对该对象执行过finalize方法</li><li>reachable: 表示GC Roots引用可达</li><li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li><li>unreachable：对象不可通过上面两种途径可达</li></ul><p>状态变迁图：</p><p><img src="\assets\blogImg\4\5.jpg" alt="图5"></p><p>变迁说明：</p><ol><li>新建对象首先处于[reachable, unfinalized]状态(A)</li><li>随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</li><li>若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</li><li>在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</li><li>处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</li><li>程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</li><li>若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</li><li>若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</li><li>注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法</li></ol><h2 id="4-一些代码示例"><a href="#4-一些代码示例" class="headerlink" title="4. 一些代码示例"></a>4. 一些代码示例</h2><h3 id="对象复活"><a href="#对象复活" class="headerlink" title="对象复活"></a>对象复活</h3><pre><code>public class GC {  // 这里的GC是类名，并非垃圾回收器    public static GC SAVE_HOOK = null;     public static void main(String[] args) throws InterruptedException {        // 新建对象，因为SAVE_HOOK指向这个对象，对象此时的状态是(reachable,unfinalized)        SAVE_HOOK = new GC();         //将SAVE_HOOK设置成null，此时刚才创建的对象就不可达了，因为没有句柄再指向它了，对象此时状态是(unreachable，unfinalized)        SAVE_HOOK = null;         //强制系统执行垃圾回收，系统发现刚才创建的对象处于unreachable状态，并检测到这个对象的类覆盖了finalize方法，因此把这个对象放入F-Queue队列，由低优先级线程执行它的finalize方法，此时对象的状态变成(unreachable, finalizable)或者是(finalizer-reachable,finalizable)        System.gc();         // sleep，目的是给低优先级线程从F-Queue队列取出对象并执行其finalize方法提供机会。在执行完对象的finalize方法中的super.finalize()时，对象的状态变成(unreachable,finalized)状态，但接下来在finalize方法中又执行了SAVE_HOOK = this;这句话，又有句柄指向这个对象了，对象又可达了。因此对象的状态又变成了(reachable, finalized)状态。        Thread.sleep(500);        // 这里楼主说对象处于(reachable,finalized)状态应该是合理的。对象的finalized方法被执行了，因此是finalized状态。又因为在finalize方法是执行了SAVE_HOOK=this这句话，本来是unreachable的对象，又变成reachable了。        if (null != SAVE_HOOK) { //此时对象应该处于(reachable, finalized)状态             // 这句话会输出，注意对象由unreachable，经过finalize复活了。            System.out.println(&quot;Yes , I am still alive&quot;);         } else {             System.out.println(&quot;No , I am dead&quot;);         }         // 再一次将SAVE_HOOK放空，此时刚才复活的对象，状态变成(unreachable,finalized)        SAVE_HOOK = null;         // 再一次强制系统回收垃圾，此时系统发现对象不可达，虽然覆盖了finalize方法，但已经执行过了，因此直接回收。        System.gc();         // 为系统回收垃圾提供机会        Thread.sleep(500);         if (null != SAVE_HOOK) {             // 这句话不会输出，因为对象已经彻底消失了。            System.out.println(&quot;Yes , I am still alive&quot;);         } else {             System.out.println(&quot;No , I am dead&quot;);         }     }     @Override     protected void finalize() throws Throwable { // 覆写Object类中的finalize方法        super.finalize();  // 调用Object类中finalize方法        System.out.println(&quot;execute method finalize()&quot;);         // 这句话让对象的状态由unreachable变成reachable，就是对象复活        SAVE_HOOK = this;     } }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/Smina/p/7189427.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/Smina/p/7189427.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java中的finalize方法[转载]</title>
    <link href="https://mlone.top/post/b52b9753.html"/>
    <id>https://mlone.top/post/b52b9753.html</id>
    <published>2018-11-05T05:33:50.000Z</published>
    <updated>2019-02-25T09:50:58.539Z</updated>
    
    <content type="html"><![CDATA[<p>[转载自：<a href="https://blog.csdn.net/Justin_zhao/article/details/74358828" target="_blank" rel="noopener">Java中的finalize()方法</a>]</p><p><em>Java中假定finalize的工作原理为：一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的finalize方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！</em><br><a id="more"></a><br><em>finalize()的作用：finalize用于在GC发生前事先调用去回收JNI调用中申请的特殊内存，下次GC发生时候保证GC后所有该对象的内存都释放了。</em></p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>Java的垃圾回收器只会释放由我们new出来的内存堆块，那些不是由new出来的“特殊内存”，垃圾回收器是不会管理的。</li><li>所谓的特殊内存指通过JNI用C/C++向系统申请的内存，这些内存如果不手动去清除就会一直占据在内存中。</li><li>而且，垃圾回收本身就有开销，所以虚拟机不会经常GC，只有当内存快要耗尽的时候JVM才会触发GC。</li></ul><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><h5 id="由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize-方法让我们来执行清理工作。"><a href="#由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize-方法让我们来执行清理工作。" class="headerlink" title="-由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize()方法让我们来执行清理工作。"></a>-由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize()方法让我们来执行清理工作。</h5><p>-当系统进行GC的时候会先调用finalize方法，然后再下次才会回收对象的内存。因为native中申请的内存，GC没有办法回收所以finalize被用来做垃圾回前的重要清理工作：释放特殊内存。</p><h5 id="所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！"><a href="#所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！" class="headerlink" title="-所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！"></a>-所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！</h5><p>-如果GC不发生那么finalize也不会发生，finalize是Object的protect方法，不可以在类族外访问。</p><h3 id="不是析构函数"><a href="#不是析构函数" class="headerlink" title="不是析构函数"></a>不是析构函数</h3><ul><li>Java因为有GC机制，所以没有析构函数的概念！</li><li>finalize不是C++中的析构函数：析构函数肯定是会销毁该对象的，但是finalize因为gc机制不会经常发生，所以其被执行的是不确定的。（不知道是不是我没理解透，没觉得这两个有什么可比性，一个主动发生一个被动发生）</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>调用System.gc()，可以强制让gc发生来触发finalize方法！但是GC也只是GC垃圾的对象（没有被引用的），非垃圾的对象的finalize不会被调用。程序终止和GC不是一个概念。</li><li>正常情况下你调用finalize(）都是直接super.finalize()使用父类的就行了。</li><li>finalize一般不用！被执行的不确定性太大。不要指望使用finalize来回收你的对象，它只会在系统进行GC的时候清理特殊内存，不受你的控制！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[转载自：&lt;a href=&quot;https://blog.csdn.net/Justin_zhao/article/details/74358828&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java中的finalize()方法&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Java中假定finalize的工作原理为：一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的finalize方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java中HashMap的实现原理</title>
    <link href="https://mlone.top/post/1ed5a07.html"/>
    <id>https://mlone.top/post/1ed5a07.html</id>
    <published>2018-11-03T13:09:08.000Z</published>
    <updated>2019-02-23T13:34:12.185Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/yuanblog/p/4441017.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanblog/p/4441017.html</a></p><a id="more"></a><h3 id="一、Java中的hashCode和equals"><a href="#一、Java中的hashCode和equals" class="headerlink" title="一、Java中的hashCode和equals"></a>一、Java中的hashCode和equals</h3><h4 id="1、关于hashCode"><a href="#1、关于hashCode" class="headerlink" title="1、关于hashCode"></a>1、关于hashCode</h4><p>   1.hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的</p><p>   2.如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同</p><p>   3.如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点</p><p>   4.两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”</p><p><strong>再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。</strong></p><p>以下对hashCode的解读摘自其他博客：</p><pre><code>1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有例如内存中有这样的位置0  1  2  3  4  5  6  7 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。但如果用hashcode那就会使效率提高很多。我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。那么，重写了equals()，为什么还要重写hashCode()呢？想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊</code></pre><h4 id="2、关于equals"><a href="#2、关于equals" class="headerlink" title="2、关于equals"></a>2、关于equals</h4><p>1.equals和==<br>==用于比较引用和比较基本数据类型时具有不同的功能：<br>比较基本数据类型，如果两个值相同，则结果为true<br>而在比较引用时，如果引用指向内存中的同一对象，结果为true;</p><p>equals()作为方法，实现对象的比较。由于==运算符不允许我们进行覆盖，也就是说它限制了我们的表达。因此我们复写equals()方法，达到比较对象内容是否相同的目的。而这些通过==运算符是做不到的。</p><p>2.object类的equals()方法的比较规则为：如果两个对象的类型一致，并且内容一致，则返回true,这些类有：</p><pre><code>java.io.file,java.util.Date,java.lang.string,包装类（Integer,Double等）String s1=new String(&quot;abc&quot;);String s2=new String(&quot;abc&quot;);System.out.println(s1==s2);System.out.println(s1.equals(s2));运行结果为false true</code></pre><h3 id="二、HashMap的实现原理"><a href="#二、HashMap的实现原理" class="headerlink" title="二、HashMap的实现原理"></a>二、HashMap的实现原理</h3><h4 id="1-HashMap概述"><a href="#1-HashMap概述" class="headerlink" title="1.HashMap概述"></a>1.HashMap概述</h4><p>   HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>   在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p><img src="/assets/blogImg/4/4.jpg" alt="图4"></p><p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p><p>其中Java源码如下：</p><pre><code>/**  * The table, resized as necessary. Length MUST Always be a power of two.  */transient Entry[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final K key;    V value;    Entry&lt;K,V&gt; next;    final int hash;        ……}</code></pre><p>可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h4 id="2-HashMap实现存储和读取"><a href="#2-HashMap实现存储和读取" class="headerlink" title="2.HashMap实现存储和读取"></a>2.HashMap实现存储和读取</h4><h5 id="1）存储"><a href="#1）存储" class="headerlink" title="1）存储"></a>1）存储</h5><pre><code>public V put(K key, V value) {    // HashMap允许存放null键和null值。    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。    if (key == null)        return putForNullKey(value);    // 根据key的keyCode重新计算hash值。    int hash = hash(key.hashCode());    // 搜索指定hash值在对应table中的索引。    int i = indexFor(hash, table.length);    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {            // 如果发现已有该键值，则存储新的值，并返回原始值            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        }    }    // 如果i索引处的Entry为null，表明此处还没有Entry。    modCount++;    // 将key、value添加到i索引处。    addEntry(hash, key, value, i);    return null;}</code></pre><p>根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p><p>hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p><pre><code>1 static int hash(int h) {2     h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);3     return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);4 }</code></pre><p>我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p><p>根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p><p><strong>通过这种方式就可以高效的解决HashMap的冲突问题。</strong></p><h5 id="2）读取"><a href="#2）读取" class="headerlink" title="2）读取"></a>2）读取</h5><pre><code>public V get(Object key) {    if (key == null)        return getForNullKey();    int hash = hash(key.hashCode());    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];        e != null;        e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))            return e.value;    }    return null;}</code></pre><p>从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p><h5 id="3）归纳起来简单地说"><a href="#3）归纳起来简单地说" class="headerlink" title="3）归纳起来简单地说:"></a>3）归纳起来简单地说:</h5><p>HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p><h4 id="3-HashMap的resize"><a href="#3-HashMap的resize" class="headerlink" title="3.HashMap的resize"></a>3.HashMap的resize</h4><p>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p><p>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16</em>0.75=12的时候，就把数组的大小扩展为2<em>16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75</em>1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p><h4 id="总结：HashMap的实现原理："><a href="#总结：HashMap的实现原理：" class="headerlink" title="总结：HashMap的实现原理："></a>总结：HashMap的实现原理：</h4><p>  <strong>1. 利用key的hashCode重新hash计算出当前对象的元素在数组中的下标。</strong></p><p>  <strong>2. 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中。</strong></p><p>  <strong>3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</strong></p><p>  <strong>4. 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/yuanblog/p/4441017.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yuanblog/p/4441017.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何避免死锁</title>
    <link href="https://mlone.top/post/7b28700.html"/>
    <id>https://mlone.top/post/7b28700.html</id>
    <published>2018-10-29T08:41:34.000Z</published>
    <updated>2019-02-28T04:24:11.955Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>Java多线程中的死锁：</p><p><strong>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</strong></p><p>死锁的发生必须满足以下四个条件：</p><ul><li><p><strong>互斥条件：</strong>一个资源每次只能被一个进程使用。</p></li><li><p><strong>请求与保持条件：</strong>一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p></li><li><p><strong>不可剥夺条件：进</strong>程已获得的资源，在末使用完之前，不能强行剥夺。</p></li><li><p><strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系。</p></li></ul><p>避免死锁最简单的方法就是<strong>阻止循环等待条件</strong>，将系统中所有的资源设置<em>标志位、排序</em>，规定所有的进程<em>在申请资源时必须按照一定的顺序规则</em>来避免死锁。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://mlone.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="多线程" scheme="https://mlone.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>事务的4种隔离级别</title>
    <link href="https://mlone.top/post/9ba28576.html"/>
    <id>https://mlone.top/post/9ba28576.html</id>
    <published>2018-10-28T07:28:02.000Z</published>
    <updated>2019-02-27T08:39:18.355Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><h5 id="关系型数据库存在的数据安全问题："><a href="#关系型数据库存在的数据安全问题：" class="headerlink" title="关系型数据库存在的数据安全问题："></a>关系型数据库存在的数据安全问题：</h5><hr><ul><li><p><strong>脏读：</strong>一个事务读取到了另外一个事务未提交的数据。</p></li><li><p><strong>不可重复读：</strong>一个事务读取到了另外一个事务修改过并提交的数据。（一个事务过程中多次查询，查询的数据结果却不同）</p></li><li><p><strong>幻读（虚读）：</strong>一个事务读取到了另外一个事务插入并提交的新数据。（一个事务过程中多次查询，却查询到了之前并不存在的记录）</p></li></ul><hr><h5 id="事务的4种隔离级别"><a href="#事务的4种隔离级别" class="headerlink" title="事务的4种隔离级别"></a>事务的4种隔离级别</h5><ol><li><p><strong>read uncommitted：读未提交</strong>（可读别人未提交的数据）–&gt;最低级别（存在脏读、不可重复读、虚读问题）</p></li><li><p><strong>read committed：读已提交</strong>（可读别人已提交的数据）–&gt;消除了脏读（存在不可重复读、虚读问题）</p></li><li><p><strong>repeatable read：可重复读</strong>（不读别人提交的数据）–&gt;消除不可重复读（存在虚读问题）</p></li><li><p><strong>serializable：串行化</strong>（别人未提交就作等待不能读数据）–&gt;消除虚读  最高级别  效率最低</p></li></ol><p><em>一般数据库都使用中间两种级别。</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事务" scheme="https://mlone.top/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>JDBC数据库访问与事务处理</title>
    <link href="https://mlone.top/post/9b2f6e20.html"/>
    <id>https://mlone.top/post/9b2f6e20.html</id>
    <published>2018-10-28T06:28:02.000Z</published>
    <updated>2019-02-27T10:07:25.397Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><h4 id="jdbc访问数据库的步骤："><a href="#jdbc访问数据库的步骤：" class="headerlink" title="jdbc访问数据库的步骤："></a>jdbc访问数据库的步骤：</h4><ol><li>获取到数据库的用户名、密码、连接字符串。</li><li>用Class.forName或者其他方法来注册驱动，获得ConnectionManager</li><li>再用ConnectionManager通过连接字符串、用户名、密码，获取到Connection连接，</li><li>通过Connection获得Statement处理对象或者PreparedStatement预处理对象，</li><li>操作完毕后，先关闭statement对象再关闭Connection连接。</li></ol><h4 id="jdbc如何做事务处理？"><a href="#jdbc如何做事务处理？" class="headerlink" title="jdbc如何做事务处理？"></a>jdbc如何做事务处理？</h4><p>首先，设置jdbc的自动提交为false；</p><p>然后，使用数据库连接，开启一个事务transaction；</p><p>接着，对数据库进行多条增删改操作，并添加异常捕获try-catch；</p><p>操作完毕后，进行commit事务提交，并在catch代码块中使用事务回滚rollback功能；</p><p>最后，在finally代码块中关闭数据库连接。</p><h4 id="jdbc入门"><a href="#jdbc入门" class="headerlink" title="jdbc入门"></a>jdbc入门</h4><pre><code>/* 以查找全部记录为例 */import java.sql.DriverManager;import java.sql.Connection;import java.sql.Statement;import java.sql.ResultSet;//首先导入mysql的jdbc包import com.mysql.jdbc.Driver;public class JdbcTest {    @Test    public void process(){        Connection conn = null; // 创建连接对象        Statement stmt = null;    // 创建能执行SQL语句的Statement对象        ResultSet rs = null; // 创建SQL语句执行结果返回对象        try {//异常捕获            // 1.通过jdbc包中的Driver类来注册驱动            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);            // 2.通过DriverManager以及连接参数获取链接Connection            conn = DriverManager.getConnection(&quot;jdbc:mysql:///DBname&quot;, &quot;username&quot;, &quot;password&quot;); //参数：数据库连接字符串、用户名、密码            // 3.由Connection开启事务 --设置默认提交为false            conn.setAutoCommit(false);            // 4.由Connection创建能执行SQL语句的Statement对象            stmt = conn.createStatement();//或PreparedStatement预处理对象            // 5.编写SQL语句并执行            String sql = &quot;select * from t_user&quot;;            // 执行SQL语句获得结果集            rs = stmt.executeQuery(sql);            // 遍历查询结果集rs获取数据            while(rs.next()){                // 拿出来                int id =rs.getInt(&quot;id&quot;);                String username = rs.getString(&quot;username&quot;);                String password = rs.getString(&quot;password&quot;);                System.out.println(id+&quot; &quot;+username+&quot; &quot;+password);            }            // 6.手动提交事务            conn.commit();        } catch (Exception e) { //ClassNotFoundException、SQLException            // 7.若发生异常  回滚事务（对于增删改）            try {                conn.rollback();            } catch (SQLException e1) {                e1.printStackTrace();            }            e.printStackTrace(); //打印异常信息            throw new RuntimeException(e);        }        finally{            // 8.释放资源            /** 释放资源的标准文档代码: */            // 8.1先关闭执行SQL语句的结果返回对象ResultSet            if(rs != null){                try {                    rs.close();                } catch (SQLException e) {                    e.printStackTrace();                }                rs = null;            }            // 8.2然后再关闭能执行SQL语句的Statement对象            if(stmt != null){                try {                    stmt.close();                } catch (SQLException e) {                    e.printStackTrace();                }                stmt = null;            }            // 8.3最后关闭链接            if(conn != null){                try {                    conn.close();                } catch (SQLException e) {                    e.printStackTrace();                }                conn = null;            }        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事务" scheme="https://mlone.top/tags/%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="jdbc" scheme="https://mlone.top/tags/jdbc/"/>
    
  </entry>
  
  <entry>
    <title>事务的四大特性ACID</title>
    <link href="https://mlone.top/post/5554abcc.html"/>
    <id>https://mlone.top/post/5554abcc.html</id>
    <published>2018-10-27T07:28:02.000Z</published>
    <updated>2019-02-27T08:39:18.356Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><h5 id="⑴-原子性（Atomicity）"><a href="#⑴-原子性（Atomicity）" class="headerlink" title="⑴ 原子性（Atomicity）"></a>⑴ 原子性（Atomicity）</h5><p>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><h5 id="⑵-一致性（Consistency）"><a href="#⑵-一致性（Consistency）" class="headerlink" title="⑵ 一致性（Consistency）"></a>⑵ 一致性（Consistency）</h5><p>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。</p><h5 id="⑶-隔离性（Isolation）"><a href="#⑶-隔离性（Isolation）" class="headerlink" title="⑶ 隔离性（Isolation）"></a>⑶ 隔离性（Isolation）</h5><p>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p><p>即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p><h5 id="⑷-持久性（Durability）"><a href="#⑷-持久性（Durability）" class="headerlink" title="⑷ 持久性（Durability）"></a>⑷ 持久性（Durability）</h5><p>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://mlone.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="事务" scheme="https://mlone.top/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>索引的作用</title>
    <link href="https://mlone.top/post/cfd87e66.html"/>
    <id>https://mlone.top/post/cfd87e66.html</id>
    <published>2018-10-26T09:28:02.000Z</published>
    <updated>2019-02-27T10:07:25.408Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要创建索引呢？</p><a id="more"></a><p>这是因为，创建索引可以大大提高系统的性能。</p><ol><li><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 </p></li><li><p>可以大大<strong>加快数据的检索速度</strong>，这也是创建索引的最主要的原因。 </p></li><li><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p></li><li><p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p></li><li><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么要创建索引呢？&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://mlone.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>四种Java线程池用法解析</title>
    <link href="https://mlone.top/post/984eacd5.html"/>
    <id>https://mlone.top/post/984eacd5.html</id>
    <published>2018-10-25T08:46:56.000Z</published>
    <updated>2019-02-28T09:10:16.037Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/ruiati/p/6134131.html" target="_blank" rel="noopener">https://www.cnblogs.com/ruiati/p/6134131.html</a></p><a id="more"></a><p>本文为大家分析四种Java线程池用法，供大家参考，具体内容如下</p><p><a href="http://www.jb51.net/article/81843.htm" target="_blank" rel="noopener">http://www.jb51.net/article/81843.htm</a></p><h4 id="1、new-Thread的弊端"><a href="#1、new-Thread的弊端" class="headerlink" title="1、new Thread的弊端"></a>1、new Thread的弊端</h4><p>执行一个异步任务你还只是如下new Thread吗？</p><pre><code>new Thread(new Runnable() {  @Override  public void run() {    // TODO Auto-generated method stub    }  }).start();</code></pre><p>那你就out太多了，new Thread的弊端如下：</p><ul><li>每次new Thread新建对象性能差。</li><li>线程缺乏统一管理，可能无限制新建线程，相互之间竞争，及可能占用过多系统资源导致死机或oom。</li><li>缺乏更多功能，如定时执行、定期执行、线程中断。</li></ul><p>相比new Thread，Java提供的四种线程池的好处在于：</p><ul><li>重用存在的线程，减少对象创建、消亡的开销，性能佳。</li><li>可有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。</li><li>提供定时执行、定期执行、单线程、并发数控制等功能。</li></ul><h4 id="2、Java-线程池"><a href="#2、Java-线程池" class="headerlink" title="2、Java 线程池"></a>2、Java 线程池</h4><p>Java通过Executors提供四种线程池，分别为：</p><ol><li>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</li><li>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li></ol><p><strong>(1) newCachedThreadPool：</strong></p><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。示例代码如下：</p><pre><code>ExecutorService cachedThreadPool = Executors.newCachedThreadPool();  for (int i = 0; i &lt; 10; i++) {    final int index = i;  try {    Thread.sleep(index * 1000);  }     catch (InterruptedException e) {      e.printStackTrace();  }cachedThreadPool.execute(new Runnable() {@Overridepublic void run() {  System.out.println(index);}});}</code></pre><p>线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。</p><p><strong>(2)newFixedThreadPool：</strong></p><p>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。示例代码如下：</p><pre><code>ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);  for (int i = 0; i &lt; 10; i++) {  final int index = i;  fixedThreadPool.execute(new Runnable() {@Overridepublic void run() {try {  System.out.println(index);  Thread.sleep(2000);} catch (InterruptedException e) {  // TODO Auto-generated catch block  e.printStackTrace();  }}});}</code></pre><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。</p><p>定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。可参考PreloadDataCache。</p><p><strong>(3)newScheduledThreadPool：</strong></p><p>创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下：</p><pre><code>ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.schedule(new Runnable() {@Overridepublic void run() {  System.out.println(&quot;delay 3 seconds&quot;);}}, 3, TimeUnit.SECONDS);</code></pre><p>表示延迟3秒执行。</p><p>定期执行示例代码如下：</p><pre><code>scheduledThreadPool.scheduleAtFixedRate(new Runnable() {@Overridepublic void run() {  System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;);}}, 1, 3, TimeUnit.SECONDS);</code></pre><p>表示延迟1秒后每3秒执行一次。</p><p>ScheduledExecutorService比Timer更安全，功能更强大</p><p><strong>(4)newSingleThreadExecutor：</strong></p><p>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下：</p><pre><code>ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();for (int i = 0; i &lt; 10; i++) {final int index = i;singleThreadExecutor.execute(new Runnable() {@Overridepublic void run() {  try {    System.out.println(index);  Thread.sleep(2000);} catch (InterruptedException e) {  // TODO Auto-generated catch block  e.printStackTrace();    }}  });}</code></pre><p>结果依次输出，相当于顺序执行各个任务。</p><p>现行大多数GUI程序都是单线程的。Android中单线程可用于数据库操作，文件操作，应用批量安装，应用批量删除等不适合并发但可能IO阻塞性及影响UI线程响应的操作。</p><p><strong>线程池的作用：</strong></p><p>线程池作用就是限制系统中执行线程的数量。<br>根 据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排 队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池 中有等待的工作线程，就可以开始运行了；否则进入等待队列。</p><p><strong>为什么要用线程池:</strong></p><p>1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</p><p>2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</p><p>Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。</p><p><strong>比较重要的几个类：</strong></p><p>ExecutorService： 真正的线程池接口。</p><p>ScheduledExecutorService： 能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</p><p>ThreadPoolExecutor： ExecutorService的默认实现。</p><p>ScheduledThreadPoolExecutor： 继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</p><p>要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。</p><p><strong>1.newSingleThreadExecutor</strong></p><p>创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</p><p><strong>2.newFixedThreadPool</strong></p><p>创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</p><p><strong>3.newCachedThreadPool</strong></p><p>创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，</p><p>那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</p><p><strong>4.newScheduledThreadPool</strong></p><p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p><p>实例代码</p><p><strong>一、固定大小的线程池，newFixedThreadPool：</strong></p><pre><code>package app.executors; import java.util.concurrent.Executors; import java.util.concurrent.ExecutorService; /**  * Java线程：线程池  *  * @author xiho */public class Test {   public static void main(String[] args) {     // 创建一个可重用固定线程数的线程池     ExecutorService pool = Executors.newFixedThreadPool(2);     // 创建线程     Thread t1 = new MyThread();     Thread t2 = new MyThread();     Thread t3 = new MyThread();     Thread t4 = new MyThread();     Thread t5 = new MyThread();     // 将线程放入池中进行执行     pool.execute(t1);     pool.execute(t2);     pool.execute(t3);     pool.execute(t4);     pool.execute(t5);     // 关闭线程池     pool.shutdown();   } } class MyThread extends Thread {   @Override  public void run() {     System.out.println(Thread.currentThread().getName() + &quot;正在执行。。。&quot;);   } }</code></pre><p>输出结果：</p><pre><code>pool-1-thread-1正在执行。。。 pool-1-thread-3正在执行。。。 pool-1-thread-4正在执行。。。 pool-1-thread-2正在执行。。。 pool-1-thread-5正在执行。。。</code></pre><p>改变ExecutorService pool = Executors.newFixedThreadPool(5)中的参数：ExecutorService pool = Executors.newFixedThreadPool(2)，</p><p>输出结果是：</p><pre><code>pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-2正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-2正在执行。。。</code></pre><p>从以上结果可以看出，newFixedThreadPool的参数指定了可以运行的线程的最大数目，超过这个数目的线程加进去以后，不会运行。其次，加入线程池的线程属于托管状态，线程的运行不受加入顺序的影响。</p><p><strong>二、单任务线程池，newSingleThreadExecutor：</strong></p><p>仅仅是把上述代码中的ExecutorService pool = Executors.newFixedThreadPool(2)改为ExecutorService pool = Executors.newSingleThreadExecutor();</p><p>输出结果：</p><pre><code>pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。 pool-1-thread-1正在执行。。。</code></pre><p>可以看出，每次调用execute方法，其实最后都是调用了thread-1的run方法。</p><p><strong>三、可变尺寸的线程池，newCachedThreadPool：</strong></p><p>与上面的类似，只是改动下pool的创建方式：ExecutorService pool = Executors.newCachedThreadPool();</p><p>输出结果：</p><pre><code>pool-1-thread-1正在执行。。。 pool-1-thread-2正在执行。。。 pool-1-thread-4正在执行。。。 pool-1-thread-3正在执行。。。 pool-1-thread-5正在执行。。。</code></pre><p>这种方式的特点是：可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</p><p><strong>四、延迟连接池，newScheduledThreadPool：</strong></p><pre><code>public class TestScheduledThreadPoolExecutor {  public static void main(String[] args) {    ScheduledThreadPoolExecutor exec = new ScheduledThreadPoolExecutor(1);    exec.scheduleAtFixedRate(new Runnable() {//每隔一段时间就触发异常           @Override           publicvoid run() {              //throw new RuntimeException();              System.out.println(&quot;================&quot;);           }         }, 1000, 5000, TimeUnit.MILLISECONDS);    exec.scheduleAtFixedRate(new Runnable() {//每隔一段时间打印系统时间，证明两者是互不影响的           @Override           publicvoid run() {              System.out.println(System.nanoTime());           }         }, 1000, 2000, TimeUnit.MILLISECONDS);  }}</code></pre><p>输出结果：</p><pre><code>================838464454951683866438290348388643830710================839064385138383926438793198400643939383</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/ruiati/p/6134131.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/ruiati/p/6134131.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程池" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>mysql外键介绍</title>
    <link href="https://mlone.top/post/c1424651.html"/>
    <id>https://mlone.top/post/c1424651.html</id>
    <published>2018-10-25T08:28:02.000Z</published>
    <updated>2019-02-27T10:07:25.403Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><ol><li><p>MySQL外键必须使用存储引擎为  innDB  其中MySAM 和MEMORYH这两种引擎不支持。</p></li><li><p>由数据库自身保证数据一致性，完整性，更可靠，因为程序很难100％保证数据的完整性，而用外键即使在数据库服务器当机或者出现其他问题的时候，也能够最大限度的<strong>保证数据的一致性和完整性。</strong></p></li><li><p>设置外键约束的两个表之间会具有父子关系，即子表中外键的字段的取值范围由父表所决定。</p></li><li><p>设置外键一定程度上降低数据库的速度。</p></li><li><p>子表的外键字段的数据类型和父表中要一致。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://mlone.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>java常用的几种线程池比较</title>
    <link href="https://mlone.top/post/2f895ce9.html"/>
    <id>https://mlone.top/post/2f895ce9.html</id>
    <published>2018-10-25T07:46:56.000Z</published>
    <updated>2019-02-28T08:58:22.793Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.cnblogs.com/aaron911/p/6213808.html" target="_blank" rel="noopener">https://www.cnblogs.com/aaron911/p/6213808.html</a></p><a id="more"></a><h1 id="1-为什么使用线程池"><a href="#1-为什么使用线程池" class="headerlink" title="1. 为什么使用线程池"></a>1. 为什么使用线程池</h1><p>诸如 Web 服务器、数据库服务器、文件服务器或邮件服务器之类的许多服务器应用程序都面向处理来自某些远程来源的大量短小的任务。请求以某种方式到达服务器，这种方式可能是通过网络协议（例如 HTTP、FTP 或 POP）、通过 JMS 队列或者可能通过轮询数据库。不管请求如何到达，服务器应用程序中经常出现的情况是：单个任务处理的时间很短而请求的数目却是巨大的。</p><p>构建服务器应用程序的一个简单模型是：每当一个请求到达就创建一个新线程，然后在新线程中为请求服务。实际上对于原型开发这种方法工作得很好，但如果试图部署以这种方式运行的服务器应用程序，那么这种方法的严重不足就很明显。每个请求对应一个线程（thread-per-request）方法的不足之一是：为每个请求创建一个新线程的开销很大；为每个请求创建新线程的服务器在创建和销毁线程上花费的时间和消耗的系统资源要比花在处理实际的用户请求的时间和资源更多。</p><p>除了创建和销毁线程的开销之外，活动的线程也消耗系统资源。在一个 JVM 里创建太多的线程可能会导致系统由于过度消耗内存而用完内存或“切换过度”。为了防止资源不足，服务器应用程序需要一些办法来限制任何给定时刻处理的请求数目。</p><p>线程池为线程生命周期开销问题和资源不足问题提供了解决方案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。其好处是，因为在请求到达时线程已经存在，所以无意中也消除了线程创建所带来的延迟。这样，就可以立即为请求服务，使应用程序响应更快。而且，通过适当地调整线程池中的线程数目，也就是当请求的数目超过某个阈值时，就强制其它任何新到的请求一直等待，直到获得一个线程来处理为止，从而可以防止资源不足。</p><h1 id="2-使用线程池的风险"><a href="#2-使用线程池的风险" class="headerlink" title="2. 使用线程池的风险"></a>2. 使用线程池的风险</h1><p>虽然线程池是构建多线程应用程序的强大机制，但使用它并不是没有风险的。用线程池构建的应用程序容易遭受任何其它多线程应用程序容易遭受的所有并发风险，诸如同步错误和死锁，它还容易遭受特定于线程池的少数其它风险，诸如与池有关的死锁、资源不足和线程泄漏。</p><h2 id="2-1-死锁"><a href="#2-1-死锁" class="headerlink" title="2.1 死锁"></a>2.1 死锁</h2><p>任何多线程应用程序都有死锁风险。当一组进程或线程中的每一个都在等待一个只有该组中另一个进程才能引起的事件时，我们就说这组进程或线程 死锁了。死锁的最简单情形是：线程 A 持有对象 X 的独占锁，并且在等待对象 Y 的锁，而线程 B 持有对象 Y 的独占锁，却在等待对象 X 的锁。除非有某种方法来打破对锁的等待（Java 锁定不支持这种方法），否则死锁的线程将永远等下去。</p><p>虽然任何多线程程序中都有死锁的风险，但线程池却引入了另一种死锁可能，在那种情况下，所有池线程都在执行已阻塞的等待队列中另一任务的执行结果的任务，但这一任务却因为没有未被占用的线程而不能运行。当线程池被用来实现涉及许多交互对象的模拟，被模拟的对象可以相互发送查询，这些查询接下来作为排队的任务执行，查询对象又同步等待着响应时，会发生这种情况。</p><h2 id="2-2-资源不足"><a href="#2-2-资源不足" class="headerlink" title="2.2 资源不足"></a>2.2 资源不足</h2><p>线程池的一个优点在于：相对于其它替代调度机制（有些我们已经讨论过）而言，它们通常执行得很好。但只有恰当地调整了线程池大小时才是这样的。线程消耗包括内存和其它系统资源在内的大量资源。除了 Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。最后，虽然线程之间切换的调度开销很小，但如果有很多线程，环境切换也可能严重地影响程序的性能。</p><p>如果线程池太大，那么被那些线程消耗的资源可能严重地影响系统性能。在线程之间进行切换将会浪费时间，而且使用超出比您实际需要的线程可能会引起资源匮乏问题，因为池线程正在消耗一些资源，而这些资源可能会被其它任务更有效地利用。除了线程自身所使用的资源以外，服务请求时所做的工作可能需要其它资源，例如 JDBC 连接、套接字或文件。这些也都是有限资源，有太多的并发请求也可能引起失效，例如不能分配 JDBC 连接。</p><h2 id="2-3-并发错误"><a href="#2-3-并发错误" class="headerlink" title="2.3 并发错误"></a>2.3 并发错误</h2><p>线程池和其它排队机制依靠使用 wait() 和 notify() 方法，这两个方法都难于使用。如果编码不正确，那么可能丢失通知，导致线程保持空闲状态，尽管队列中有工作要处理。使用这些方法时，必须格外小心。而最好使用现有的、已经知道能工作的实现，例如 util.concurrent 包。</p><h2 id="2-4-线程泄漏"><a href="#2-4-线程泄漏" class="headerlink" title="2.4 线程泄漏"></a>2.4 线程泄漏</h2><p>各种类型的线程池中一个严重的风险是线程泄漏，当从池中除去一个线程以执行一项任务，而在任务完成后该线程却没有返回池时，会发生这种情况。发生线程泄漏的一种情形出现在任务抛出一个 RuntimeException 或一个 Error 时。如果池类没有捕捉到它们，那么线程只会退出而线程池的大小将会永久减少一个。当这种情况发生的次数足够多时，线程池最终就为空，而且系统将停止，因为没有可用的线程来处理任务。</p><p>有些任务可能会永远等待某些资源或来自用户的输入，而这些资源又不能保证变得可用，用户可能也已经回家了，诸如此类的任务会永久停止，而这些停止的任务也会引起和线程泄漏同样的问题。如果某个线程被这样一个任务永久地消耗着，那么它实际上就被从池除去了。对于这样的任务，应该要么只给予它们自己的线程，要么只让它们等待有限的时间。</p><h2 id="2-5-请求过载"><a href="#2-5-请求过载" class="headerlink" title="2.5 请求过载"></a>2.5 请求过载</h2><p>仅仅是请求就压垮了服务器，这种情况是可能的。在这种情形下，我们可能不想将每个到来的请求都排队到我们的工作队列，因为排在队列中等待执行的任务可能会消耗太多的系统资源并引起资源缺乏。在这种情形下决定如何做取决于您自己；在某些情况下，您可以简单地抛弃请求，依靠更高级别的协议稍后重试请求，您也可以用一个指出服务器暂时很忙的响应来拒绝请求。</p><h2 id="3-有效使用线程池的准则"><a href="#3-有效使用线程池的准则" class="headerlink" title="3. 有效使用线程池的准则"></a>3. 有效使用线程池的准则</h2><p>只要您遵循几条简单的准则，线程池可以成为构建服务器应用程序的极其有效的方法：</p><p>不要对那些同步等待其它任务结果的任务排队。这可能会导致上面所描述的那种形式的死锁，在那种死锁中，所有线程都被一些任务所占用，这些任务依次等待排队任务的结果，而这些任务又无法执行，因为所有的线程都很忙。</p><p>在为时间可能很长的操作使用合用的线程时要小心。如果程序必须等待诸如 I/O 完成这样的某个资源，那么请指定最长的等待时间，以及随后是失效还是将任务重新排队以便稍后执行。这样做保证了：通过将某个线程释放给某个可能成功完成的任务，从而将最终取得某些进展。</p><p>理解任务。要有效地调整线程池大小，您需要理解正在排队的任务以及它们正在做什么。它们是 CPU 限制的（CPU-bound）吗？它们是 I/O 限制的（I/O-bound）吗？您的答案将影响您如何调整应用程序。如果您有不同的任务类，这些类有着截然不同的特征，那么为不同任务类设置多个工作队列可能会有意义，这样可以相应地调整每个池。</p><h1 id="4-线程池的大小设置"><a href="#4-线程池的大小设置" class="headerlink" title="4. 线程池的大小设置"></a>4. 线程池的大小设置</h1><p>调整线程池的大小基本上就是避免两类错误：线程太少或线程太多。幸运的是，对于大多数应用程序来说，太多和太少之间的余地相当宽。</p><p>请回忆：在应用程序中使用线程有两个主要优点，尽管在等待诸如 I/O 的慢操作，但允许继续进行处理，并且可以利用多处理器。在运行于具有 N 个处理器机器上的计算限制的应用程序中，在线程数目接近 N 时添加额外的线程可能会改善总处理能力，而在线程数目超过 N 时添加额外的线程将不起作用。事实上，太多的线程甚至会降低性能，因为它会导致额外的环境切换开销。</p><p>线程池的最佳大小取决于可用处理器的数目以及工作队列中的任务的性质。若在一个具有 N 个处理器的系统上只有一个工作队列，其中全部是计算性质的任务，在线程池具有 N 或 N+1 个线程时一般会获得最大的 CPU 利用率。</p><p>对于那些可能需要等待 I/O 完成的任务（例如，从套接字读取 HTTP 请求的任务），需要让池的大小超过可用处理器的数目，因为并不是所有线程都一直在工作。通过使用概要分析，您可以估计某个典型请求的等待时间（WT）与服务时间（ST）之间的比例。如果我们将这一比例称之为 WT/ST，那么对于一个具有 N 个处理器的系统，需要设置大约 N*(1+WT/ST) 个线程来保持处理器得到充分利用。</p><p>处理器利用率不是调整线程池大小过程中的唯一考虑事项。随着线程池的增长，您可能会碰到调度程序、可用内存方面的限制，或者其它系统资源方面的限制，例如套接字、打开的文件句柄或数据库连接等的数目。</p><h1 id="5-常用的几种线程池"><a href="#5-常用的几种线程池" class="headerlink" title="5. 常用的几种线程池"></a>5. 常用的几种线程池</h1><h2 id="5-1-newCachedThreadPool"><a href="#5-1-newCachedThreadPool" class="headerlink" title="5.1 newCachedThreadPool"></a>5.1 newCachedThreadPool</h2><p>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>这种类型的线程池特点是：</p><ul><li>工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。</li><li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li><li>在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li></ul><p>示例代码如下：</p><pre><code>package test;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolExecutorTest { public static void main(String[] args) {  ExecutorService cachedThreadPool = Executors.newCachedThreadPool();  for (int i = 0; i &lt; 10; i++) {   final int index = i;   try {    Thread.sleep(index * 1000);   } catch (InterruptedException e) {    e.printStackTrace();   }   cachedThreadPool.execute(new Runnable() {    public void run() {     System.out.println(index);    }   });  } }}</code></pre><h2 id="5-2-newFixedThreadPool"><a href="#5-2-newFixedThreadPool" class="headerlink" title="5.2 newFixedThreadPool"></a>5.2 newFixedThreadPool</h2><p>创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。</p><p>FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p><p>示例代码如下：</p><pre><code>package test;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolExecutorTest { public static void main(String[] args) {  ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3);  for (int i = 0; i &lt; 10; i++) {   final int index = i;   fixedThreadPool.execute(new Runnable() {    public void run() {     try {      System.out.println(index);      Thread.sleep(2000);     } catch (InterruptedException e) {      e.printStackTrace();     }    }   });  } }}</code></pre><p>因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。</p><p>定长线程池的大小最好根据系统资源进行设置如Runtime.getRuntime().availableProcessors()。</p><h2 id="5-3-newSingleThreadExecutor"><a href="#5-3-newSingleThreadExecutor" class="headerlink" title="5.3 newSingleThreadExecutor"></a>5.3 newSingleThreadExecutor</h2><p>创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。</p><p>示例代码如下：</p><pre><code>package test;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ThreadPoolExecutorTest { public static void main(String[] args) {  ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();  for (int i = 0; i &lt; 10; i++) {   final int index = i;   singleThreadExecutor.execute(new Runnable() {    public void run() {     try {      System.out.println(index);      Thread.sleep(2000);     } catch (InterruptedException e) {      e.printStackTrace();     }    }   });  } }}</code></pre><h2 id="5-4-newScheduleThreadPool"><a href="#5-4-newScheduleThreadPool" class="headerlink" title="5.4 newScheduleThreadPool"></a>5.4 newScheduleThreadPool</h2><p>创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。</p><p>延迟3秒执行，延迟执行示例代码如下：</p><pre><code>package test;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class ThreadPoolExecutorTest { public static void main(String[] args) {  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);  scheduledThreadPool.schedule(new Runnable() {   public void run() {    System.out.println(&quot;delay 3 seconds&quot;);   }  }, 3, TimeUnit.SECONDS); }}</code></pre><p>表示延迟1秒后每3秒执行一次，定期执行示例代码如下：</p><pre><code>package test;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class ThreadPoolExecutorTest { public static void main(String[] args) {  ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5);  scheduledThreadPool.scheduleAtFixedRate(new Runnable() {   public void run() {    System.out.println(&quot;delay 1 seconds, and excute every 3 seconds&quot;);   }  }, 1, 3, TimeUnit.SECONDS); }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://www.cnblogs.com/aaron911/p/6213808.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/aaron911/p/6213808.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程池" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>java基本数据类型对应的mysql字段类型</title>
    <link href="https://mlone.top/post/8dcfa579.html"/>
    <id>https://mlone.top/post/8dcfa579.html</id>
    <published>2018-10-25T06:28:02.000Z</published>
    <updated>2019-02-27T10:07:25.402Z</updated>
    
    <content type="html"><![CDATA[<p><strong>8中基本数据类型：</strong></p><a id="more"></a><p><em>boolean</em> –&gt; BIT</p><p><em>char</em></p><p><em>byte</em></p><p><em>short</em></p><p><em>（int）Integer (lang包)</em>–&gt; TINYINT（BOOLEAN）、SMALLINT、MEDIUMINT </p><p><em>BigInteger(math包)</em> –&gt; BIGINT</p><p><em>Long</em> –&gt; INTEGER、ID</p><p><em>Float</em> –&gt; FLOAT</p><p><em>Double</em> –&gt; DOUBLE </p><p><strong>3种引用数据类型：</strong></p><p><em>String</em> –&gt; VARCHAR、CHAR、TEXT</p><p><em>数组byte[]</em> –&gt; BLOB</p><p>对象（sql包）:</p><p><em>Date</em> –&gt; DATE、YEAR</p><p><em>Time</em> –&gt; TIME</p><p><em>Timestamp</em> –&gt; DATETIME、TIMESTAMP</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;8中基本数据类型：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://mlone.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mysql" scheme="https://mlone.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>五种作业调度算法</title>
    <link href="https://mlone.top/post/713996e4.html"/>
    <id>https://mlone.top/post/713996e4.html</id>
    <published>2018-10-25T02:28:02.000Z</published>
    <updated>2019-02-27T10:07:25.407Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p>（1）先来先服务</p><p>（2）短作业优先</p><p>（3）最短剩余时间优先</p><p>（4）最高响应比优先  响应比R=作业周转时间/作业处理时间（周转时间：等待+处理）</p><p>（5）优先级调度算法（设定优先级有两种方式：用户自己设定和系统设定）</p><p>（6）均衡调度算法（分类排队算法）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://mlone.top/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://mlone.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="算法" scheme="https://mlone.top/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="作业调度" scheme="https://mlone.top/tags/%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>如何手动停止一个线程</title>
    <link href="https://mlone.top/post/b82cf365.html"/>
    <id>https://mlone.top/post/b82cf365.html</id>
    <published>2018-10-24T07:28:02.000Z</published>
    <updated>2019-02-27T08:39:18.357Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/luckygxf/p/4737655.html" target="_blank" rel="noopener">https://www.cnblogs.com/luckygxf/p/4737655.html</a></p><a id="more"></a><p>在Java的多线程编程中，java.lang.Thread类型包含了一些列的方法start(), stop(), stop(Throwable) and suspend(), destroy() and resume()。通过这些方法，我们可以对线程进行方便的操作，但是这些方法中，<strong>只有start()方法得到了保留。</strong></p><p><strong>方式1. </strong>设置一个成员变量作为共享变量，相当于标志，在run()方法中不断检查标志，判断是否退出线程（跳出函数）：</p><p>（只能中断处于运行状态的进程）</p><pre><code>public class ThreadFlag extends Thread {     public volatile boolean exit = false;     public void run()     {         while (!exit);     }     public static void main(String[] args) throws Exception     {         ThreadFlag thread = new ThreadFlag();         thread.start();         sleep(3000); // 主线程延迟3秒         thread.exit = true; // 将中断标志值为true         thread.join(); // 在主线程中等待thread线程执行完毕        System.out.println(&quot;线程退出!&quot;);     } } </code></pre><p>在上面代码中定义了一个退出标志exit，当exit为true时，while循环退出，exit的默认值为false。在定义exit时，<strong>使用了一个Java关键字volatile，这个关键字的目的是使exit同步，也就是说在同一时刻只能由一个线程来修改exit的值。</strong></p><p><strong>方式2. </strong> 使用Thread.interrupt()方法终止线程</p><p>（只能中断处于阻塞状态的进程）</p><p><em>如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？</em></p><p>这种情况经常会发生，比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，<strong>都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。</strong></p><p>这里我们给出的建议是，不要使用stop()方法，而是<strong>使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。</strong></p><p><strong>注意：</strong>interrupted与isInterrupted</p><p>在Thread类中有两个方法可以判断线程是否通过interrupt方法被终止：</p><ol><li>静态的interrupted用来判断当前线程是否被中断；</li><li>非静态的isInterrupted可以用来判断其他线程是否被中断。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/luckygxf/p/4737655.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/luckygxf/p/4737655.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="多线程" scheme="https://mlone.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java线程的6中状态</title>
    <link href="https://mlone.top/post/42644e5a.html"/>
    <id>https://mlone.top/post/42644e5a.html</id>
    <published>2018-10-24T02:28:02.000Z</published>
    <updated>2019-02-27T08:39:18.353Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><ol><li><p><strong>初始(NEW)：</strong>新创建了一个线程对象，但还没有调用start()方法。</p></li><li><p><strong>运行(RUNNABLE)：</strong> 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）</p></li><li><p><strong>阻塞(BLOCKED)：</strong>表示线程阻塞于锁synchronized。</p></li><li><p><strong>等待(WAITING)：</strong>进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</p></li><li><p><strong>超时等待(TIMED_WAITING)：</strong>该状态不同于WAITING，它可以在指定的时间后自行返回。</p></li><li><p><strong>终止(TERMINATED)：</strong>表示该线程已经执行完毕。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="多线程" scheme="https://mlone.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>线程间的通信方式</title>
    <link href="https://mlone.top/post/a84acd9a.html"/>
    <id>https://mlone.top/post/a84acd9a.html</id>
    <published>2018-10-23T07:28:02.000Z</published>
    <updated>2019-02-27T08:16:52.761Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://www.cnblogs.com/hapjin/p/5492619.html" target="_blank" rel="noopener">JAVA多线程之线程间的通信方式</a></p><a id="more"></a><h4 id="一，介绍"><a href="#一，介绍" class="headerlink" title="一，介绍"></a>一，介绍</h4><p>本总结我对于JAVA多线程中线程之间的通信方式的理解，主要以代码结合文字的方式来讨论线程间的通信，故摘抄了书中的一些示例代码。</p><h4 id="二，线程间的通信方式"><a href="#二，线程间的通信方式" class="headerlink" title="二，线程间的通信方式"></a>二，线程间的通信方式</h4><h5 id="①同步"><a href="#①同步" class="headerlink" title="①同步"></a>①同步</h5><p>这里讲的同步是指多个线程通过synchronized关键字这种方式来实现线程间的通信。</p><p>参考示例：</p><pre><code>public class MyObject {    synchronized public void methodA() {        //do something....    }    synchronized public void methodB() {        //do some other thing    }}public class ThreadA extends Thread {    private MyObject object;    //省略构造方法    @Override    public void run() {        super.run();        object.methodA();    }}public class ThreadB extends Thread {    private MyObject object;    //省略构造方法    @Override    public void run() {        super.run();        object.methodB();    }}public class Run {    public static void main(String[] args) {        MyObject object = new MyObject();        //线程A与线程B 持有的是同一个对象:object        ThreadA a = new ThreadA(object);        ThreadB b = new ThreadB(object);        a.start();        b.start();    }}</code></pre><p>由于线程A和线程B持有同一个MyObject类的对象object，尽管这两个线程需要调用不同的方法，但是它们是同步执行的，<strong>比如：线程B需要等待线程A执行完了methodA()方法之后，它才能执行methodB()方法。这样，线程A和线程B就实现了 通信。</strong></p><p><strong>这种方式，本质上就是“共享内存”式的通信。多个线程需要访问同一个共享变量，谁拿到了锁（获得了访问权限），谁就可以执行。</strong></p><h5 id="②while轮询的方式"><a href="#②while轮询的方式" class="headerlink" title="②while轮询的方式"></a>②while轮询的方式</h5><p>代码如下：</p><pre><code>import java.util.ArrayList;import java.util.List;public class MyList {    private List&lt;String&gt; list = new ArrayList&lt;String&gt;();    public void add() {        list.add(&quot;elements&quot;);    }    public int size() {        return list.size();    }}import mylist.MyList;public class ThreadA extends Thread {    private MyList list;    public ThreadA(MyList list) {        super();        this.list = list;    }    @Override    public void run() {        try {            for (int i = 0; i &lt; 10; i++) {                list.add();                System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素&quot;);                Thread.sleep(1000);            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}import mylist.MyList;public class ThreadB extends Thread {    private MyList list;    public ThreadB(MyList list) {        super();        this.list = list;    }    @Override    public void run() {        try {            while (true) {                if (list.size() == 5) {                    System.out.println(&quot;==5, 线程b准备退出了&quot;);                    throw new InterruptedException();                }            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}import mylist.MyList;import extthread.ThreadA;import extthread.ThreadB;public class Test {    public static void main(String[] args) {        MyList service = new MyList();        ThreadA a = new ThreadA(service);        a.setName(&quot;A&quot;);        a.start();        ThreadB b = new ThreadB(service);        b.setName(&quot;B&quot;);        b.start();    }}</code></pre><p>在这种方式下，线程A不断地改变条件，线程ThreadB不停地通过while语句检测这个条件(list.size()==5)是否成立 ，从而实现了线程间的通信。<strong>但是这种方式会浪费CPU资源。</strong>之所以说它浪费资源，是因为JVM调度器将CPU交给线程B执行时，它没做啥“有用”的工作，只是在不断地测试 某个条件是否成立。就类似于现实生活中，某个人一直看着手机屏幕是否有电话来了，而不是： 在干别的事情，当有电话来时，响铃通知TA电话来了。关于线程的轮询的影响，<a href="http://www.cnblogs.com/hapjin/p/5467984.html" target="_blank" rel="noopener">可参考：JAVA多线程之当一个线程在执行死循环时会影响另外一个线程吗？</a></p><p>这种方式还存在另外一个问题：</p><p>轮询的条件的可见性问题，关于内存可见性问题，可参考：<a href="http://www.cnblogs.com/hapjin/p/5492880.html" target="_blank" rel="noopener">JAVA多线程之volatile 与 synchronized 的比较</a>中的第一点<strong>“一，volatile关键字的可见性”</strong></p><p>线程都是先把变量读取到本地线程栈空间，然后再去再去修改的本地变量。因此，如果线程B每次都在取本地的 条件变量，那么尽管另外一个线程已经改变了轮询的条件，它也察觉不到，这样也会造成死循环。</p><h5 id="③wait-notify机制"><a href="#③wait-notify机制" class="headerlink" title="③wait/notify机制"></a>③wait/notify机制</h5><p>代码如下：</p><pre><code>import java.util.ArrayList;import java.util.List;public class MyList {    private static List&lt;String&gt; list = new ArrayList&lt;String&gt;();    public static void add() {        list.add(&quot;anyString&quot;);    }    public static int size() {        return list.size();    }}public class ThreadA extends Thread {    private Object lock;    public ThreadA(Object lock) {        super();        this.lock = lock;    }    @Override    public void run() {        try {            synchronized (lock) {                if (MyList.size() != 5) {                    System.out.println(&quot;wait begin &quot;                            + System.currentTimeMillis());                    lock.wait();                    System.out.println(&quot;wait end  &quot;                            + System.currentTimeMillis());                }            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}public class ThreadB extends Thread {    private Object lock;    public ThreadB(Object lock) {        super();        this.lock = lock;    }    @Override    public void run() {        try {            synchronized (lock) {                for (int i = 0; i &lt; 10; i++) {                    MyList.add();                    if (MyList.size() == 5) {                        lock.notify();                        System.out.println(&quot;已经发出了通知&quot;);                    }                    System.out.println(&quot;添加了&quot; + (i + 1) + &quot;个元素!&quot;);                    Thread.sleep(1000);                }            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}public class Run {    public static void main(String[] args) {        try {            Object lock = new Object();            ThreadA a = new ThreadA(lock);            a.start();            Thread.sleep(50);            ThreadB b = new ThreadB(lock);            b.start();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>线程A要等待某个条件满足时(list.size()==5)，才执行操作。线程B则向list中添加元素，改变list 的size。</p><p>A,B之间如何通信的呢？也就是说，线程A如何知道 list.size() 已经为5了呢？</p><p>这里用到了Object类的 wait() 和 notify() 方法。</p><p>当条件未满足时(list.size() !=5)，线程A调用wait() 放弃CPU，并进入阻塞状态。—不像②while轮询那样占用CPU</p><p>当条件满足时，线程B调用 notify()通知 线程A，所谓通知线程A，就是唤醒线程A，并让它进入可运行状态。</p><p>这种方式的一个好处就是CPU的利用率提高了。</p><p>但是也有一些缺点：比如，线程B先执行，一下子添加了5个元素并调用了notify()发送了通知，而此时线程A还执行；当线程A执行并调用wait()时，那它永远就不可能被唤醒了。因为，线程B已经发了通知了，以后不再发通知了。这说明：<strong>通知过早，会打乱程序的执行逻辑。</strong></p><h5 id="④管道通信"><a href="#④管道通信" class="headerlink" title="④管道通信"></a>④管道通信</h5><p>就是使用java.io.PipedInputStream 和 java.io.PipedOutputStream进行通信</p><p>具体就不介绍了。分布式系统中说的两种通信机制：共享内存机制和消息通信机制。感觉前面的①中的synchronized关键字和②中的while轮询 “属于” 共享内存机制，由于是轮询的条件使用了volatile关键字修饰时，这就表示它们通过判断这个“共享的条件变量“是否改变了，来实现进程间的交流。</p><p>而管道通信，更像消息传递机制，也就是说：通过管道，将一个线程中的消息发送给另一个。</p><p>关于wait/notify更多内容，可参考：<a href="http://www.cnblogs.com/hapjin/p/5492645.html" target="_blank" rel="noopener">JAVA多线程之wait/notify</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;http://www.cnblogs.com/hapjin/p/5492619.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JAVA多线程之线程间的通信方式&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="多线程" scheme="https://mlone.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>如何在两个线程间共享数据</title>
    <link href="https://mlone.top/post/9a246216.html"/>
    <id>https://mlone.top/post/9a246216.html</id>
    <published>2018-10-22T07:28:02.000Z</published>
    <updated>2019-02-27T08:07:15.087Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/hejingyuan6/article/details/47053409" target="_blank" rel="noopener">https://blog.csdn.net/hejingyuan6/article/details/47053409</a></p><a id="more"></a><p>你可以通过共享对象来实现这个目的，或者是使用像阻塞队列这样并发的数据结构。</p><p>1，如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据。</p><p>例如，卖票系统就可以这么做：</p><pre><code>class Ticket implements Runnable {    private int ticket = 10; //共享成员变量    public void run() {        while (ticket &gt; 0) {            ticket--;            System.out.println(&quot;当前票数为：&quot; + ticket);        }    }}public class SellTicket {    public static void main(String[] args) {        Ticket t = new Ticket(); //使用同一个Runnable实现对象        new Thread(t).start(); //在主线程中新建并开启两个线程        new Thread(t).start();    }}</code></pre><p>2，如果每个线程执行的代码不同，这时候需要用不同的Runnable对象。</p><p>例如，设计4个线程。其中两个线程每次对data增加1，另外两个线程对data每次减1，银行存取款。</p><p>有两种方法来解决此问题：</p><p>（其实这两个方法是差不多的，只是使用内部类写法更简洁）</p><p>2.1 将共享数据封装成另外一个对象，然后将这个对象逐一传递给各个Runnable对象，每个线程对共享数据的操作方法也分配到那个对象身上完成，这样容易实现针对数据进行各个操作的互斥和通信：</p><pre><code>class MyData{ //共享数据类    private int data; //共享数据    public MyData(int data){ this.data=data; }    public synchronized void increase(){ //加操作        data++;        System.out.println(Thread.currentThread().getName() + &quot;data:&quot; + data);    }    public synchronized void decrease(){ //减操作        data--;        System.out.println(Thread.currentThread().getName() + &quot;data:&quot; + data);    }}class Inc implements Runnable{ //线程1    private MyData obj;    public Inc(MyData obj){ //传入共享数据类对象        this.obj=obj;    }    public void run(){        this.obj.increase(); //调用加操作    }}class Dec implements Runnable{ //线程2    private MyData obj;    public Dec(MyData obj){ //传入共享数据类对象        this.obj=obj;    }    public void run(){        this.obj.decrease(); //调用减操作    }}public class Test{    public static void main(String[] args){        MyData t = new MyData (10);        for (int i = 0; i &lt; 2; i++){ //共开启2*2个线程            Thread inc=new Thread(new Inc(t));            Thread dec=new Thread(new Dec(t));            inc.start();            dec.start();        }    }}</code></pre><p>2.2 将Runnable对象作为一个类的内部类，共享数据作为这个类的成员变量，每个线程对共享数据的操作方法也封装在外部类，以便实现对数据的各个操作的同步和互斥，作为内部类的各个Runnable对象调用外部类的这些方法：</p><pre><code>class MyData{ //共享数据类    private int data; //共享数据    public MyData(int data){ this.data=data; }    public synchronized void increase(){ //加操作        data++;        System.out.println(Thread.currentThread().getName() + &quot;data:&quot; + data);    }    public synchronized void decrease(){ //减操作        data--;        System.out.println(Thread.currentThread().getName() + &quot;data:&quot; + data);    }}public class Test{    public static void main(String[] args){        final MyData t = new MyData (10); //final表示引用变量t不能指向其他对象实例        for (int i = 0; i &lt; 2; i++){             new Thread(new Runnable(){                public void run(){                       this.obj.increase(); //调用加操作                   }                }).start();            new Thread(new Runnable(){                public void run(){                       this.obj.decrease(); //调用减操作                   }                }).start();        }    }}</code></pre><p><strong>总结：</strong></p><p>其实多线程间的共享数据最主要的还是互斥，多个线程共享一个变量，针对变量的操作实现原子性即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/hejingyuan6/article/details/47053409&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/hejingyuan6/article/details/47053409&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="多线程" scheme="https://mlone.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式</title>
    <link href="https://mlone.top/post/9a246216.html"/>
    <id>https://mlone.top/post/9a246216.html</id>
    <published>2018-10-22T07:28:02.000Z</published>
    <updated>2019-02-27T07:53:09.140Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="http://www.cnblogs.com/luohanguo/p/7825656.html" target="_blank" rel="noopener">http://www.cnblogs.com/luohanguo/p/7825656.html</a><br><a id="more"></a></p><h4 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h4><p>观察者模式的定义：</p><p>　　在对象之间定义了一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会收到通知并自动更新。</p><p>大白话：</p><p>　　其实就是发布订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。</p><p>该模式包含四个角色：</p><ul><li>抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</li><li>抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</li><li>具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</li><li>具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。</li></ul><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><pre><code>/*** * 抽象被观察者接口 * 声明了添加、删除、通知观察者方法 * @author jstao */public interface Observerable {    public void registerObserver(Observer o); //添加一个用户    public void removeObserver(Observer o); //移除一个用户    public void notifyObserver(); //通知用户消息更新了--&gt;里面调用观察者接口的update()方法}</code></pre><p>.</p><pre><code>/*** * 抽象观察者接口 * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。 * @author jstao */public interface Observer {    public void update(String message);}</code></pre><p>.</p><pre><code>import java.util.ArrayList;import java.util.List;/** * 被观察者，也就是微信公众号服务 * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现 * @author jstao * */public class WechatServer implements Observerable {    //注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现类编程    private List&lt;Observer&gt; list; //用户列表    private String message; //发布的信息    public WechatServer() {        list = new ArrayList&lt;Observer&gt;();    }    @Override    public void registerObserver(Observer o) {        list.add(o);    }    @Override    public void removeObserver(Observer o) {        if(!list.isEmpty())            list.remove(o);    }    //遍历    @Override    public void notifyObserver() {        for(int i = 0; i &lt; list.size(); i++) {            Observer oserver = list.get(i);            oserver.update(message); //回调集合中每个用户的update()方法，传达更新消息        }    }    public void setInfomation(String s) { //设置更新消息        this.message = s;        System.out.println(&quot;微信服务更新消息： &quot; + s);        //消息更新，通知所有观察者        notifyObserver();    }}</code></pre><p>.</p><pre><code>/** * 观察者 * 实现了update方法 * @author jstao * */public class User implements Observer {    private String name;    private String message;    public User(String name) {        this.name = name;    }    @Override    public void update(String message) {        this.message = message;        read();    }    public void read() {        System.out.println(name + &quot; 收到推送消息： &quot; + message);    }}</code></pre><p>//测试：</p><pre><code>/** * 首先注册了三个用户，ZhangSan、LiSi、WangWu。公众号发布了一条消息&quot;PHP是世界上最好用的语言！&quot;，三个用户都收到了消息。    用户ZhangSan看到消息后颇为震惊，果断取消订阅，这时公众号又推送了一条消息，此时用户ZhangSan已经收不到消息，其他用户    还是正常能收到推送消息。 */public class Test {    public static void main(String[] args) {        WechatServer server = new WechatServer();        Observer userZhang = new User(&quot;ZhangSan&quot;);        Observer userLi = new User(&quot;LiSi&quot;);        Observer userWang = new User(&quot;WangWu&quot;);        server.registerObserver(userZhang);        server.registerObserver(userLi);        server.registerObserver(userWang);        server.setInfomation(&quot;PHP是世界上最好用的语言！&quot;);        System.out.println(&quot;----------------------------------------------&quot;);        server.removeObserver(userZhang);        server.setInfomation(&quot;JAVA是世界上最好用的语言！&quot;);    }}</code></pre><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>这个模式是松偶合的，改变主题或观察者中的一方，另一方不会受到影像。</p><p>JDK中也有自带的观察者模式，但是被观察者是一个类而不是接口，限制了它的复用能力。</p><p>在JavaBean和Swing中也可以看到观察者模式的影子。</p><p><strong>yangd个人理解：</strong></p><p>接口异步回调是两个对象之间互相调用，而观察者模式只有服务器调用用户的方法（被观察者调用观察者），是单向调用，所以二者是不一样的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;http://www.cnblogs.com/luohanguo/p/7825656.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/luohanguo/p/7825656.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://mlone.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://mlone.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>动态代理模式</title>
    <link href="https://mlone.top/post/aa7827a9.html"/>
    <id>https://mlone.top/post/aa7827a9.html</id>
    <published>2018-10-20T07:28:02.000Z</published>
    <updated>2019-02-27T07:49:50.450Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><pre><code>/** * 通过reflect反射实现 */import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;</code></pre><p>//接口</p><pre><code>public interface Waiter {    // 服务功能    public void service();}</code></pre><p>//接口实现类：女服务员</p><pre><code>public class Waitress implements Waiter {    @Override    public void service() {        System.out.println(&quot;女服务员正在服务...&quot;);    }}</code></pre><p>//服务员经理</p><pre><code>public class WaiterManager {    /**     * 通过经理拿到女服务员的功能代理对象Waiter proxy     */    public static Waiter getWaitressProxy(Waitress ress){        // Proxy代理类的静态实例化方法newProxyInstance        //参数：被代理对象的类的加载器、接口、InvocationHandler接口的实现类        Waiter proxy = (Waiter) Proxy.newProxyInstance(ress.getClass().getClassLoader(), ress.getClass().getInterfaces(), new MyWaitressHandler(ress));        return proxy; // 返回女服务员的代理对象    }}</code></pre><p>// InvocationHandler动态代理接口的实现类</p><pre><code>class MyWaitressHandler implements InvocationHandler{    private Waiter w;    MyWaitressHandler(Waiter w){ // 实参是Waitress ress        this.w = w;    }</code></pre><p>//重写InvocationHandler接口的invoke方法</p><pre><code>/** * 执行服务功能： * 在该方法里，经理不仅可以决定是否让服务员进行服务，还可以对服务功能进行完善。 * （服务前请微笑，服务后请鞠躬。） */@Overridepublic Object invoke(Object proxy, Method method, Object[] args)        throws Throwable {    // 服务前请微笑    System.out.println(&quot;微笑...&quot;);    // method是waiter中service()方法的对象    // 形参w.service() --&gt; 实参ress.service()    // 执行服务功能    method.invoke(w, args);    // 服务后请鞠躬    System.out.println(&quot;鞠躬...&quot;);    return null;}</code></pre><p>//测试</p><pre><code>    @Test    public void run2(){        Waitress ress = new Waitress();        Waiter proxy = WaiterManager.getWaitressProxy(ress);        proxy.service(); //微笑…女服务员正在服务…鞠躬…    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://mlone.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://mlone.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>静态工厂模式</title>
    <link href="https://mlone.top/post/f11bee84.html"/>
    <id>https://mlone.top/post/f11bee84.html</id>
    <published>2018-10-19T07:28:02.000Z</published>
    <updated>2019-02-27T07:49:50.454Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.cnblogs.com/xuxinstyle/p/9128865.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuxinstyle/p/9128865.html</a><br><a id="more"></a></p><p>//首先创建一个抽象类</p><pre><code>public abstract class INoodles {    /**     * 描述每种面条啥样的     */    public abstract void desc();}</code></pre><p>//该抽象类的3个实现子类</p><pre><code>public class LzNoodles extends INoodles {    @Override    public void desc() {        System.out.println(&quot;兰州拉面&quot;);    }}public class PaoNoodles extends INoodles {    @Override    public void desc() {        System.out.println(&quot;泡面&quot;);    }}public class GankouNoodles extends INoodles {    @Override    public void desc() {        System.out.println(&quot;干扣面&quot;);    }}</code></pre><p>//工厂类</p><pre><code>public class SimpleNoodlesFactory {    public static final int TYPE_LZ = 1; //兰州拉面    public static final int TYPE_PM = 2; //泡面    public static final int TYPE_GK = 3; //干扣面    //根据类型创建不同的对象实例    public static INoodles createNoodles(int type) {        switch (type) {            case TYPE_LZ:                return new LzNoodles();            case TYPE_PM:                return new PaoNoodles();            case TYPE_GK:                return new GankouNoodles();            default:                return new PaoNoodles(); //默认给一碗泡面        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/xuxinstyle/p/9128865.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/xuxinstyle/p/9128865.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://mlone.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://mlone.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式</title>
    <link href="https://mlone.top/post/a708a60d.html"/>
    <id>https://mlone.top/post/a708a60d.html</id>
    <published>2018-10-18T07:28:02.000Z</published>
    <updated>2019-02-27T07:49:50.452Z</updated>
    
    <content type="html"><![CDATA[<p>.<br><a id="more"></a></p><p><strong>基本思想：</strong></p><ul><li>增强类与被增强类实现(implements)相同的接口；</li><li>增强类中获取被增强类的引用。</li></ul><p>// 共同的接口：</p><pre><code>interface IPerson{    public void run();}</code></pre><p>// 被增强的类 </p><pre><code>class Person implements IPerson{     public void run(){        System.out.println(&quot;跑...&quot;);    }}</code></pre><p>// 增强的类</p><pre><code>class SuperPerson implements IPerson{    private IPerson p; // 用于接收Person对象    public SuperPerson(IPerson p){ // 传入一个Person对象        this.p = p;    }    public void run(){        p.run();        System.out.println(&quot;超人跑...&quot;);    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;.&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://mlone.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://mlone.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://mlone.top/post/f1601c3e.html"/>
    <id>https://mlone.top/post/f1601c3e.html</id>
    <published>2018-10-17T07:28:02.000Z</published>
    <updated>2019-02-27T07:49:50.451Z</updated>
    
    <content type="html"><![CDATA[<p>懒汉、饿汉<br><a id="more"></a></p><p>//懒汉式</p><pre><code>public class Apple {    private static Apple apple = null;    private Apple(){}    //synchronized使用来对方法进行线程同步的，即一定时间内只能有一个线程调用该方法    public static synchronized Apple getApple(){        if(apple == null) {            apple = new Apple(); //需要时再创建Apple实例，需要加synchronized，防止并发操作时多个线程同时创建多个实例        }        return apple;    }}</code></pre><p>//饿汉式</p><pre><code>public class Apple {    private static Apple apple = new Apple(); //提前创建Apple实例    private Apple(){}    public static Apple getApple(){ //不需要加synchronized，也能应对并发操作        return apple;    } }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;懒汉、饿汉&lt;br&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://mlone.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://mlone.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM启动参数设置</title>
    <link href="https://mlone.top/post/61cc7df2.html"/>
    <id>https://mlone.top/post/61cc7df2.html</id>
    <published>2018-10-15T14:30:16.000Z</published>
    <updated>2019-02-25T14:42:03.776Z</updated>
    
    <content type="html"><![CDATA[<p>参考1：<a href="https://blog.csdn.net/sivyer123/article/details/17139443" target="_blank" rel="noopener">JVM 堆内存设置原理</a></p><a id="more"></a><p>参考2：<a href="https://www.cnblogs.com/smyhvae/p/4736162.html" target="_blank" rel="noopener">Java虚拟机详解03—-常用JVM配置参数</a></p><h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><ul><li>-Xmx3550m：设置JVM<strong>最大堆内存</strong>为3550M。</li><li>-Xms3550m：设置JVM<strong>初始堆内存</strong>为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如&gt;2MB）时将会在很大程度上降低系统的性能。</li><li>-Xmn2g：设置<strong>年轻代</strong>大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。</li><li>-XX:NewSize=1024m：设置年轻代初始值为1024M。</li><li>-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。</li><li>-XX:PermSize=256m：设置<strong>持久代初始值</strong>为256M。</li><li>-XX:MaxPermSize=256m：设置<strong>持久代最大值</strong>为256M。</li><li>-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。</li><li>-XX:SurvivorRatio=4：设置<strong>年轻代中Eden区与Survivor区的比值</strong>。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。</li><li>-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</li></ul><h1 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a>疑问解答</h1><p>-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？<br>如下：</p><p>高优先级：-XX:NewSize/-XX:MaxNewSize </p><p>中优先级：-Xmn（默认等效  -Xmn=-XX:NewSize=-XX:MaxNewSize=?） </p><p>低优先级：-XX:NewRatio </p><p>推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境。-Xmn 配合 -Xms/-Xmx，即可将堆内存布局完成。</p><p>-Xmn参数是在JDK 1.4 开始支持。</p><h1 id="垃圾回收器选择"><a href="#垃圾回收器选择" class="headerlink" title="垃圾回收器选择"></a>垃圾回收器选择</h1><p>JVM给出了3种选择：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器。</p><p>默认情况下JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。</p><h2 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h2><ul><li>-XX:+UseSerialGC：设置串行收集器。</li></ul><h2 id="并行收集器（吞吐量优先）"><a href="#并行收集器（吞吐量优先）" class="headerlink" title="并行收集器（吞吐量优先）"></a>并行收集器（吞吐量优先）</h2><ul><li>-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。</li><li>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。</li></ul><h2 id="并发收集器（响应时间优先）"><a href="#并发收集器（响应时间优先）" class="headerlink" title="并发收集器（响应时间优先）"></a>并发收集器（响应时间优先）</h2><ul><li>-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。</li><li>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。</li><li>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。</li><li>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。</li><li>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。</li><li>-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。</li></ul><h2 id="其它垃圾回收参数"><a href="#其它垃圾回收参数" class="headerlink" title="其它垃圾回收参数"></a>其它垃圾回收参数</h2><ul><li>-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。</li><li>-XX:-DisableExplicitGC：不响应 System.gc() 代码。</li><li>-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。</li><li>-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。</li><li>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。</li></ul><h1 id="辅助信息参数设置"><a href="#辅助信息参数设置" class="headerlink" title="辅助信息参数设置"></a>辅助信息参数设置</h1><ul><li>-XX:-CITime：打印消耗在JIT编译的时间。</li><li>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。</li><li>-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。</li><li>-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。</li><li>-XX:OnError=”;”：出现致命ERROR后运行自定义命令。</li><li>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令。</li><li>-XX:-PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。</li><li>-XX:-PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。</li><li>-XX:-PrintCompilation：当一个方法被编译时打印相关信息。</li><li>-XX:-PrintGC：每次GC时打印相关信息。</li><li>-XX:-PrintGCDetails：每次GC时打印详细信息。</li><li>-XX:-PrintGCTimeStamps：打印每次GC的时间戳。</li><li>-XX:-TraceClassLoading：跟踪类的加载信息。</li><li>-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。</li><li>-XX:-TraceClassResolution：跟踪常量池。</li><li>-XX:-TraceClassUnloading：跟踪类的卸载信息。</li></ul><h1 id="关于参数名称等"><a href="#关于参数名称等" class="headerlink" title="关于参数名称等"></a>关于参数名称等</h1><ul><li><p>标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容；例如：</p><p>  – -client——设置JVM使用Client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试；在32位环境下直接运行Java程序默认启用该模式。</p><p>  – -server——设置JVM使Server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下默认启用该模式。</p></li><li><p>非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容；</p></li><li>非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用；</li></ul><h1 id="JVM服务参数调优实战"><a href="#JVM服务参数调优实战" class="headerlink" title="JVM服务参数调优实战"></a>JVM服务参数调优实战</h1><h2 id="大型网站服务器案例"><a href="#大型网站服务器案例" class="headerlink" title="大型网站服务器案例"></a>大型网站服务器案例</h2><p>承受海量访问的动态Web应用</p><p>服务器配置：8 CPU, 8G MEM, JDK 1.6.X</p><p>参数方案：</p><p>-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC</p><p>调优说明：</p><ul><li>-Xmx 与 -Xms 相同以避免JVM反复重新申请内存。-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。</li><li>-Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。</li><li>-Xss128k 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能。</li><li>-XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。</li><li>-XX:ParallelGCThreads=8 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。</li><li>-XX:MaxTenuringThreshold=0 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0。</li><li>-XX:+UseConcMarkSweepGC 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况。</li></ul><h2 id="内部集成构建服务器案例"><a href="#内部集成构建服务器案例" class="headerlink" title="内部集成构建服务器案例"></a>内部集成构建服务器案例</h2><p>高性能数据处理的工具应用<br>服务器配置：1 CPU, 4G MEM, JDK 1.6.X</p><p>参数方案：</p><p>-server -XX:PermSize=196m -XX:MaxPermSize=196m -Xmn320m -Xms768m -Xmx1024m</p><p>调优说明：</p><ul><li>-XX:PermSize=196m -XX:MaxPermSize=196m 根据集成构建的特点，大规模的系统编译可能需要加载大量的Java类到内存中，所以预先分配好大量的持久代内存是高效和必要的。</li><li>-Xmn320m 遵循年轻代大小为整个堆的3/8原则。</li><li>-Xms768m -Xmx1024m 根据系统大致能够承受的堆内存大小设置即可。</li></ul><p>在64位服务器上运行应用程序，构建执行时，用 jmap -heap 11540 命令观察JVM堆内存状况如下：</p><pre><code>Attaching to process ID 11540, please wait...Debugger attached successfully.Server compiler detected.JVM version is 20.12-b01using thread-local object allocation.Parallel GC with 4 thread(s)Heap Configuration:   MinHeapFreeRatio = 40   MaxHeapFreeRatio = 70   MaxHeapSize      = 1073741824 (1024.0MB)   NewSize          = 335544320 (320.0MB)   MaxNewSize       = 335544320 (320.0MB)   OldSize          = 5439488 (5.1875MB)   NewRatio         = 2   SurvivorRatio    = 8   PermSize         = 205520896 (196.0MB)   MaxPermSize      = 205520896 (196.0MB)Heap Usage:PS Young GenerationEden Space:   capacity = 255852544 (244.0MB)   used     = 101395504 (96.69828796386719MB)   free     = 154457040 (147.3017120361328MB)   39.63044588683081% usedFrom Space:   capacity = 34144256 (32.5625MB)   used     = 33993968 (32.41917419433594MB)   free     = 150288 (0.1433258056640625MB)   99.55984397492803% usedTo Space:   capacity = 39845888 (38.0MB)   used     = 0 (0.0MB)   free     = 39845888 (38.0MB)   0.0% usedPS Old Generation   capacity = 469762048 (448.0MB)   used     = 44347696 (42.29325866699219MB)   free     = 425414352 (405.7067413330078MB)   9.440459523882184% usedPS Perm Generation   capacity = 205520896 (196.0MB)   used     = 85169496 (81.22396087646484MB)   free     = 120351400 (114.77603912353516MB)   41.440796365543285% used</code></pre><p>结果是比较健康的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考1：&lt;a href=&quot;https://blog.csdn.net/sivyer123/article/details/17139443&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVM 堆内存设置原理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存设置原理</title>
    <link href="https://mlone.top/post/4cc01209.html"/>
    <id>https://mlone.top/post/4cc01209.html</id>
    <published>2018-10-15T14:30:16.000Z</published>
    <updated>2019-02-25T14:50:44.523Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/sivyer123/article/details/17139443" target="_blank" rel="noopener">https://blog.csdn.net/sivyer123/article/details/17139443</a></p><a id="more"></a><h1 id="堆内存设置"><a href="#堆内存设置" class="headerlink" title="堆内存设置"></a>堆内存设置</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>方法区：Permanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。</p><p>堆内存：Heap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。</p><p><img src="/assets/blogImg/4/19.png" alt="图片19"></p><h3 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a>持久代</h3><p>　　用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。</p><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>　　所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。</p><p>　　大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。</p><p>　　2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。<strong>而且，因为需要交换的原因，Survivor区至少有一个是空的。</strong>特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><p>　　针对年轻代的垃圾回收即 Young GC。</p><h3 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h3><p>　　在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p>　　针对年老代的垃圾回收即 Full GC。</p><p>所以，当一组对象生成时，<strong>内存申请过程</strong>如下：</p><p>　　<em>JVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。</em></p><p>　　<em>当Eden区空间足够时，内存申请结束。否则执行下一步。</em></p><p>　　<em>JVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。</em></p><p>　　<em>Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。</em></p><p>　　<em>当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。</em></p><p>　　<em>Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。</em></p><h3 id="OOM（“Out-of-Memory”）异常一般主要有如下2种原因："><a href="#OOM（“Out-of-Memory”）异常一般主要有如下2种原因：" class="headerlink" title="OOM（“Out of Memory”）异常一般主要有如下2种原因："></a>OOM（“Out of Memory”）异常一般主要有如下2种原因：</h3><ol><li>持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace</li></ol><p>　　通常由于持久代设置过小，动态加载了大量Java类而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。</p><ol start="2"><li>年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace</li></ol><p>　　这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。</p><p>　　例如循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/sivyer123/article/details/17139443&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/sivyer123/article/details/17139443&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>运行时数据区概括</title>
    <link href="https://mlone.top/post/3447574e.html"/>
    <id>https://mlone.top/post/3447574e.html</id>
    <published>2018-10-14T14:30:16.000Z</published>
    <updated>2019-02-25T14:42:03.789Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><a id="more"></a><p><a href="https://www.cnblogs.com/SaraMoring/p/5687466.html" target="_blank" rel="noopener">Java内存分配之堆、栈和常量池</a></p><p><a href="https://blog.csdn.net/aijiudu/article/details/72991993" target="_blank" rel="noopener">JVM架构和GC垃圾回收机制详解</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653193961&amp;idx=2&amp;sn=cdfa0d38829a0dc1ad5d23350e1aca90&amp;chksm=8c99f433bbee7d25f353b6156375a0d0d430080e1c7489f47499fa3f4051e0fa4449811cfddb&amp;mpshare=1&amp;scene=1&amp;srcid=0529n9lAnXTfdGBzFnANpp8I#rd" target="_blank" rel="noopener">聊下JVM内存模型</a></p><p>运行时数据区包括：本地方法栈，虚拟机栈区，程序计数器，方法区，堆区。</p><p><img src="/assets/blogImg/4/16.jpg" alt="图片16"></p><p><strong>本地方法栈(Native Method Stack)：</strong>用于保存<strong>本地方法信息</strong>。<em>对每一个线程，将创建一个单独的本地方法栈</em>。</p><p><em>Java 虚拟机实现可能会使用到传统的栈（通常称之为“ C Stacks”）来支持 native 方（ 指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（ Native MethodStack）。</em></p><p><strong>虚拟机栈 ：</strong>也就是我们常说的栈区，线程私有，存放<strong>基本类型的变量数据，对象的引用变量和返回地址</strong>，在编译期间完成分配。</p><p><em>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量数据（int, short, long, byte, float, double, boolean, char）和对象句柄(引用)。</em></p><p><strong>程序计数器（PC寄存器） ：</strong>线程私有，每个线程都有自己独立的寄存器来保存<strong>当前指令的地址，*</strong>一旦该指令被执行，寄存器变会被更新至下条指令的地址。 *</p><p><strong>方法区（持久代） ：</strong>所有线程共享，存储已被虚拟机加载的，在编译期被确定并保存在.class文件中的一些类级别的数据，如<strong>类信息，常量，静态变量，即编译器编译后的代码等数据</strong>。这个区域的内存回收目标主要是<em>针对常量池的对象的回收和对类型的卸载</em>。</p><p><strong>堆区（年轻代+老年代） ：</strong> JAVA 堆，也称 GC 堆，所有线程共享，存放new创建的对象实例和数组， JAVA 堆是垃圾收集器管理的主要区域。</p><p><em>堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，但这也导致了它的缺点：存取速度较慢。</em></p><p><strong>由于方法区和堆区的内存由多个线程共享，所以存储的数据不是线程安全的。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java运行时数据区</title>
    <link href="https://mlone.top/post/9806100a.html"/>
    <id>https://mlone.top/post/9806100a.html</id>
    <published>2018-10-14T13:30:16.000Z</published>
    <updated>2019-02-25T14:44:44.588Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自公众号：AskHarries</p><a id="more"></a><p><img src="/assets/blogImg/4/15.png" alt="图片15"></p><h2 id="1-JVM运行时数据区"><a href="#1-JVM运行时数据区" class="headerlink" title="1. JVM运行时数据区"></a>1. JVM运行时数据区</h2><p><img src="/assets/blogImg/4/16.jpg" alt="图片16"></p><h2 id="2-程序计数器-PC寄存器"><a href="#2-程序计数器-PC寄存器" class="headerlink" title="2. 程序计数器(PC寄存器)"></a>2. 程序计数器(PC寄存器)</h2><p>每个线程都会有自己私有的程序计数器(PC)。可以看作是当前线程所执行的字节码的行号指示器。</p><p>也可以理解为下一条将要执行的指令的地址或者行号。字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、 循环、 跳转、 异常处理、 线程上下文切换，线程恢复时，都要依赖PC.</p><ul><li>如果线程正在执行的是一个Java方法，PC值为正在执行的虚拟机字节码指令的地址</li><li>如果线程正在执行的是Native方法，PC值为空(未定义)</li></ul><h2 id="3-虚拟机栈-VM-Stack"><a href="#3-虚拟机栈-VM-Stack" class="headerlink" title="3.虚拟机栈(VM Stack)"></a>3.虚拟机栈(VM Stack)</h2><p>VM Stack也是线程私有的区域。他是java方法执行时的字典：它里面记录了局部变量表、 操作数栈、 动态链接、 方法出口等信息。</p><p><strong>在《java虚拟机规范》一书中对这部分的描述如下：</strong></p><p><em>栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 (Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。<br>栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。<br>栈帧的存储空间分配在 Java 虚拟机栈（ §2.5.5）之中，每一个栈帧都有自己的局部变量表（ Local Variables， §2.6.1）、操作数栈（ OperandStack， §2.6.2）和指向当前方法所属的类的运行时常量池（ §2.5.5）的引用。</em></p><h2 id="4-本地方法栈-Native-Method-Stack"><a href="#4-本地方法栈-Native-Method-Stack" class="headerlink" title="4. 本地方法栈(Native Method Stack)"></a>4. 本地方法栈(Native Method Stack)</h2><p><em>Java 虚拟机实现可能会使用到传统的栈（通常称之为“ C Stacks”）来支持 native 方法（ 指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（ Native MethodStack）。</em></p><p>VM Stack是为执行java方法服务的，此处的Native Method Stack是为执行本地方法服务的。<br>此处的本地方法指定是和具体的底层操作系统层面相关的接口调用了(这部分太高高级了，不想深究……)。</p><p>《java虚拟机规范》中没有对这部分做具体的规定。所以就由VM的实现者自由发挥了。</p><p>有的虚拟机(比如HotSpot)将VM Stack和Native Method Stack合二为一，所以VM的另一种内存区域图就如下面所示了：</p><p><img src="/assets/blogImg/4/17.jpg" alt="图片17"></p><h2 id="5-Java堆-Heap"><a href="#5-Java堆-Heap" class="headerlink" title="5.Java堆(Heap)"></a>5.Java堆(Heap)</h2><p><em>在 Java 虚拟机中，堆（ Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。</em></p><p>以下是本人对《java虚拟机规范》一书中对Java堆的介绍的总结:</p><ul><li>在虚拟机启动的时候就被创建</li><li>是所有线程共享的内存区域</li><li><p>存储了被自动内存管理系统所管理的各种对象</p><pre><code>---- 这些受管理的对象无需，也无法显式地被销毁---- 自动内存管理系统:Automatic StorageManagement System，也即是常说的”Garbage Collector(垃圾收集器)”---- 并未指明用什么具体的技术去实现自动内存管理系统</code></pre></li><li>Java 堆的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩</li><li>Java 堆所使用的内存不需要保证是连续的</li><li>如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那 Java 虚拟机将会抛出一个OutOfMemoryError 异常</li><li><p>实现者应当提供给程序员或者最终用户调节 Java 堆初始容量的手段</p><pre><code>---- 对于可以动态扩展和收缩 Java 堆来说，则应当提供调节其最大、最小容量的手段</code></pre></li><li><p>所有的对象实例以及数组都要在堆上分配</p></li></ul><p><img src="/assets/blogImg/4/18.jpg" alt="图片18"></p><h2 id="6-方法区-Method-Area"><a href="#6-方法区-Method-Area" class="headerlink" title="6.方法区(Method Area)"></a>6.方法区(Method Area)</h2><p>方法区是由所有线程共享的内存区域。</p><p>方法区存储的大致内容如下:</p><ul><li><p>每一个类的结构信息</p><pre><code>---- 运行时常量池（ Runtime Constant Pool）---- 字段和方法数据---- 构造函数和普通方法的字节码内容</code></pre></li><li><p>类、实例、接口初始化时用到的特殊方法</p></li></ul><p>每一个运行时常量池都分配在 Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。</p><ul><li>当创建类或接口的时候，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li></ul><h2 id="7-直接内存-Direct-Memory"><a href="#7-直接内存-Direct-Memory" class="headerlink" title="7.直接内存(Direct Memory)"></a>7.直接内存(Direct Memory)</h2><p>此处的直接内存并不是由JVM管理的内存。他是利用本地方法库直接在java堆之外申请的内存区域。</p><p>比如NIO中的DirectByteBuffer就是操作直接内存的。</p><p>直接内存的好处就是避免了在java堆和native堆直接同步数据的步骤。但是他并不是由JVM来管理的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自公众号：AskHarries&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://mlone.top/post/91e798bc.html"/>
    <id>https://mlone.top/post/91e798bc.html</id>
    <published>2018-10-12T13:30:16.000Z</published>
    <updated>2019-02-25T14:46:08.838Z</updated>
    
    <content type="html"><![CDATA[<p>来自：Hollis（微信号：hollischuang）</p><a id="more"></a><p>前几天，发了一篇文章，介绍了一下<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121579&amp;idx=1&amp;sn=373fb812e6ff056b2e5b41cc46968cc9&amp;chksm=f36bb84ac41c315cb7c3e9d7e99b68bee7b2ac2dc8a6ed7e4a5829c5f2434ffa08e9eb14d40f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">JVM内存结构、Java内存模型以及Java对象模型之间的区别</a>。</p><p>有很多小伙伴反馈希望可以深入的讲解下每个知识点。Java内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。</p><p>网上有很多关于Java内存模型的文章，在《深入理解Java虚拟机》和《Java并发编程的艺术》等书中也都有关于这个知识点的介绍。但是，很多人读完之后还是搞不清楚，甚至有的人说自己更懵了。本文，就来整体的介绍一下Java内存模型，目的很简单，让你读完本文以后，就知道到底Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题等。</p><p>本文中，有很多定义和说法，都是笔者自己理解后定义出来的。希望能够让读者可以对Java内存模型有更加清晰的认识。当然，如有偏颇，欢迎指正。</p><h2 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h2><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p><p><strong>内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。</strong></p><h3 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h3><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p><p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p><p><em>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率</em>。</p><p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p><p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。</p><p>那么，程序的执行过程就变成了：</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><p><em>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</em></p><p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p><p>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。</p><p>这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p><p>那么，在有了多级缓存之后，程序的执行就变成了：</p><p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p><p><em>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</em></p><p>单核CPU只含有一套L1，L2，L3缓存；</p><p>如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p><p><em>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</em></p><p><em>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</em></p><p><em>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</em></p><p><em>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</em></p><p>下图为一个单CPU双核的缓存结构。</p><p><img src="/assets/blogImg/4/11.jpg" alt="图片11"></p><p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p><p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p><p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p><p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><p><em>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</em></p><p><em>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</em></p><p><em>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</em></p><p><em>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</em></p><p><img src="/assets/blogImg/4/12.jpg" alt="图片12"></p><h3 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h3><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在<strong>缓存一致性问题。</strong>除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>处理器优化。</strong></p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做<strong>指令重排。</strong></p><p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p><p><em>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</em></p><h2 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h2><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。</p><p>其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p><p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p><p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p><p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p><p>有没有发现，<strong>缓存一致性问题</strong>其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的。<strong>指令重排</strong>即会导致<strong>有序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><h2 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h2><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p><p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化</strong>和<strong>使用内存屏障。</strong>本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。</p><h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p><p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p><p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）</a></p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p><p><img src="/assets/blogImg/4/13.jpg" alt="图片13"></p><p>这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p><p><strong>所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</strong></p><h2 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h2><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，<strong>Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</strong></p><p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。</p><p><strong>原子性</strong></p><p>在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。在synchronized的实现原理文章中，介绍过，这两个字节码，在Java中对应的关键字就是synchronized。</p><p>因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。</p><p><strong>可见性</strong></p><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p><p>Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p><p>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><p><strong>有序性</strong></p><p>在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：</p><p>volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。</p><p>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。</p><p>但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在读完本文之后，相信你应该了解了什么是Java内存模型、Java内存模型的作用以及Java中内存模型做了什么事情等。</p><p>关于Java中这些和内存模型有关的关键字，希望读者还可以继续深入学习，并且自己写几个例子亲自体会一下。可以参考《深入理解Java虚拟机》和《Java并发编程的艺术》两本书。</p><p><img src="/assets/blogImg/4/14.png" alt="图片14"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自：Hollis（微信号：hollischuang）&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Array and Collection Framework</title>
    <link href="https://mlone.top/post/5495d47.html"/>
    <id>https://mlone.top/post/5495d47.html</id>
    <published>2018-10-03T10:21:32.000Z</published>
    <updated>2019-02-23T10:39:56.794Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/ada_dengpan/article/details/51200907" target="_blank" rel="noopener">https://blog.csdn.net/ada_dengpan/article/details/51200907</a></p><a id="more"></a><h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><pre><code>* （1）Array数组** 和C/C++以及其他语言一样，Java中的数组有差不多一样的语法* 只是Java中除了8种基本类型，数组也是作为对象处理的，所以创建对象时也需要使用new关键字* 和大多数编程语言一样，数组一旦创建，大小便不可改变* Java中有一个Arrays封装类，专门用来操作基本数组* Arrays中拥有一组static函数：*     --equals():比较两个array是否相等。array拥有相同元素个数，且所有对应元素两两相等*     --fill():将指定的数据类型填入array数组中*     --sort():用来对array数组进行排序*     --binarySearch():在排好的array数组中寻找元素*     --System.arraycopy():array数组的复制** int [] intArr = new int[10];*</code></pre><h3 id="Collection集合框架"><a href="#Collection集合框架" class="headerlink" title="Collection集合框架"></a>Collection集合框架</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>* （2）Array是Java中随机访问一连串对象最有效率的数据结构，但很不灵活，大小固定，且不知道里面有多少元素* 为此JDK（）已经为我们提供了一系列的类来实现功能强大且更灵活的基本数据结构，这些类均在java.util包中。* 其继承结构如下：* --Collection（集合）**   --List（列表）*         --LinkedList（链表：链式存储）*         --ArrayList（线性表：顺序存储）*         --Vector（矢量）（已淘汰）*              --Stack（栈）**   --Set（集合）*         --HashSet*              --LinkedHashSet**         --TreeSet（实现了SortedSet接口）*   **   --Queue（队列）**   --Map（图）*         --HashTable（哈希表：散列表）（已淘汰）*         --HashMap（哈希图；散列表）*              --LinkedHashMap*         --TreeMap*         --WeakHashMap*         </code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>* （2.1）List**              List是一个接口，不能实例化，若要实例化要通过创建ArrayList或LinkedList** （2.1.1）ArrayList里面的内部类实现，是通过一定的增长规则动态复制增加数组长度来实现动态增加元素的，*              如果在大量数据的情况下，在某一位置随机插入或删除元素，就会产生性能问题。** （2.1.2）LinkedList可以解决这类问题，但LinkedList在通过下标取元素的时候，一定要遍历整个链表节点匹配，*              在数据量大的情况下，效率不高。** （2.1.3）Vector是一种过时的动态数组，是线程同步的，效率很低，一般不赞成使用：**              Stack是Java实现了一个堆栈，先进后出（FILO）结构。**</code></pre><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><pre><code>** （2.2）Set*              Set接口继承Collection接口，最大的特点是集合中的元素都是唯一的，没有重复元素。*              它有两个类：HashSet和TreeSet**              （2.2.1）--HashSet*                    --不允许出现重复元素；*                    --不保证集合中元素的顺序都是哈希算法来的~*                    --允许包含值为null的元素，但最多只能有一个null元素。**              （2.2.2）--TreeSet*                    --不允许出现重复元素；*                    --集合中元素的顺序按某种规则进行排序；*                    --不允许包含值为null的元素**              （2.2.3）遍历时删除问题*              1、//使用迭代器遍历Set集合.*               Iterator&lt;String&gt; it  = set.iterator();*               while(it.hasNext()){*               String temp = it.next();*               System.out.println(&quot;元素：&quot;+ temp);*                it.remove();*                }*               2、//使用增强for循环解决 （底层实现还是迭代器）*                for(String item : set){*                System.out.println(&quot;元素：&quot;+ item);*                }*                *              使用增强for循环遍历List（所有实现子类ArrayList，Stack等）元素对其中元素进行删除，*              会抛出java.util.ConcurrentModificationException的异常�??*              若使用下面这种方式：*              for(int i= 0; i &lt; list.size(); i++){*                    list.remove(i);*              }*              则会删除下标为偶数的元素，因为每次删除后，后面的元素的下标全部减1,相当于元素位置全部左移一位，*              再次删除时，会跳过一个元素进行删除，这是非常不好的。*              如果非要这样删除，可以倒着来：*              for(int i = list.size()-1; i &gt;= 0; i--){*                         list.remove(i);*              }*              或者新建一个要删除的List，最后一起删除list.removeAll(deleteList);**</code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><pre><code>** （2.3）Map*         Map接口，没有继承Collection接口，它是一个独立的接口。使用key-value的键值对存储数据，*               常用的两个子类是HashMap和TreeMap。**         （2.3.1）--HashMap：Map基于散列表的实现。插入和查询“键值对”的位置是固定的，*                         可以通过构造器设置容量capacity和负载因子loadfactor，以调整容器的装载能力。**         （2.3.2）--LinkedHashMap：类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序*                         或者是最近最少使用（LRU）的次序。只比HashMap慢一点，*                         而在迭代访问时反而更快，因为它使用链表维护内部次序。**         （2.3.3）--TreeMap：基于红黑树数据结构的实现的，查看“键”或“键值对”时，它们会被排序（次序由Comparabel或Comparator决定）*                         TreeMap的特点在于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。**         （2.3.4）--WeakHashMap：弱键（weak key）Map，Map中使用的对象也被允许释放：这是为解决特殊问题设计的。*                         如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。**         （2.3.5）--IdentifyHashMap:使用==代替equals()对“键”作比较 hash map。专为解决特殊问题而设计的。*</code></pre><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><pre><code>* （3）线程安全**        Vector是线程同步的，也就是线程安全的，对多线程的操作采用了synchronized处理。但因为效率低已不建议使用，*        而ArrayList和LinkedList虽然是线程异步的、效率高，但都是线程不安全的，在多线程环境中，对数据的修改会造成错误的结果。** 有两种解决方案：*       （3.1）使用同步包装器**         List safedList = Collections.synchronizedList(new ArrayList());*         Set safedSet = Collections.synchronizedSet(new HashSet);*         Map safedMap = Collections.synchronizedSet(new HashSet);**         查看其源码，发现是Collections类给不安全的集合类包装了一层（即虚拟机自动给集合实现加锁接口），然后生成一个新的类*   新类里面采用了synchronized对集合的操作进行了同步处理*          public int size(){                     synchronized(mutex){return c.size();}            }            public boolean isEmpty(){                    synchronized(mutex){return c.isEmpty();}            }            public boolean contains(Object o){                     synchronized(mutex){return c.contains(o);}            }            public Object[] toArray(){                    synchronized(mutex){return c.toArray();}           }            public &lt;T&gt; T[] toArray(T[] a){                     synchronized(mutex){return c.toArray(a);}            }           public Iterator&lt;E&gt; iterator(){                     return c.iterator(); //Must be manually synched by uers!                                          //必须由用户手动同步            }           public boolean add(E e){                     synchronized(mutex){return c.add(e);}            }           public boolean remove(Object o){                     synchronized(mutex){return c.remove(o);}            }           public boolean containsAll(Collection&lt;?&gt; coll){                     synchronized(mutex){return c.containsAll(coll);}            }           public boolean addAll(Collection&lt;? extends E&gt; coll){                     synchronized(mutex){return c.addAll(coll);}            }           public boolean removeAll(Collection&lt;?&gt; coll){                     synchronized(mutex){return c.removeAll(coll);}            }           public boolean retainAll(Collection&lt;?&gt; coll){                     synchronized(mutex){return c.retainAll(coll);}            }           public void clear(){                     synchronized(mutex){c.clear();}            } *                     * * * *  （3.2）使用安全的集合： *         Java5.0新加入的ConcurrentLinkedQueue、ConcurrentHashMap *         CopyOnWriteArrayList和CopyOnWriteArraySet,这些集合类都是线程安全的。 *         都在java.util.concurrent包下。而至于这些新的类为什么能保证线程安全，这里不作详述。 *                     *     PS:concurrent *        adj.〈正式的;同时发生的;同时完成的;同时存在的。 *        n.[数] 共点;同时发生的事情 */</code></pre>]]></content>
    
    <summary type="html">
    
      java数组和集合框架
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://mlone.top/tags/Java/"/>
    
      <category term="集合框架" scheme="https://mlone.top/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java RMI详解</title>
    <link href="https://mlone.top/post/d2873939.html"/>
    <id>https://mlone.top/post/d2873939.html</id>
    <published>2018-10-01T06:32:51.000Z</published>
    <updated>2019-02-23T12:56:12.450Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/a19881029/article/details/9465663" target="_blank" rel="noopener">https://blog.csdn.net/a19881029/article/details/9465663</a></p><a id="more"></a><p><strong>RMI:远程方法调用</strong>(Remote Method Invocation)：<em>能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法。</em></p><p><img src="/assets/blogImg/4/2.png" alt="图2"></p><p><strong>RMI远程调用步骤：</strong></p><p>1，客户对象调用客户端辅助对象上的方法</p><p>2，客户端辅助对象打包调用信息（变量，方法名），通过网络发送给服务端辅助对象</p><p>3，服务端辅助对象将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象</p><p>4，调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象</p><p>5，服务端辅助对象将结果打包，发送给客户端辅助对象</p><p>6，客户端辅助对象将返回值解包，返回给客户对象</p><p>7，客户对象获得返回值</p><p>对于客户对象来说，步骤2-6是完全透明的</p><p>搭建一个RMI服务的过程分为以下7步;</p><h4 id="1，创建远程方法接口，该接口必须继承自Remote接口"><a href="#1，创建远程方法接口，该接口必须继承自Remote接口" class="headerlink" title="1，创建远程方法接口，该接口必须继承自Remote接口"></a>1，创建远程方法接口，该接口必须继承自Remote接口</h4><p>Remote 接口是一个标识接口，用于标识所包含的方法可以从非本地虚拟机上调用的接口，Remote接口本身不包含任何方法</p><pre><code>package server;import java.rmi.Remote;import java.rmi.RemoteException;public interface Hello extends Remote {    public String sayHello(String name) throws RemoteException;}</code></pre><p>由于远程方法调用的本质依然是网络通信，只不过隐藏了底层实现，网络通信是经常会出现异常的，所以<strong>接口的所有方法都必须抛出RemoteException</strong>以说明该方法是有风险的</p><h4 id="2，创建远程方法接口实现类："><a href="#2，创建远程方法接口实现类：" class="headerlink" title="2，创建远程方法接口实现类："></a>2，创建远程方法接口实现类：</h4><p>UnicastRemoteObject类的构造函数抛出了RemoteException，故其继承类不能使用默认构造函数，<strong>继承类的构造函数必须也抛出RemoteException</strong></p><p>由于<strong>方法参数</strong>与<strong>返回值</strong>最终都将在网络上传输，故必须是<strong>可序列化的</strong></p><pre><code>package server;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class HelloImpl extends UnicastRemoteObject implements Hello {    private static final long serialVersionUID = -271947229644133464L;    public HelloImpl() throws RemoteException{        super();    }    public String sayHello(String name) throws RemoteException {        return &quot;Hello,&quot;+name;    }}</code></pre><h4 id="3，利用java自带rmic工具生成sutb存根类-jdk1-5-0-15-bin-rmic"><a href="#3，利用java自带rmic工具生成sutb存根类-jdk1-5-0-15-bin-rmic" class="headerlink" title="3，利用java自带rmic工具生成sutb存根类(jdk1.5.0_15/bin/rmic)"></a>3，利用java自带rmic工具生成sutb存根类(jdk1.5.0_15/bin/rmic)</h4><p>jdk1.2以后的RMI可以通过反射API可以直接将请求发送给真实类，所以不需要skeleton类了</p><p>sutb存根为远程方法类在本地的代理，是在服务端代码的基础上生成的，需要HelloImpl.class文件，由于HelloImpl继承了Hello接口，故Hello.class文件也是不可少的</p><p>Test</p><p>– server</p><p>—- Hello.class</p><p>—- HelloImpl.class</p><p>方式一：</p><pre><code>[name@name Test]$ cd /home/name/Test/[name@name Test]$ rmic server.HelloImpl</code></pre><p>方式二：</p><pre><code>[name@name Test]$ rmic -classpath /home/name/Test server.HelloImpl</code></pre><p>运行成功后将会生成HelloImpl_Stub.class文件</p><h4 id="4，启动RMI注册服务-jdk1-5-0-15-bin-rmiregistry"><a href="#4，启动RMI注册服务-jdk1-5-0-15-bin-rmiregistry" class="headerlink" title="4，启动RMI注册服务(jdk1.5.0_15/bin/rmiregistry)"></a>4，启动RMI注册服务(jdk1.5.0_15/bin/rmiregistry)</h4><p>方式一：后台启动rmiregistry服务</p><pre><code>[name@name jdk]$ jdk1.5.0_15/bin/rmiregistry 12312 &amp;[1] 22720[name@name jdk]$ ps -ef|grep rmiregistryname    22720 13763  0 16:43 pts/3    00:00:00 jdk1.5.0_15/bin/rmiregistry 12312name    22737 13763  0 16:43 pts/3    00:00:00 grep rmiregistry</code></pre><p><strong>如果不带具体端口号，则默认为1099</strong></p><p>方式二：人工创建rmiregistry服务，需要在代码中添加：</p><pre><code>LocateRegistry.createRegistry(12312);</code></pre><h4 id="5，编写服务端代码"><a href="#5，编写服务端代码" class="headerlink" title="5，编写服务端代码"></a>5，编写服务端代码</h4><pre><code>package server;import java.rmi.Naming;import java.rmi.registry.LocateRegistry;public class HelloServer {    public static void main(String[] args) {        try{            Hello h = new HelloImpl();            //创建并导出接受指定port请求的本地主机上的Registry实例。            //LocateRegistry.createRegistry(12312);            /**    Naming 类提供在对象注册表中存储和获得远程对远程对象引用的方法             *  Naming 类的每个方法都可将某个名称作为其一个参数，             *  该名称是使用以下形式的 URL 格式（没有 scheme 组件）的 java.lang.String:             *  //host:port/name             *  host：注册表所在的主机（远程或本地)，省略则默认为本地主机             *  port：是注册表接受调用的端口号，省略则默认为1099，RMI注册表registry使用的著名端口             *  name：是未经注册表解释的简单字符串             */            //Naming.bind(&quot;//host:port/name&quot;, h);            Naming.bind(&quot;rmi://192.168.58.164:12312/Hello&quot;, h);            System.out.println(&quot;HelloServer启动成功&quot;);        }catch(Exception e){            e.printStackTrace();        }    }}</code></pre><p><strong>先创建注册表，然后才能在注册表中存储远程对象信息</strong></p><h4 id="6，运行服务端（58-164）："><a href="#6，运行服务端（58-164）：" class="headerlink" title="6，运行服务端（58.164）："></a>6，运行服务端（58.164）：</h4><p>Test</p><p>– server</p><p>—- Hello.class</p><p>—- HelloImpl.class</p><p>—- HelloServer.class</p><pre><code>[name@name ~]$ java server.HelloServerHelloServer 启动成功</code></pre><p>当然/home/name/Test一定要在系统CLASSPATH中，否则会报找不到相应的.class文件</p><h4 id="7，编写客户端代码"><a href="#7，编写客户端代码" class="headerlink" title="7，编写客户端代码"></a>7，编写客户端代码</h4><pre><code>package client;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;import server.Hello;public class HelloClient {    public static void main(String[] args) {        try {            Hello h = (Hello)Naming.lookup(&quot;rmi://192.168.58.164:12312/Hello&quot;);            System.out.println(h.sayHello(&quot;zx&quot;));        } catch (MalformedURLException e) {            System.out.println(&quot;url格式异常&quot;);        } catch (RemoteException e) {            System.out.println(&quot;创建对象异常&quot;);            e.printStackTrace();        } catch (NotBoundException e) {            System.out.println(&quot;对象未绑定&quot;);        }    }}</code></pre><h4 id="8，运行客户端（58-163）："><a href="#8，运行客户端（58-163）：" class="headerlink" title="8，运行客户端（58.163）："></a>8，运行客户端（58.163）：</h4><p>Test</p><p>– client</p><p>—- HelloClient.class</p><p>– server</p><p>—- Hello.class</p><p>—- HelloImpl_Stub.class//服务端生成的存根文件</p><pre><code>[name@name client]$ java client.HelloClientHello,zx</code></pre><p>同服务器端，/home/name/Test一定要在系统CLASSPATH中</p><p><img src="/assets/blogImg/4/3.png" alt="图3"></p><p><strong>PS：</strong></p><p>1，客户端所在服务和服务端所在的服务器网络一定要通（一开始浪费了很多时间，最后才发现是网络不通）</p><p>2，所有代码在jdk1.5.0_15，Linux服务器上调试通过</p><p>3，如果java命令运行提示找不到类文件，则为CLASSPATH配置问题</p><pre><code>[name@name ~]$ vi .bash_profile JAVA_HOME=/home/name/jdk/jdk1.5.0_15export JAVA_HOMEPATH=$JAVA_HOME/bin:$PATHexport PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:/home/name/Testexport CLASSPATH</code></pre><p>JAVA_HOME为jdk的根目录</p><p>PATH为java工具类路径(java，javac，rmic等)</p><p>CLASSPATH为java .class文件的存放路径，使用java命令运行.class文件时即会在该参数配置的路径下寻找相应文件</p><h4 id="java-RMI的缺点："><a href="#java-RMI的缺点：" class="headerlink" title="java RMI的缺点："></a>java RMI的缺点：</h4><p>1，从代码中也可以看到，代码依赖于ip与端口</p><p>2，RMI依赖于Java远程消息交换协议JRMP（Java Remote Messaging Protocol），该协议为java定制，要求服务端与客户端都为java编写</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/a19881029/article/details/9465663&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a19881029/article/details/9465663&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="RMI" scheme="https://mlone.top/tags/RMI/"/>
    
  </entry>
  
  <entry>
    <title>java序列化(Serializable)的作用和反序列化</title>
    <link href="https://mlone.top/post/693bdb7c.html"/>
    <id>https://mlone.top/post/693bdb7c.html</id>
    <published>2018-10-01T05:20:13.000Z</published>
    <updated>2019-02-23T12:33:37.273Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/zero0/articles/1874841.html" target="_blank" rel="noopener">https://www.cnblogs.com/zero0/articles/1874841.html</a><br><a id="more"></a></p><p>这里转载一篇讲解java序列化(Serializable)和反序列化方面的感觉很好的文章。 </p><h3 id="1、序列化是干什么的？"><a href="#1、序列化是干什么的？" class="headerlink" title="1、序列化是干什么的？"></a>1、序列化是干什么的？</h3><p>简单说就是为了<strong>保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。</strong>虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 </p><h3 id="2、什么情况下需要序列化"><a href="#2、什么情况下需要序列化" class="headerlink" title="2、什么情况下需要序列化"></a>2、什么情况下需要序列化</h3><p><strong>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</strong></p><p><strong>b）当你想用套接字在网络上传送对象的时候；</strong> </p><p><strong>c）当你想通过RMI传输对象的时候；</strong></p><h3 id="6、相关注意事项"><a href="#6、相关注意事项" class="headerlink" title="6、相关注意事项"></a>6、相关注意事项</h3><p><em>a）序列化时，只对对象的状态进行保存，而不管对象的方法；</em> </p><p><em>b）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口</em>； </p><p><em>c）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</em> </p><p><em>d）并非所有的对象都可以序列化。</em></p><p>至于为什么不可以，有很多原因了,比如： </p><p>1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输  等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。</p><p>2.资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现。 </p><h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述:"></a>详细描述:</h3><p>序列化的过程就是对象写入字节流和从字节流中读取对象。将对象状态转换成字节流之后，可以用java.io包中的各种字节流类将其保存到文件中，管道到另一 线程中或通过网络连接将对象数据发送到另一主机。对象序列化功能非常简单、强大，在RMI、Socket、JMS、EJB都有应用。对象序列化问题在网络 编程中并不是最激动人心的课题，但却相当重要，具有许多实用意义。 </p><p>一：对象序列化可以实现分布式对象。主要应用例如：RMI要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。 </p><p>二：java 对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用 对象序列化可以进行对象的“深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。 </p><p>从上面的叙述中，我们知道了对象序列化是java编程中的必备武器，那么让我们从基础开始，好好学习一下它的机制和用法。 </p><p>java序列化比较简单，通常不需要编写保存和恢复对象状态的定制代码。实现java.io.Serializable接口的类对象可以转换成字 节流或从 字节流恢复，不需要在类中增加任何代码。只有极少数情况下才需要定制代码保存或恢复对象状态。这里要注意：不是每个类都可序列化，有些类是不能序列化的， 例如涉及线程的类与特定JVM有非常复杂的关系。 </p><h3 id="序列化机制："><a href="#序列化机制：" class="headerlink" title="序列化机制："></a>序列化机制：</h3><p>序列化分为两大部分：序列化和反序列化。<br>序列化是这 个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。<br>反序列化就是打开字节流并重构对象。</p><p>对象序列化不仅要将基本数据类型转换成字节 表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。ObjectOutputStream中的序列化过程与字节流连接，包括对象类型和版本信 息。</p><p>反序列化时，JVM用头信息生成对象实例，然后将对象字节流中的数据复制到对象数据成员中。下面我们分两大部分来阐述： </p><h3 id="处理对象流："><a href="#处理对象流：" class="headerlink" title="处理对象流："></a>处理对象流：</h3><p>（序列化过程和反序列化过程） </p><p>java.io包有两个序列化对象的类。ObjectOutputStream负责将对象写入字节流，ObjectInputStream从字节流重构对象。 </p><p>我们先了解ObjectOutputStream类吧。ObjectOutputStream类扩展DataOutput接口。<br>writeObject() 方法是最重要的方法，用于对象序列化。如果对象包含其他对象的引用，则writeObject()方法递归序列化这些对象。每个 ObjectOutputStream维护序列化的对象引用表，防止发送同一对象的多个拷贝。（这点很重要）由于writeObject()可以序列化整 组交叉引用的对象，因此同一ObjectOutputStream实例可能不小心被请求序列化同一对象。这时，进行反引用序列化，而不是再次写入对象字节 流。<br>下面，让我们从例子中来了解ObjectOutputStream这个类吧。</p><pre><code>// 序列化 today’s date 到一个文件中. FileOutputStream f = new FileOutputStream(“tmp”);     //创建一个包含恢复对象(即对象进行反序列化信息)的”tmp”数据文件 ObjectOutputStream s = new ObjectOutputStream(f); s.writeObject(“Today”);    //写入字符串对象; s.writeObject(new Date());    //写入瞬态对象; s.flush(); </code></pre><p>现在，让我们来了解ObjectInputStream这个类。它与ObjectOutputStream相似。它扩展DataInput接口。 ObjectInputStream中的方法镜像DataInputStream中读取Java基本数据类型的公开方法。readObject()方法从 字节流中反序列化对象。每次调用readObject()方法都返回流中下一个Object。对象字节流并不传输类的字节码，而是包括类名及其签名。 readObject()收到对象时，JVM装入头中指定的类。如果找不到这个类，则readObject()抛出 ClassNotFoundException,如果需要传输对象数据和字节码，则可以用RMI框架。ObjectInputStream的其余方法用于 定制反序列化过程。<br>例子如下： </p><pre><code>//从文件中反序列化 string 对象和 date 对象 FileInputStream in = new FileInputStream(“tmp”); ObjectInputStream s = new ObjectInputStream(in); String today = (String)s.readObject();   //恢复对象; Date date = (Date)s.readObject(); </code></pre><h3 id="定制序列化过程"><a href="#定制序列化过程" class="headerlink" title="定制序列化过程:"></a>定制序列化过程:</h3><p>序列化通常可以自动完成，但有时可能要对这个过程进行控制。java可以将类声明为serializable，但仍可手工控制声明为static或transient的数据成员。 </p><p>例子：一个非常简单的序列化类。 </p><pre><code>public class simpleSerializableClass implements Serializable{     String sToday=”Today:”;     transient Date dtToday=new Date(); } </code></pre><p>序列化时，类的所有数据成员应可序列化除了声明为transient或static的成员。将变量声明为transient告诉JVM我们会负责将变元序列 化。将数据成员声明为transient后，序列化过程就无法将其加进对象字节流中，没有从transient数据成员发送的数据。后面数据反序列化时， 要重建数据成员（因为它是类定义的一部分），但不包含任何数据，因为这个数据成员不向流中写入任何数据。记住，对象流不序列化static或 transient。我们的类要用writeObject()与readObject()方法以处理这些数据成员。使用writeObject()与 readObject()方法时，还要注意按写入的顺序读取这些数据成员。</p><p>关于如何使用定制序列化的部分代码如下：</p><pre><code>//重写writeObject()方法以便处理transient的成员。 public void writeObject(ObjectOutputStream outputStream) throws IOException{     outputStream.defaultWriteObject(); //使定制的writeObject()方法可以利用自动序列化中内置的逻辑。     outputStream.writeObject(oSocket.getInetAddress());     outputStream.writeInt(oSocket.getPort()); } //重写readObject()方法以便接收transient的成员。 private void readObject(ObjectInputStream inputStream) throws IOException,ClassNotFoundException{     inputStream.defaultReadObject(); //defaultReadObject()补充自动序列化     InetAddress oAddress=(InetAddress)inputStream.readObject();     int iPort =inputStream.readInt();     oSocket = new Socket(oAddress,iPort);     iID=getID();     dtToday =new Date(); } </code></pre><h3 id="完全定制序列化过程"><a href="#完全定制序列化过程" class="headerlink" title="完全定制序列化过程:"></a>完全定制序列化过程:</h3><p>如果一个类要完全负责自己的序列化，则实现Externalizable接口而不是Serializable接口。Externalizable接口定义包 括两个方法writeExternal()与readExternal()。利用这些方法可以控制对象数据成员如何写入字节流.类实现 Externalizable时，头写入对象流中，然后类完全负责序列化和恢复数据成员，除了头以外，根本没有自动序列化。这里要注意了。声明类实现 Externalizable接口会有重大的安全风险。writeExternal()与readExternal()方法声明为public，恶意类可 以用这些方法读取和写入对象数据。如果对象包含敏感信息，则要格外小心。这包括使用安全套接或加密整个字节流。</p><p>到此为至，我们学习了序列化的基础部分知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/zero0/articles/1874841.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zero0/articles/1874841.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="序列化" scheme="https://mlone.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Callable、Future和FutureTask</title>
    <link href="https://mlone.top/post/6e36e91a.html"/>
    <id>https://mlone.top/post/6e36e91a.html</id>
    <published>2018-09-28T14:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.772Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">Java并发编程：Callable、Future和FutureTask</a></p><a id="more"></a><p>　　在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。</p><p>　　这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p><p>　　如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>　　而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><p>　　今天我们就来讨论一下Callable、Future和FutureTask三个类的使用方法。以下是本文的目录大纲：</p><p>　　一.Callable与Runnable</p><p>　　二.Future</p><p>　　三.FutureTask</p><p>　　四.使用示例</p><h2 id="一-Callable与Runnable"><a href="#一-Callable与Runnable" class="headerlink" title="一.Callable与Runnable"></a>一.Callable与Runnable</h2><p>　先说一下java.lang.Runnable吧，它是一个接口，在它里面只声明了一个run()方法：</p><pre><code>public interface Runnable {    public abstract void run();}</code></pre><p>　　由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>　　Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：</p><pre><code>public interface Callable&lt;V&gt; {    /**     * Computes a result, or throws an exception if unable to do so.     *     * @return computed result     * @throws Exception if unable to compute a result     */    V call() throws Exception;}</code></pre><p> 　　可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p><p>　　那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本:</p><pre><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);</code></pre><p>　　第一个submit方法里面的参数类型就是Callable。</p><p>　　暂时只需要知道Callable一般是和ExecutorService配合来使用的，具体的使用方法讲在后面讲述。</p><p>　　一般情况下我们使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。</p><h2 id="二-Future"><a href="#二-Future" class="headerlink" title="二.Future"></a>二.Future</h2><p>　　Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><p>　　Future类位于java.util.concurrent包下，它是一个接口：</p><pre><code>public interface Future&lt;V&gt; {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();    V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><p>　　在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p><ul><li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li><li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li><li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul><p>　　也就是说Future提供了三种功能：</p><p>　　1）判断任务是否完成；</p><p>　　2）能够中断任务；</p><p>　　3）能够获取任务执行结果。</p><p>　　因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p><h2 id="三-FutureTask"><a href="#三-FutureTask" class="headerlink" title="三.FutureTask"></a>三.FutureTask</h2><p>　　我们先来看一下FutureTask的实现：</p><pre><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</code></pre><p>　　FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：</p><pre><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {    void run();}</code></pre><p> 　　可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p>　　FutureTask提供了2个构造器：</p><pre><code>public FutureTask(Callable&lt;V&gt; callable) {}public FutureTask(Runnable runnable, V result) {}</code></pre><p>事实上，FutureTask是Future接口的一个唯一实现类。</p><h2 id="四-使用示例"><a href="#四-使用示例" class="headerlink" title="四.使用示例"></a>四.使用示例</h2><p>　<strong>1.使用Callable+Future获取执行结果</strong></p><pre><code>public class Test {    public static void main(String[] args) {        ExecutorService executor = Executors.newCachedThreadPool();        Task task = new Task();        Future&lt;Integer&gt; result = executor.submit(task);        executor.shutdown();        try {            Thread.sleep(1000);        } catch (InterruptedException e1) {            e1.printStackTrace();        }        System.out.println(&quot;主线程在执行任务&quot;);        try {            System.out.println(&quot;task运行结果&quot;+result.get());        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        System.out.println(&quot;所有任务执行完毕&quot;);    }}</code></pre><p>.</p><pre><code>class Task implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        System.out.println(&quot;子线程在进行计算&quot;);        Thread.sleep(3000);        int sum = 0;        for(int i=0;i&lt;100;i++)            sum += i;        return sum;    }}</code></pre><p> 　　执行结果：</p><pre><code>子线程在进行计算主线程在执行任务task运行结果4950所有任务执行完毕</code></pre><p>　　<strong>2.使用Callable+FutureTask获取执行结果</strong></p><pre><code>public class Test {    public static void main(String[] args) {        //第一种方式        ExecutorService executor = Executors.newCachedThreadPool();        Task task = new Task();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);        executor.submit(futureTask);        executor.shutdown();        //第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread        /*Task task = new Task();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);        Thread thread = new Thread(futureTask);        thread.start();*/        try {            Thread.sleep(1000);        } catch (InterruptedException e1) {            e1.printStackTrace();        }        System.out.println(&quot;主线程在执行任务&quot;);        try {            System.out.println(&quot;task运行结果&quot;+futureTask.get());        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        System.out.println(&quot;所有任务执行完毕&quot;);    }}</code></pre><p>.</p><pre><code>class Task implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        System.out.println(&quot;子线程在进行计算&quot;);        Thread.sleep(3000);        int sum = 0;        for(int i=0;i&lt;100;i++)            sum += i;        return sum;    }}</code></pre><p>如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3949310.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java并发编程：Callable、Future和FutureTask&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="https://mlone.top/post/443887f3.html"/>
    <id>https://mlone.top/post/443887f3.html</id>
    <published>2018-09-27T14:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.781Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/dreamroute/p/5034726.html" target="_blank" rel="noopener">https://www.cnblogs.com/dreamroute/p/5034726.html</a></p><a id="more"></a><p>　　ThreadLocal翻译成中文比较准确的叫法应该是：线程局部变量。</p><p>　　这个玩意有什么用处，或者说为什么要有这么一个东东？先解释一下，在并发编程的时候，成员变量如果不做任何处理其实是线程不安全的，各个线程都在操作同一个变量，显然是不行的，并且我们也知道volatile这个关键字也是不能保证线程安全的。那么在有一种情况之下，我们需要满足这样一个条件：变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本。这种情况之下ThreadLocal就非常使用，比如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是一个线程安全的变量。而我们每个线程都需要使用他，并且各自使用各自的。这种情况，ThreadLocal就比较好的解决了这个问题。</p><p>　　我们从源码的角度来分析这个问题。</p><p>　　首先定义一个ThreadLocal：</p><pre><code>public final class ConnectionUtil {    private ConnectionUtil() {}    private static final ThreadLocal&lt;Connection&gt; conn = new ThreadLocal&lt;&gt;();    public static Connection getConn() {        Connection con = conn.get();        if (con == null) {            try {                Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                con = DriverManager.getConnection(&quot;url&quot;, &quot;userName&quot;, &quot;password&quot;);                conn.set(con);            } catch (ClassNotFoundException | SQLException e) {                // ...            }        }        return con;    }}</code></pre><p>　　这样子，都是用同一个连接，但是每个连接都是新的，是同一个连接的副本。</p><p>　　那么实现机制是如何的呢？</p><p>　　1、每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个ThreadLocal。</p><pre><code>/* ThreadLocal values pertaining to this thread. This map is maintained  * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;</code></pre><p>　　2、当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。</p><pre><code>public T get() {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null)            return (T)e.value;    }    return setInitialValue();}</code></pre><p>　　3、当我们调用set()方法的时候，很常规，就是将值设置进ThreadLocal中。</p><p>　　4、总结：当我们调用get方法的时候，其实每个当前线程中都有一个ThreadLocal。每次获取或者设置都是对该ThreadLocal进行的操作，是与其他线程分开的。</p><p>　　5、应用场景：当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。</p><p>　　6、其实说再多也不如看一下源码来得清晰。如果要看源码，其中涉及到一个WeakReference和一个Map，这两个地方需要了解下，这两个东西分别是a.Java的弱引用，也就是GC的时候会销毁该引用所包裹(引用)的对象，这个threadLocal作为key可能被销毁，但是只要我们定义成他的类不卸载，tl这个强引用就始终引用着这个ThreadLocal的，永远不会被gc掉。b.和HashMap差不多。</p><p>　　事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值，既然从自己的变量中取值，那肯定就不存在线程安全问题，总体来讲，ThreadLocal这个变量的状态根本没有发生变化，他仅仅是充当一个key的角色，另外提供给每一个线程一个初始值。如果允许的话，我们自己就能实现一个这样的功能，只不过恰好JDK就已经帮我们做了这个事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/dreamroute/p/5034726.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/dreamroute/p/5034726.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>join方法简单总结</title>
    <link href="https://mlone.top/post/318e1afb.html"/>
    <id>https://mlone.top/post/318e1afb.html</id>
    <published>2018-09-22T14:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.786Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/lcplcpjava/p/6896904.html" target="_blank" rel="noopener">java 线程方法join的简单总结</a></p><a id="more"></a><p>　　虽然关于讨论线程join方法的博客已经很多了，不过个人感觉挺多都讨论得不够全面，所以我觉得有必要对其进行一个全面的总结。</p><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>　　Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。具体看代码：</p><pre><code>public class JoinTest {    public static void main(String [] args) throws InterruptedException {        ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);        ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);        t1.start();        /**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：         程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕         所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会         */        t1.join();        t2.start();    }}class ThreadJoinTest extends Thread{    public ThreadJoinTest(String name){        super(name);    }    @Override    public void run(){        for(int i=0;i&lt;1000;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>上面程序结果是先打印完小明线程，在打印小东线程；　　</p><p>　　上面注释也大概说明了join方法的作用：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。注意，这里调用的join方法是没有传参的，join方法其实也可以传递一个参数给它的，具体看下面的简单例子：</p><pre><code>public class JoinTest {    public static void main(String [] args) throws InterruptedException {        ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);        ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);        t1.start();        /**join方法可以传递参数，join(10)表示main线程会等待t1线程10毫秒，10毫秒过去后，         * main线程和t1线程之间执行顺序由串行执行变为普通的并行执行         */        t1.join(10);        t2.start();    }}class ThreadJoinTest extends Thread{    public ThreadJoinTest(String name){        super(name);    }    @Override    public void run(){        for(int i=0;i&lt;1000;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>上面代码结果是：程序执行前面10毫秒内打印的都是小明线程，10毫秒后，小明和小东程序交替打印。</p><p>　　所以，join方法中如果传入参数，则表示这样的意思：如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。需要注意的是，jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。　　</p><h2 id="二、join与start调用顺序问题"><a href="#二、join与start调用顺序问题" class="headerlink" title="二、join与start调用顺序问题"></a>二、join与start调用顺序问题</h2><p>　　上面的讨论大概知道了join的作用了，那么，入股 join在start前调用，会出现什么后果呢？先看下面的测试结果</p><pre><code>public class JoinTest {    public static void main(String [] args) throws InterruptedException {        ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);        ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);        /**join方法可以在start方法前调用时，并不能起到同步的作用         */        t1.join();        t1.start();        //Thread.yield();        t2.start();    }}class ThreadJoinTest extends Thread{    public ThreadJoinTest(String name){        super(name);    }    @Override    public void run(){        for(int i=0;i&lt;1000;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>上面代码执行结果是：小明和小东线程交替打印。</p><p>　　所以得到以下结论：join方法必须在线程start方法调用之后调用才有意义。这个也很容易理解：如果一个线程都没有start，那它也就无法同步了。</p><h2 id="三、join方法实现原理"><a href="#三、join方法实现原理" class="headerlink" title="三、join方法实现原理"></a>三、join方法实现原理</h2><p>　　有了上面的例子，我们大概知道join方法的作用了，那么，join方法实现的原理是什么呢？</p><p>　　其实，join方法是通过调用线程的wait方法来达到同步的目的的。例如，A线程中调用了B线程的join方法，则相当于A线程调用了B线程的wait方法，在调用了B线程的wait方法后，A线程就会进入阻塞状态，具体看下面的源码：</p><pre><code>public final synchronized void join(long millis)    throws InterruptedException {        long base = System.currentTimeMillis();        long now = 0;        if (millis &lt; 0) {            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);        }        if (millis == 0) {            while (isAlive()) {                wait(0);            }        } else {            while (isAlive()) {                long delay = millis - now;                if (delay &lt;= 0) {                    break;                }                wait(delay);                now = System.currentTimeMillis() - base;            }        }    }}</code></pre><p>　　从源码中可以看到：<strong>join方法的原理就是调用相应线程的wait方法进行等待操作的，</strong>例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/lcplcpjava/p/6896904.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java 线程方法join的简单总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>wait和sleep方法的区别</title>
    <link href="https://mlone.top/post/16df4c2a.html"/>
    <id>https://mlone.top/post/16df4c2a.html</id>
    <published>2018-09-21T12:39:28.000Z</published>
    <updated>2019-02-27T09:25:06.531Z</updated>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.cnblogs.com/loren-Yang/p/7538482.html" target="_blank" rel="noopener">https://www.cnblogs.com/loren-Yang/p/7538482.html</a></p><a id="more"></a><h4 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h4><p><strong>（1）来自不同的类：</strong></p><p>sleep()方法是Thread类中的一个静态方法；</p><p>wait()属于Object类的成员方法。</p><p><strong>（2）唤醒条件不同：</strong></p><p>Sleep()方法属于Thread类中方法，表示让当前线程进入睡眠状态，等待一定的时间后，便会自动醒来进入可运行状态；</p><p>一旦某个线程对象调用了wait()方法，就必须要在其他线程中使用notify()或notifyAll()方法才能唤醒它。</p><p><strong>（3）异常捕获不同：</strong></p><p>在sleep的过程中有可能被其他对象调用它的interrupt()方法,产生InterruptedException异常，所以要使用sleep方法必须对其捕获异常；</p><p>而使用wait()，notify()和notifyAll()方法不需要进行捕获异常 。</p><p><strong>（4）最主要区别是对带锁Synchronized资源的控制权：</strong></p><p>Sleep()方法没有释放锁。一个线程对象调用了sleep()方法之后，并不会释放它所持有的所有对象锁；</p><p>Wait()方法释放了锁。使得其他线程可以有机会使用带锁代码块或者带锁方法。</p><p><strong>PS：</strong></p><p>如果线程调用了对象的 wait()方法，那么线程便会处于该对象的<strong>等待池</strong>中，<strong>等待池中的线程不会去竞争该对象的锁。</strong></p><ul><li>当有线程调用了对象的 notifyAll()方法（唤醒所有 wait 线程）或 notify()方法（只随机唤醒一个 wait 线程），被唤醒的的线程便会进入该对象的锁池中，锁池中的线程会去竞争该对象锁。</li><li>也就是说，调用了notify后只会有一个线程会由等待池进入锁池，而notifyAll会将该对象等待池内的所有线程移动到锁池中，等待锁竞争。</li></ul><h4 id="补充两个重要的方法：-yield-和join"><a href="#补充两个重要的方法：-yield-和join" class="headerlink" title="补充两个重要的方法： yield()和join()"></a>补充两个重要的方法： yield()和join()</h4><p>　　yield方法暂停当前正在执行的线程对象。  </p><p>　　yield()方法是停止当前线程，让同等优先权的线程或更高优先级的线程有执行的机会。如果没有的话，那么yield()方法将不会起作用，并且由可执行状态后马上又被执行。   </p><p>　　join方法是用于在某一个线程的执行过程中调用另一个线程执行，等到被调用的线程执行结束后，再继续执行当前线程。</p><p>　　如：</p><pre><code>t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。 </code></pre><h4 id="说一下为什么使用wait-方法时，一般是需要while循环而不是if？"><a href="#说一下为什么使用wait-方法时，一般是需要while循环而不是if？" class="headerlink" title="说一下为什么使用wait()方法时，一般是需要while循环而不是if？"></a>说一下为什么使用wait()方法时，一般是需要while循环而不是if？</h4><pre><code>while(!执行条件） {    wait();}....if(!执行条件） {    wait();}....</code></pre><p>　　while会一直执行循环，直到条件满足，执行条件才会继续往下执行。if只会执行一次判断条件，不满足就会等待。这样就会出现问题。</p><p>　　我们知道用notify() 和notifyAll()可以唤醒线程，一般我们常用的是notifyAll()，因为notify()，只会随机唤醒一个睡眠线程，并不一定是我们想要唤醒的线程。如果使用的是notifyAll()，唤醒所有的线程，那你怎么知道他想唤醒的是某个正在等待的wait()线程呢，如果用while()方法，就会再次判断条件是不是成立，满足执行条件了，就会接着执行，而if会直接唤醒wait()方法，继续往下执行，根本不管这个notifyAll()是不是想唤醒的是自己还是别人，可能此时if的条件根本没成立。</p><p>举个例子：</p><p>　　while去水果店买苹果，没有了，然后while就和水果店老板说，有水果的时候通知我，我先回去了。if也去水果店买苹果，没有了，然后if就和水果店老板说，有水果的时候通知我，我先回去了。过一段时间，水果店老板发短信告诉while和if，有水果了，while去一看，水果店只是进了香蕉，并不是苹果，所以不是想要的水果，于是回去继续等水果店老板通知，而if根本就不看是不是自己想要的苹果，直接就叫老板送10斤水果过来，这样会导致你得到错误的结果。</p><p>参考文献：</p><p><a href="http://wkf41068.iteye.com/blog/1835697" target="_blank" rel="noopener">Java中wait 和sleep 方法比较</a></p><p><a href="http://blog.csdn.net/clam_clam/article/details/6803667" target="_blank" rel="noopener">JAVA-sleep()和wait()的区别</a></p><p><a href="http://www.cnblogs.com/hongten/p/hongten_java_sleep_wait.html" target="_blank" rel="noopener">java中的sleep()和wait()的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;a href=&quot;https://www.cnblogs.com/loren-Yang/p/7538482.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/loren-Yang/p/7538482.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://mlone.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>早绑定与晚绑定</title>
    <link href="https://mlone.top/post/72dff8df.html"/>
    <id>https://mlone.top/post/72dff8df.html</id>
    <published>2018-09-20T01:00:07.000Z</published>
    <updated>2019-02-23T10:22:12.406Z</updated>
    
    <content type="html"><![CDATA[<p>静态绑定（早绑定）：<br>程序在编译阶段根据参数个数确定调用哪个函数（重载）。<br><a id="more"></a><br>动态绑定（晚绑定）：<br>以封装和继承为基础，将成员函数和析构函数声明为虚函数（virtual）。<br>构造函数不能声明为virtual：</p><pre><code>Shape *shape1 = new Circle(3.5, 4.0);shape -&gt; calcArea(); //父类指针调用子类面积函数delete Shape1；//先调用子类析构函数，再调用父类析构函数shape1 = NULL;return 0;</code></pre><p>C++:</p><pre><code>virtual double cost()=0; //纯虚函数</code></pre><p>纯虚函数在类内声明，在类内或类外定义函数，而纯虚函数无函数体。<br>含有纯虚函数的类称为抽象类；<br>只含有纯虚函数的类称为接口类（没有任何数据成员）。</p><p>Java:    通过”abstract”关键字实现多态。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态绑定（早绑定）：&lt;br&gt;程序在编译阶段根据参数个数确定调用哪个函数（重载）。&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://mlone.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://mlone.top/tags/Java/"/>
    
      <category term="C++" scheme="https://mlone.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>wait、notify/notifyAll详解</title>
    <link href="https://mlone.top/post/362a4e44.html"/>
    <id>https://mlone.top/post/362a4e44.html</id>
    <published>2018-09-19T12:39:28.000Z</published>
    <updated>2019-02-25T14:42:03.784Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/moongeek/p/7631447.html" target="_blank" rel="noopener">Java多线程学习之wait、notify/notifyAll 详解</a></p><a id="more"></a><p><strong>1、wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。</strong></p><p><strong>2、wait()使当前线程阻塞，前提是 必须先获得锁，一般配合synchronized 关键字使用，即，一般在synchronized 同步代码块里使用 wait()、notify/notifyAll() 方法。</strong></p><p><strong>3、 由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。</strong></p><p>　　<em>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。</em></p><p>　　<em>只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁</em>。</p><p>　　也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程。</p><p><strong>4、wait() 需要被try catch包围，中断也可以使wait等待的线程唤醒。</strong></p><p><strong>5、notify 和wait 的顺序不能错，如果A线程先执行notify方法，B线程在执行wait方法，那么B线程是无法被唤醒的。</strong></p><p><strong>6、notify 和 notifyAll的区别</strong></p><p>　　<em>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</em></p><p><strong>7、在多线程中要测试某个条件的变化，使用if 还是while？</strong></p><p>　　要注意，notify唤醒沉睡的线程后，<strong>线程会接着上次的执行继续往下执行。所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑，显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while来执行，以确保条件满足和一定执行。</strong>如下代码：</p><pre><code>public class K {    //状态锁    private Object lock;    //条件变量    private int now,need;    public void produce(int num){        //同步        synchronized (lock){           //当前有的不满足需要，进行等待            while(now &lt; need){                try {                    //等待阻塞                    wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(&quot;我被唤醒了！&quot;);            }           // 做其他的事情        }    }}</code></pre><p>　　显然，只有当前值满足需要值的时候，线程才可以往下执行，所以，必须使用while 循环阻塞。注意，wait() 当被唤醒时候，只是让while循环继续往下走.如果此处用if的话，意味着if继续往下走，会跳出if语句块。但是，notifyAll 只是负责唤醒线程，并不保证条件云云，所以需要手动来保证程序的逻辑。</p><p><strong>8、实现生产者和消费者问题 </strong></p><p>　　什么是生产者-消费者问题呢？</p><p><img src="/assets/blogImg/4/10.jpg" alt="图片10"></p><p>如上图，假设有一个公共的容量有限的池子，有两种人，一种是生产者，另一种是消费者。需要满足如下条件：</p><p>　　　　1、生产者产生资源往池子里添加，前提是池子没有满，如果池子满了，则生产者暂停生产，直到自己的生成能放下池子。</p><p>　　　　2、消费者消耗池子里的资源，前提是池子的资源不为空，否则消费者暂停消耗，进入等待直到池子里有资源数满足自己的需求。</p><p>　　– 仓库类　</p><pre><code>import java.util.LinkedList;/** *  生产者和消费者的问题 *  wait、notify/notifyAll() 实现 */public class Storage1 implements AbstractStorage {    //仓库最大容量    private final int MAX_SIZE = 100;    //仓库存储的载体    private LinkedList list = new LinkedList();    //生产产品    public void produce(int num){        //同步        synchronized (list){            //仓库剩余的容量不足以存放即将要生产的数量，暂停生产            while(list.size()+num &gt; MAX_SIZE){                System.out.println(&quot;【要生产的产品数量】:&quot; + num + &quot;\t【库存量】:&quot;                        + list.size() + &quot;\t暂时不能执行生产任务!&quot;);                try {                    //条件不满足，生产阻塞                    list.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            for(int i=0;i&lt;num;i++){                list.add(new Object());            }            System.out.println(&quot;【已经生产产品数】:&quot; + num + &quot;\t【现仓储量为】:&quot; + list.size());            list.notifyAll();        }    }    //消费产品    public void consume(int num){        synchronized (list){            //不满足消费条件            while(num &gt; list.size()){                System.out.println(&quot;【要消费的产品数量】:&quot; + num + &quot;\t【库存量】:&quot;                        + list.size() + &quot;\t暂时不能执行生产任务!&quot;);                try {                    list.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            //消费条件满足，开始消费            for(int i=0;i&lt;num;i++){                list.remove();            }            System.out.println(&quot;【已经消费产品数】:&quot; + num + &quot;\t【现仓储量为】:&quot; + list.size());            list.notifyAll();        }    }}</code></pre><p>　　- 抽象仓库类</p><pre><code>public interface AbstractStorage {    void consume(int num);    void produce(int num);}</code></pre><p>　　- 生产者</p><pre><code>public class Producer extends Thread{    //每次生产的数量    private int num ;    //所属的仓库    public AbstractStorage abstractStorage;    public Producer(AbstractStorage abstractStorage){        this.abstractStorage = abstractStorage;    }    public void setNum(int num){        this.num = num;    }    // 线程run函数    @Override    public void run()    {        produce(num);    }    // 调用仓库Storage的生产函数    public void produce(int num)    {        abstractStorage.produce(num);    }}</code></pre><p>　　- 消费者</p><pre><code>public class Consumer extends Thread{    // 每次消费的产品数量    private int num;    // 所在放置的仓库    private AbstractStorage abstractStorage1;    // 构造函数，设置仓库    public Consumer(AbstractStorage abstractStorage1)    {        this.abstractStorage1 = abstractStorage1;    }    // 线程run函数    public void run()    {        consume(num);    }    // 调用仓库Storage的生产函数    public void consume(int num)    {        abstractStorage1.consume(num);    }    public void setNum(int num){        this.num = num;    }}</code></pre><p>　　- 测试</p><pre><code>public class Test{    public static void main(String[] args) {        // 仓库对象        AbstractStorage abstractStorage = new Storage1();        // 生产者对象        Producer p1 = new Producer(abstractStorage);        Producer p2 = new Producer(abstractStorage);        Producer p3 = new Producer(abstractStorage);        Producer p4 = new Producer(abstractStorage);        Producer p5 = new Producer(abstractStorage);        Producer p6 = new Producer(abstractStorage);        Producer p7 = new Producer(abstractStorage);        // 消费者对象        Consumer c1 = new Consumer(abstractStorage);        Consumer c2 = new Consumer(abstractStorage);        Consumer c3 = new Consumer(abstractStorage);        // 设置生产者产品生产数量        p1.setNum(10);        p2.setNum(10);        p3.setNum(10);        p4.setNum(10);        p5.setNum(10);        p6.setNum(10);        p7.setNum(80);        // 设置消费者产品消费数量        c1.setNum(50);        c2.setNum(20);        c3.setNum(30);        // 线程开始执行        c1.start();        c2.start();        c3.start();        p1.start();        p2.start();        p3.start();        p4.start();        p5.start();        p6.start();        p7.start();    }}</code></pre><p>　　- 输出</p><pre><code>【要消费的产品数量】:50    【库存量】:0    暂时不能执行生产任务!【要消费的产品数量】:20    【库存量】:0    暂时不能执行生产任务!【要消费的产品数量】:30    【库存量】:0    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:10【要消费的产品数量】:30    【库存量】:10    暂时不能执行生产任务!【要消费的产品数量】:20    【库存量】:10    暂时不能执行生产任务!【要消费的产品数量】:50    【库存量】:10    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:20【已经生产产品数】:10    【现仓储量为】:30【要消费的产品数量】:50    【库存量】:30    暂时不能执行生产任务!【已经消费产品数】:20    【现仓储量为】:10【要消费的产品数量】:30    【库存量】:10    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:20【要消费的产品数量】:50    【库存量】:20    暂时不能执行生产任务!【要消费的产品数量】:30    【库存量】:20    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:30【已经消费产品数】:30    【现仓储量为】:0【要消费的产品数量】:50    【库存量】:0    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:10【要消费的产品数量】:50    【库存量】:10    暂时不能执行生产任务!【已经生产产品数】:80    【现仓储量为】:90【已经消费产品数】:50    【现仓储量为】:40</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/moongeek/p/7631447.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java多线程学习之wait、notify/notifyAll 详解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>抽象类</title>
    <link href="https://mlone.top/post/3dbae4e.html"/>
    <id>https://mlone.top/post/3dbae4e.html</id>
    <published>2018-09-18T10:25:14.000Z</published>
    <updated>2019-02-25T10:55:43.845Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/wei_zhi/article/details/52736350/" target="_blank" rel="noopener">https://blog.csdn.net/wei_zhi/article/details/52736350/</a></p><a id="more"></a><h2 id="一、抽象类的基本概念"><a href="#一、抽象类的基本概念" class="headerlink" title="一、抽象类的基本概念"></a>一、抽象类的基本概念</h2><p>普通类是一个完善的功能类，可以直接产生实例化对象，并且在普通类中可以包含有构造方法、普通方法、static方法、常量和变量等内容。</p><p>而抽象类是指在普通类的结构里面增加<strong>抽象方法</strong>的组成部分。</p><p>那么什么叫抽象方法呢？在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。而<strong>抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。</strong></p><p>而<strong>拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明。</strong></p><p>范例：定义一个抽象类:</p><pre><code>abstract class A{//定义一个抽象类    public void fun(){//普通方法        System.out.println(&quot;存在方法体的方法&quot;);    }    public abstract void print();//抽象方法，没有方法体，有abstract关键字做修饰}</code></pre><h2 id="二、抽象类的使用"><a href="#二、抽象类的使用" class="headerlink" title="二、抽象类的使用"></a>二、抽象类的使用</h2><p>我们先看范例。 </p><p>范例：直接实例化抽象类的对象:</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public void fun(){//普通方法        System.out.println(&quot;存在方法体的方法&quot;);    }    public abstract void print();//抽象方法，没有方法体，有abstract关键字做修饰}public class TestDemo {    public static void main(String[] args) {        A a = new A();    }}</code></pre><p>运行：</p><pre><code>Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem:     Cannot instantiate the type A    at com.wz.abstractdemo.TestDemo.main(TestDemo.java:15)</code></pre><p>从上可知，<strong>A是抽象的，无法直接进行实例化操作。</strong>为什么不能直接实例化呢？当一个类实例化之后，就意味着这个对象可以调用类中的属性或者放过了，但在抽象类里存在抽象方法，而抽象方法没有方法体，没有方法体就无法进行调用。既然无法进行方法调用的话，又怎么去产生实例化对象呢。</p><p>抽象类的使用原则如下：</p><ul><li><p>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public； </p></li><li><p>抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理； </p></li><li><p>抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；</p></li><li><p>子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；</p></li></ul><p>范例：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public void fun(){//普通方法        System.out.println(&quot;存在方法体的方法&quot;);    }    public abstract void print();//抽象方法，没有方法体，有abstract关键字做修饰}//单继承class B extends A{//B类是抽象类的子类，是一个普通类    @Override    public void print() {//强制要求覆写        System.out.println(&quot;Hello World !&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A a = new B();//向上转型        a.fun();//被子类所覆写的过的方法    }}</code></pre><p>运行结果：</p><pre><code>Hello World!</code></pre><p>现在就可以清楚的发现： </p><ul><li><p>抽象类继承子类里面有明确的方法覆写要求，而普通类可以有选择性的来决定是否需要覆写；</p></li><li><p>抽象类实际上就比普通类多了一些抽象方法而已，其他组成部分和普通类完全一样； </p></li><li><p>普通类对象可以直接实例化，但抽象类的对象必须经过向上转型之后才可以得到。</p></li></ul><p>虽然一个类的子类可以去继承任意的一个普通类，可是从开发的实际要求来讲，普通类尽量不要去继承另外一个普通类，而是去继承抽象类。</p><h2 id="三、抽象类的使用限制"><a href="#三、抽象类的使用限制" class="headerlink" title="三、抽象类的使用限制"></a>三、抽象类的使用限制</h2><p><strong>（1）抽象类中有构造方法么？ </strong></p><p><em>由于抽象类里会存在一些属性，那么抽象类中一定存在构造方法，其存在目的是为了属性的初始化。</em></p><p><em>并且子类对象实例化的时候，依然满足先执行父类构造，再执行子类构造的顺序。</em></p><p>范例如下：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public A(){        System.out.println(&quot;*****A类构造方法*****&quot;);    }    public abstract void print();//抽象方法，没有方法体，有abstract关键字做修饰}//单继承class B extends A{//B类是抽象类的子类，是一个普通类    public B(){        System.out.println(&quot;*****B类构造方法*****&quot;);    }    @Override    public void print() {//强制要求覆写        System.out.println(&quot;Hello World !&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A a = new B();//向上转型    }}</code></pre><p>执行结果：</p><pre><code>*****A类构造方法**********B类构造方法*****</code></pre><p><strong>（2）抽象类可以用final声明么？</strong> </p><p><em>不能，因为抽象类必须有子类，而final定义的类不能有子类</em>；</p><p><strong>（3）抽象类能否使用static声明？</strong> </p><p>先看一个关于外部抽象类的范例：</p><pre><code>package com.wz.abstractdemo;static abstract class A{//定义一个抽象类    public abstract void print();}class B extends A{    public void print(){        System.out.println(&quot;**********&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A a = new B();//向上转型        a.print();    }}</code></pre><p>执行结果:</p><pre><code>Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: Illegal modifier for the class A; only public, abstract &amp; final are permittedat com.wz.abstractdemo.A.&lt;init&gt;(TestDemo.java:3)at com.wz.abstractdemo.B.&lt;init&gt;(TestDemo.java:9)at com.wz.abstractdemo.TestDemo.main(TestDemo.java:18)</code></pre><p>再看一个关于内部抽象类：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    static abstract class B{//static定义的内部类属于外部类        public abstract void print();    }}class C extends A.B{    public void print(){        System.out.println(&quot;**********&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A.B ab = new C();//向上转型        ab.print();    }}</code></pre><p>执行结果：</p><pre><code>**********</code></pre><p>由此可见，外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</p><p><strong>（4）可以直接调用抽象类中用static声明的方法么？ </strong></p><p><em>任何时候，如果要执行类中的static方法的时候，都可以在没有对象的情况下直接调用，对于抽象类也一样。</em></p><p>范例如下：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public static void print(){        System.out.println(&quot;Hello World !&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A.print();    }}</code></pre><p>运行结果：</p><pre><code>Hello World !</code></pre><p><strong>（5）有时候由于抽象类中只需要一个特定的系统子类操作，所以可以忽略掉外部子类。这样的设计在系统类库中会比较常见，目的是对用户隐藏不需要知道的子类。</strong> </p><p>范例如下：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public abstract void print();    private static class B extends A{//内部抽象类子类        public void print(){//覆写抽象类的方法            System.out.println(&quot;Hello World !&quot;);        }    }    //这个方法不受实例化对象的控制    public static A getInstance(){        return new B();    }}public class TestDemo {    public static void main(String[] args) {        //此时取得抽象类对象的时候完全不需要知道B类这个子类的存在        A a = A.getInstance();        a.print();    }}</code></pre><p>运行结果：</p><pre><code>Hello World !</code></pre><h2 id="四、抽象类的应用——模板设计模式"><a href="#四、抽象类的应用——模板设计模式" class="headerlink" title="四、抽象类的应用——模板设计模式"></a>四、抽象类的应用——模板设计模式</h2><p>例如，现在有三类事物： </p><p>（1）机器人：充电，工作； </p><p>（2）人：吃饭，工作，睡觉； </p><p>（3）猪：进食，睡觉。 </p><p>现要求实现一个程序，可以实现三种不同事物的行为。</p><p>先定义一个抽象行为类：</p><pre><code>package com.wz.abstractdemo;public abstract class Action{    public static final int EAT = 1 ;    public static final int SLEEP = 3 ;    public static final int WORK = 5 ;    public abstract void eat();    public abstract void sleep();    public abstract void work();    public void commond(int flags){      switch(flags){        case EAT:            this.eat();            break;        case SLEEP:            this.sleep();            break;        case WORK:            this.work();            break;        case EAT + SLEEP:            this.eat();            this.sleep();            break;        case SLEEP + WORK:            this.sleep();            this.work();            break;        default:            break;        }    }}</code></pre><p>定义一个机器人的类：</p><pre><code>package com.wz.abstractdemo;public class Robot extends Action{    @Override    public void eat() {        System.out.println(&quot;机器人充电&quot;);    }    @Override    public void sleep() {    }    @Override    public void work() {        System.out.println(&quot;机器人工作&quot;);    }}</code></pre><p>定义一个人的类：</p><pre><code>package com.wz.abstractdemo;public class Human extends Action{    @Override    public void eat() {        System.out.println(&quot;人吃饭&quot;);    }    @Override    public void sleep() {        System.out.println(&quot;人睡觉&quot;);    }    @Override    public void work() {        System.out.println(&quot;人工作&quot;);    }}</code></pre><p>定义一个猪的类:</p><pre><code>package com.wz.abstractdemo;public class Pig extends Action{    @Override    public void eat() {        System.out.println(&quot;猪进食&quot;);    }    @Override    public void sleep() {        System.out.println(&quot;猪睡觉&quot;);    }    @Override    public void work() {    }}</code></pre><p>测试主类：</p><pre><code>package com.wz.abstractdemo;public class AbstractDemo {    public static void main(String[] args) {        fun(new Robot());        fun(new Human());        fun(new Pig());    }    public static void fun(Action act){        act.commond(Action.EAT);        act.commond(Action.SLEEP);        act.commond(Action.WORK);    }}</code></pre><p>运行结果：</p><pre><code>机器人充电机器人工作人吃饭人睡觉人工作猪进食猪睡觉</code></pre><p><strong>所有的子类如果要想正常的完成操作，必须按照指定的方法进行覆写才可以，而这个时候抽象类所起的功能就是一个类定义模板的功能。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/wei_zhi/article/details/52736350/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/wei_zhi/article/details/52736350/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Volatile关键字</title>
    <link href="https://mlone.top/post/3fbd301a.html"/>
    <id>https://mlone.top/post/3fbd301a.html</id>
    <published>2018-09-17T14:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.783Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></p><a id="more"></a><p>　　volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p><p>　　volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p><p>　　以下是本文的目录大纲：</p><p>　　一.内存模型的相关概念</p><p>　　二.并发编程中的三个概念</p><p>　　三.Java内存模型</p><p>　　四..深入剖析volatile关键字</p><p>　　五.使用volatile关键字的场景</p><h2 id="一-内存模型的相关概念"><a href="#一-内存模型的相关概念" class="headerlink" title="一.内存模型的相关概念"></a>一.内存模型的相关概念</h2><p>　　大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p><p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p><pre><code>i = i + 1;</code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p><p>　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p><p>　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p><p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p><p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p><p>　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p><p>　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p><p>　　1）通过在总线加LOCK#锁的方式</p><p>　　2）通过缓存一致性协议</p><p>　　这2种方式都是硬件层面上提供的方式。</p><p>　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p><p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p><p>　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><p><img src="/assets/blogImg/4/8.jpg" alt="图片8"></p><h2 id="二-并发编程中的三个概念"><a href="#二-并发编程中的三个概念" class="headerlink" title="二.并发编程中的三个概念"></a>二.并发编程中的三个概念</h2><p>　　在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>　　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>　　一个很经典的例子就是银行账户转账问题：</p><p>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p><p>　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p><p>　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p><p>　　同样地反映到并发编程中会出现什么结果呢？</p><p>　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p><pre><code>i = 9;</code></pre><p>　　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p><p>　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>　　举个简单的例子，看下面这段代码：</p><pre><code>//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i;</code></pre><p>　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p><p>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p><pre><code>int i = 0;              boolean flag = false;i = 1;                //语句1  flag = true;          //语句2</code></pre><p>　　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p><p>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p><p>　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p><pre><code>int a = 10;    //语句1int r = 2;    //语句2a = a + 3;    //语句3r = a*a;     //语句4</code></pre><p>这段代码有4个语句，那么可能的一个执行顺序是：</p><p><img src="/assets/blogImg/4/9.jpg" alt="图片9"></p><p>　　那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p><p>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p><p>　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p><pre><code>//线程1:context = loadContext();   //语句1inited = true;             //语句2//线程2:while(!inited ){  sleep()}doSomethingwithconfig(context);</code></pre><p>　　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p> 　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p><p>　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><h2 id="三-Java内存模型"><a href="#三-Java内存模型" class="headerlink" title="三.Java内存模型"></a>三.Java内存模型</h2><p>　　在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p><p>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p><p>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p><p>　　举个简单的例子：在java中，执行下面这个语句：</p><pre><code>i  = 10;</code></pre><p>　　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p><p>　　那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p><h3 id="1-原子性-1"><a href="#1-原子性-1" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p><p>　　请分析以下哪些操作是原子性操作：</p><pre><code>x = 10;         //语句1y = x;         //语句2x++;           //语句3x = x + 1;     //语句4</code></pre><p> 　　咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p><p>　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p><p>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p><p>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p><p> 　　所以上面4个语句只有语句1的操作具备原子性。</p><p>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><p>　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p><p>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h3 id="2-可见性-1"><a href="#2-可见性-1" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>　　对于可见性，Java提供了volatile关键字来保证可见性。</p><p>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h3 id="3-有序性-1"><a href="#3-有序性-1" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>　　另外，<strong>Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</strong></p><p>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><p>　　这8条原则摘自《深入理解Java虚拟机》。</p><p>　　这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p><p>　　下面我们来解释一下前4条规则：</p><p>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p><p>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p><p>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p><p>　　第四条规则实际上就是体现happens-before原则具备传递性。</p><h2 id="四-深入剖析volatile关键字"><a href="#四-深入剖析volatile关键字" class="headerlink" title="四.深入剖析volatile关键字"></a>四.深入剖析volatile关键字</h2><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p><h3 id="1-volatile关键字的两层语义"><a href="#1-volatile关键字的两层语义" class="headerlink" title="1.volatile关键字的两层语义"></a>1.volatile关键字的两层语义</h3><p>　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><p>　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>　　2）禁止进行指令重排序。</p><p>　　先看一段代码，假如线程1先执行，线程2后执行：</p><pre><code>//线程1boolean stop = false;while(!stop){    doSomething();}//线程2stop = true;</code></pre><p>　　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p><p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p><p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p><p>　　但是用volatile修饰之后就变得不一样了：</p><p>　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p><p>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p><p>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p><p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p><p>　　那么线程1读取到的就是最新的正确的值。</p><h3 id="2-volatile保证原子性吗？"><a href="#2-volatile保证原子性吗？" class="headerlink" title="2.volatile保证原子性吗？"></a>2.volatile保证原子性吗？</h3><p>　　从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p><p>　　下面看一个例子：</p><pre><code>public class Test {    public volatile int inc = 0;    public void increase() {        inc++;    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p> 　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p><p>　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p><p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p><p>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p><p>　　假如某个时刻变量inc的值为10，</p><p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p><p>　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p><p>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p><p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1。</p><p>　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p><p>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p><p>　　把上面的代码改成以下任何一种都可以达到效果：</p><p>　　采用synchronized：</p><pre><code>public class Test {    public  int inc = 0;    public synchronized void increase() {        inc++;    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p>　　采用Lock：</p><pre><code>public class Test {    public  int inc = 0;    Lock lock = new ReentrantLock();    public  void increase() {        lock.lock();        try {            inc++;        } finally{            lock.unlock();        }    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p>　　采用AtomicInteger：</p><pre><code>public class Test {    public  AtomicInteger inc = new AtomicInteger();    public  void increase() {        inc.getAndIncrement();    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p>　　在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p><h3 id="3-volatile能保证有序性吗？"><a href="#3-volatile能保证有序性吗？" class="headerlink" title="3.volatile能保证有序性吗？"></a>3.volatile能保证有序性吗？</h3><p>　　在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p><p>　　volatile关键字禁止指令重排序有两层意思：</p><p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p><p>　　可能上面说的比较绕，举个简单的例子：</p><pre><code>//x、y为非volatile变量//flag为volatile变量x = 2;        //语句1y = 0;        //语句2flag = true;  //语句3x = 4;         //语句4y = -1;       //语句5</code></pre><p> 　　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p><p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><p>　　那么我们回到前面举的一个例子：</p><pre><code>//线程1:context = loadContext();   //语句1inited = true;             //语句2//线程2:while(!inited ){  sleep()}doSomethingwithconfig(context);</code></pre><p>　　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p><p>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p><h3 id="4-volatile的原理和实现机制"><a href="#4-volatile的原理和实现机制" class="headerlink" title="4.volatile的原理和实现机制"></a>4.volatile的原理和实现机制</h3><p>　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p><p>　　下面这段话摘自《深入理解Java虚拟机》：</p><p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>　　2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><h2 id="五-使用volatile关键字的场景"><a href="#五-使用volatile关键字的场景" class="headerlink" title="五.使用volatile关键字的场景"></a>五.使用volatile关键字的场景</h2><p>　　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p><p>　　1）对变量的写操作不依赖于当前值</p><p>　　2）该变量没有包含在具有其他变量的不变式中</p><p>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p><p>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>　　下面列举几个Java中使用volatile的几个场景。</p><h3 id="1-状态标记量"><a href="#1-状态标记量" class="headerlink" title="1.状态标记量"></a>1.状态标记量</h3><pre><code>volatile boolean flag = false;while(!flag){    doSomething();}public void setFlag() {    flag = true;}</code></pre><p>.</p><pre><code>volatile boolean inited = false;//线程1:context = loadContext();  inited = true;            //线程2:while(!inited ){sleep()}doSomethingwithconfig(context);</code></pre><h3 id="2-double-check"><a href="#2-double-check" class="headerlink" title="2.double check"></a>2.double check</h3><pre><code>class Singleton{    private volatile static Singleton instance = null;    private Singleton() {    }    public static Singleton getInstance() {        if(instance==null) {            synchronized (Singleton.class) {                if(instance==null)                    instance = new Singleton();            }        }        return instance;    }}</code></pre><p>　　至于为何需要这么写请参考：</p><p>　　《Java 中的双重检查（Double-Check）》<a href="http://blog.csdn.net/dl88250/article/details/5439024" target="_blank" rel="noopener">http://blog.csdn.net/dl88250/article/details/5439024</a></p><p>　　和<a href="http://www.iteye.com/topic/652440" target="_blank" rel="noopener">http://www.iteye.com/topic/652440</a></p><p>　　参考资料：</p><p>　　《Java编程思想》</p><p>　　《深入理解Java虚拟机》</p><p>　　<a href="http://jiangzhengjun.iteye.com/blog/652532" target="_blank" rel="noopener">http://jiangzhengjun.iteye.com/blog/652532</a></p><p>　　<a href="http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p><p>　　<a href="http://ifeve.com/volatile/" target="_blank" rel="noopener">http://ifeve.com/volatile/</a></p><p>　　<a href="http://blog.csdn.net/ccit0519/article/details/11241403" target="_blank" rel="noopener">http://blog.csdn.net/ccit0519/article/details/11241403</a></p><p>　　<a href="http://blog.csdn.net/ns_code/article/details/17101369" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/17101369</a></p><p>　　<a href="http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html" target="_blank" rel="noopener">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p><p>　　<a href="http://www.cppblog.com/elva/archive/2011/01/21/139019.html" target="_blank" rel="noopener">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p><p>　　<a href="http://ifeve.com/volatile-array-visiblity/" target="_blank" rel="noopener">http://ifeve.com/volatile-array-visiblity/</a></p><p>　　<a href="http://www.bdqn.cn/news/201312/12579.shtml" target="_blank" rel="noopener">http://www.bdqn.cn/news/201312/12579.shtml</a></p><p>　　<a href="http://exploer.blog.51cto.com/7123589/1193399" target="_blank" rel="noopener">http://exploer.blog.51cto.com/7123589/1193399</a></p><p>　　<a href="http://www.cnblogs.com/Mainz/p/3556430.html" target="_blank" rel="noopener">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920373.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java并发编程：volatile关键字解析&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized锁机制</title>
    <link href="https://mlone.top/post/a9e12473.html"/>
    <id>https://mlone.top/post/a9e12473.html</id>
    <published>2018-09-17T11:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.780Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://zhh9106.iteye.com/blog/2151791" target="_blank" rel="noopener">https://zhh9106.iteye.com/blog/2151791</a></p><a id="more"></a><p>在java编程中，经常需要用到同步，而用得最多的也许是synchronized关键字了，下面看看这个关键字的用法。</p><p>因为synchronized关键字涉及到锁的概念，所以先来了解一些相关的锁知识。</p><p>java的内置锁：每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</p><p>java内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p><p>java的对象锁和类锁：java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的</p><p>上面已经对锁的一些概念有了一点了解，下面探讨synchronized关键字的用法。</p><p>synchronized的用法：synchronized修饰方法和synchronized修饰代码块。 </p><p>下面分别分析这两种用法在对象锁和类锁上的效果。</p><p>对象锁的synchronized修饰方法和代码块：</p><pre><code>1.public class TestSynchronized   2.{    3.    public void test1()   4.    {    5.         synchronized(this)   6.         {    7.              int i = 5;    8.              while( i-- &gt; 0)   9.              {    10.                   System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    11.                   try   12.                   {    13.                        Thread.sleep(500);    14.                   }   15.                   catch (InterruptedException ie)   16.                   {    17.                   }    18.              }    19.         }    20.    }    21.      22.    public synchronized void test2()   23.    {    24.         int i = 5;    25.         while( i-- &gt; 0)   26.         {    27.              System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    28.              try   29.              {    30.                   Thread.sleep(500);    31.              }   32.              catch (InterruptedException ie)   33.              {    34.              }    35.         }    36.    }    37.      38.    public static void main(String[] args)   39.    {    40.         final TestSynchronized myt2 = new TestSynchronized();    41.         Thread test1 = new Thread(  new Runnable() {  public void run() {  myt2.test1();  }  }, &quot;test1&quot;  );    42.         Thread test2 = new Thread(  new Runnable() {  public void run() { myt2.test2();   }  }, &quot;test2&quot;  );    43.         test1.start();;    44.         test2.start();    45.//         TestRunnable tr=new TestRunnable();  46.//         Thread test3=new Thread(tr);  47.//         test3.start();  48.    }   49.    50.}</code></pre><p>输出：</p><pre><code>1. test2 : 4  2. test2 : 3  3. test2 : 2  4. test2 : 1  5. test2 : 0  6. test1 : 4  7. test1 : 3  8. test1 : 2  9. test1 : 1  10. test1 : 0</code></pre><p>上述的代码，第一个方法时用了同步代码块的方式进行同步，传入的对象实例是this，表明是当前对象，当然，如果需要同步其他对象实例，也不可传入其他对象的实例；第二个方法是修饰方法的方式进行同步。因为第一个同步代码块传入的this，所以两个同步代码所需要获得的对象锁都是同一个对象锁，下面main方法时分别开启两个线程，分别调用test1和test2方法，那么两个线程都需要获得该对象锁，另一个线程必须等待。上面也给出了运行的结果可以看到：直到test2线程执行完毕，释放掉锁，test1线程才开始执行。</p><p><em>（可能这个结果有人会有疑问，代码里面明明是先开启test1线程，为什么先执行的是test2呢？这是因为java编译器在编译成字节码的时候，会对代码进行一个重排序，也就是说，编译器会根据实际情况对代码进行一个合理的排序，编译前代码写在前面，在编译后的字节码不一定排在前面，所以这种运行结果是正常的， 这里是题外话，最主要是检验synchronized的用法的正确性）</em></p><p>如果我们把test2方法的synchronized关键字去掉，执行结果会如何呢？</p><pre><code>1.test1 : 4  2.test2 : 4  3.test2 : 3  4.test1 : 3  5.test1 : 2  6.test2 : 2  7.test2 : 1  8.test1 : 1  9.test2 : 0  10.test1 : 0</code></pre><p>上面是执行结果，我们可以看到，结果输出是交替着进行输出的，这是因为，某个线程得到了对象锁，但是另一个线程还是可以访问没有进行同步的方法或者代码。进行了同步的方法（加锁方法）和没有进行同步的方法（普通方法）是互不影响的，一个线程进入了同步方法，得到了对象锁，其他线程还是可以访问那些没有同步的方法（普通方法）。</p><p><em>这里涉及到内置锁的一个概念（此概念出自java并发编程实战第二章）：对象的内置锁和对象的状态之间是没有内在的关联的，虽然大多数类都将内置锁用做一种有效的加锁机制，但对象的域并不一定通过内置锁来保护。当获取到与对象关联的内置锁时，并不能阻止其他线程访问该对象，当某个线程获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，是为了免去显式地创建锁对象。</em></p><p>所以synchronized只是一个内置锁的加锁机制，当某个方法加上synchronized关键字后，就表明要获得该内置锁才能执行，并不能阻止其他线程访问不需要获得该内置锁的方法。</p><p>类锁的修饰（静态）方法和代码块：</p><pre><code>1.public class TestSynchronized   2.{    3.    public void test1()   4.    {    5.         synchronized(TestSynchronized.class)   6.         {    7.              int i = 5;    8.              while( i-- &gt; 0)   9.              {    10.                   System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    11.                   try   12.                   {    13.                        Thread.sleep(500);    14.                   }   15.                   catch (InterruptedException ie)   16.                   {    17.                   }    18.              }    19.         }    20.    }    21.      22.    public static synchronized void test2()   23.    {    24.         int i = 5;    25.         while( i-- &gt; 0)   26.         {    27.              System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    28.              try   29.              {    30.                   Thread.sleep(500);    31.              }   32.              catch (InterruptedException ie)   33.              {    34.              }    35.         }    36.    }    37.      38.    public static void main(String[] args)   39.    {    40.         final TestSynchronized myt2 = new TestSynchronized();    41.         Thread test1 = new Thread(  new Runnable() {  public void run() {  myt2.test1();  }  }, &quot;test1&quot;  );    42.         Thread test2 = new Thread(  new Runnable() {  public void run() { TestSynchronized.test2();   }  }, &quot;test2&quot;  );    43.         test1.start();    44.         test2.start();    45.//         TestRunnable tr=new TestRunnable();  46.//         Thread test3=new Thread(tr);  47.//         test3.start();  48.    }   49.    50.}</code></pre><p>输出：</p><pre><code>1.test1 : 4  2.test1 : 3  3.test1 : 2  4.test1 : 1  5.test1 : 0  6.test2 : 4  7.test2 : 3  8.test2 : 2  9.test2 : 1  10.test2 : 0</code></pre><p>其实，类锁修饰方法和代码块的效果和对象锁是一样的，因为类锁只是一个抽象出来的概念，只是为了区别静态方法的特点，因为静态方法是所有对象实例共用的，所以对应着synchronized修饰的静态方法的锁也是唯一的，所以抽象出来个类锁。其实这里的重点在下面这块代码，synchronized同时修饰静态和非静态方法</p><pre><code>1.public class TestSynchronized   2.{    3.    public synchronized void test1()   4.    {    5.              int i = 5;    6.              while( i-- &gt; 0)   7.              {    8.                   System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    9.                   try   10.                   {    11.                        Thread.sleep(500);    12.                   }   13.                   catch (InterruptedException ie)   14.                   {    15.                   }    16.              }    17.    }    18.      19.    public static synchronized void test2()   20.    {    21.         int i = 5;    22.         while( i-- &gt; 0)   23.         {    24.              System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    25.              try   26.              {    27.                   Thread.sleep(500);    28.              }   29.              catch (InterruptedException ie)   30.              {    31.              }    32.         }    33.    }    34.      35.    public static void main(String[] args)   36.    {    37.         final TestSynchronized myt2 = new TestSynchronized();    38.         Thread test1 = new Thread(  new Runnable() {  public void run() {  myt2.test1();  }  }, &quot;test1&quot;  );    39.         Thread test2 = new Thread(  new Runnable() {  public void run() { TestSynchronized.test2();   }  }, &quot;test2&quot;  );    40.         test1.start();    41.         test2.start();    42.//         TestRunnable tr=new TestRunnable();  43.//         Thread test3=new Thread(tr);  44.//         test3.start();  45.    }   46.    47.}  </code></pre><p>输出：</p><pre><code>1.test1 : 4  2.test2 : 4  3.test1 : 3  4.test2 : 3  5.test2 : 2  6.test1 : 2  7.test2 : 1  8.test1 : 1  9.test1 : 0  10.test2 : 0</code></pre><p><strong>上面代码synchronized同时修饰静态方法和实例方法，但是运行结果是交替进行的，这证明了类锁和对象锁是两个不一样的锁，控制着不同的区域，它们是互不干扰的。同样，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。</strong></p><p><strong>到这里，对synchronized的用法已经有了一定的了解。这时有一个疑问，既然有了synchronized修饰方法的同步方式，为什么还需要synchronized修饰同步代码块的方式呢？而这个问题也是synchronized的缺陷所在</strong></p><p>synchronized的缺陷：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。</p><p>当然同步方法和同步代码块都会有这样的缺陷，只要用了synchronized关键字就会有这样的风险和缺陷。既然避免不了这种缺陷，那么就应该将风险降到最低。这也是同步代码块在某种情况下要优于同步方法的方面。例如在某个类的方法里面：这个类里面声明了一个对象实例，SynObject so=new SynObject()；在某个方法里面调用了这个实例的方法so.testsy();但是调用这个方法需要进行同步，不能同时有多个线程同时执行调用这个方法。</p><p>这时如果直接用synchronized修饰调用了so.testsy();代码的方法，那么当某个线程进入了这个方法之后，这个对象其他同步方法都不能给其他线程访问了。假如这个方法需要执行的时间很长，那么其他线程会一直阻塞，影响到系统的性能。</p><p>如果这时用synchronized来修饰代码块：synchronized（so）{so.testsy();}，那么这个方法加锁的对象是so这个对象，跟执行这行代码的对象没有关系，当一个线程执行这个方法时，这对其他同步方法时没有影响的，因为他们持有的锁都完全不一样。</p><p>不过这里还有一种特例，就是上面演示的第一个例子，对象锁synchronized同时修饰方法和代码块，这时也可以体现到同步代码块的优越性，如果test1方法同步代码块后面有非常多没有同步的代码，而且有一个100000的循环，这导致test1方法会执行时间非常长，那么如果直接用synchronized修饰方法，那么在方法没执行完之前，其他线程是不可以访问test2方法的，但是如果用了同步代码块，那么当退出代码块时就已经释放了对象锁，当线程还在执行test1的那个100000的循环时，其他线程就已经可以访问test2方法了。这就让阻塞的机会或者线程更少。让系统的性能更优越。</p><p>一个类的对象锁和另一个类的对象锁是没有关联的，当一个线程获得A类的对象锁时，它同时也可以获得B类的对象锁。</p><p>可能上面只有理论和代码，对刚接触的人比较难理解，下面举一个例子，</p><p>这个例子是摘自博客：<a href="http://www.cnblogs.com/GnagWang/archive/2011/02/27/1966606.html" target="_blank" rel="noopener">http://www.cnblogs.com/GnagWang/archive/2011/02/27/1966606.html</a></p><p>打个比方：一个object就像一个大房子，大门永远打开。房子里有 很多房间（也就是方法）。</p><p>这些房间有上锁的（synchronized方法）， 和不上锁之分（普通方法）。房门口放着一把钥匙（key），这把钥匙可以打开所有上锁的房间。</p><p>另外我把所有想调用该对象方法的线程比喻成想进入这房子某个 房间的人。所有的东西就这么多了，下面我们看看这些东西之间如何作用的。</p><p>在此我们先来明确一下我们的前提条件。该对象至少有一个synchronized方法，否则这个key还有啥意义。当然也就不会有我们的这个主题了。</p><p>一个人想进入某间上了锁的房间，他来到房子门口，看见钥匙在那儿（说明暂时还没有其他人要使用上锁的 房间）。于是他走上去拿到了钥匙，并且按照自己 的计划使用那些房间。注意一点，他每次使用完一次上锁的房间后会马上把钥匙还回去。即使他要连续使用两间上锁的房间，中间他也要把钥匙还回去，再取回来。</p><p>因此，普通情况下钥匙的使用原则是：“随用随借，用完即还。”</p><p>这时其他人可以不受限制的使用那些不上锁的房间，一个人用一间可以，两个人用一间也可以，没限制。但是如果当某个人想要进入上锁的房间，他就要跑到大门口去看看了。有钥匙当然拿了就走，没有的话，就只能等了。</p><p>要是很多人在等这把钥匙，等钥匙还回来以后，谁会优先得到钥匙？Not guaranteed。象前面例子里那个想连续使用两个上锁房间的家伙，他中间还钥匙的时候如果还有其他人在等钥匙，那么没有任何保证这家伙能再次拿到。 （JAVA规范在很多地方都明确说明不保证，像Thread.sleep()休息后多久会返回运行，相同优先权的线程那个首先被执行，当要访问对象的锁被 释放后处于等待池的多个线程哪个会优先得到，等等。我想最终的决定权是在JVM，之所以不保证，就是因为JVM在做出上述决定的时候，绝不是简简单单根据 一个条件来做出判断，而是根据很多条。而由于判断条件太多，如果说出来可能会影响JAVA的推广，也可能是因为知识产权保护的原因吧。SUN给了个不保证 就混过去了。无可厚非。但我相信这些不确定，并非完全不确定。因为计算机这东西本身就是按指令运行的。即使看起来很随机的现象，其实都是有规律可寻。学过 计算机的都知道，计算机里随机数的学名是伪随机数，是人运用一定的方法写出来的，看上去随机罢了。另外，或许是因为要想弄的确太费事，也没多大意义，所 以不确定就不确定了吧。）</p><p>再来看看同步代码块。和同步方法有小小的不同。</p><p>1.从尺寸上讲，同步代码块比同步方法小。你可以把同步代码块看成是没上锁房间里的一块用带锁的屏风隔开的空间。</p><p>2.同步代码块还可以人为的指定获得某个其它对象的key。就像是指定用哪一把钥匙才能开这个屏风的锁，你可以用本房的钥匙；你也可以指定用另一个房子的钥匙才能开，这样的话，你要跑到另一栋房子那儿把那个钥匙拿来，并用那个房子的钥匙来打开这个房子的带锁的屏风。</p><p> 记住你获得的那另一栋房子的钥匙，并不影响其他人进入那栋房子没有锁的房间。</p><p> 为什么要使用同步代码块呢？我想应该是这样的：首先对程序来讲同步的部分很影响运行效率，而一个方法通常是先创建一些局部变量，再对这些变量做一些 操作，如运算，显示等等；而同步所覆盖的代码越多，对效率的影响就越严重。因此我们通常尽量缩小其影响范围。</p><p>如何做？同步代码块。我们只把一个方法中该同 步的地方同步，比如运算。</p><p> 另外，同步代码块可以指定钥匙这一特点有个额外的好处，是可以在一定时期内霸占某个对象的key。还记得前面说过普通情况下钥匙的使用原则吗。现在不是普通情况了。你所取得的那把钥匙不是永远不还，而是在退出同步代码块时才还。</p><p>  还用前面那个想连续用两个上锁房间的家伙打比方。怎样才能在用完一间以后，继续使用另一间呢。用同步代码块吧。先创建另外一个线程，做一个同步代码 块，把那个代码块的锁指向这个房子的钥匙。然后启动那个线程。只要你能在进入那个代码块时抓到这房子的钥匙，你就可以一直保留到退出那个代码块。也就是说 你甚至可以对本房内所有上锁的房间遍历，甚至再sleep(10<em>60</em>1000)，而房门口却还有1000个线程在等这把钥匙呢。很过瘾吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://zhh9106.iteye.com/blog/2151791&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhh9106.iteye.com/blog/2151791&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>接口回调</title>
    <link href="https://mlone.top/post/b027d2d7.html"/>
    <id>https://mlone.top/post/b027d2d7.html</id>
    <published>2018-09-17T10:07:18.000Z</published>
    <updated>2019-02-25T14:52:05.176Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/xiaanming/article/details/8703708" target="_blank" rel="noopener">https://blog.csdn.net/xiaanming/article/details/8703708</a></p><a id="more"></a><p>以前不理解什么叫回调，天天听人家说加一个回调方法啥的，心里想我草，什么叫回调方法啊？然后自己就在网上找啊找啊找，找了很多也不是很明白，现在知道了，所谓回调：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，这样子说你是不是有点晕晕的，其实我刚开始也是这样不理解，看了人家说比较经典的回调方式：</p><ul><li>Class A实现接口CallBack callback——背景1</li><li>Class A中包含一个class B的引用b ——背景2</li><li>Class B有一个参数为callback的方法f(CallBack callback) ——背景3</li></ul><p>A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C</p><p>然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D</p><p>大家都喜欢用打电话的例子，好吧，为了跟上时代，我也用这个例子好了，我这个例子采用异步加回调:</p><p>有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2.</p><pre><code>/** * 这是一个回调接口 * @author xiaanming */public interface CallBack {   /**     * 这个是小李知道答案时要调用的函数告诉小王，也就是回调函数    * @param result 是答案     */    public void solve(String result);}</code></pre><p>.</p><pre><code>/** * 这个是小王 * @author xiaanming * 实现了一个回调接口CallBack，相当于-----&gt;背景一 */public class Wang implements CallBack {    /**     * 小李对象的引用     * 相当于-----&gt;背景二     */    private Li li;     /**     * 小王的构造方法，持有小李的引用     * @param li     */    public Wang(Li li){        this.li = li;    }    /**     * 小王通过这个方法去问小李的问题     * @param question  就是小王要问的问题,1 + 1 = ?     */    public void askQuestion(final String question){        //这里用一个线程就是异步，        new Thread(new Runnable() {            @Override            public void run() {                /**                 * 小王调用小李中的方法，在这里注册回调接口                 * 这就相当于A类调用B的方法C                 */                li.executeMessage(Wang.this, question);             }        }).start();        //小网问完问题挂掉电话就去干其他的事情了，诳街去了        play();    }    public void play(){        System.out.println(&quot;我要逛街去了&quot;);    }    /**     * 小李知道答案后调用此方法告诉小王，就是所谓的小王的回调方法     */    @Override    public void solve(String result) {        System.out.println(&quot;小李告诉小王的答案是---&gt;&quot; + result);    }}</code></pre><p>.</p><pre><code>/** * 这个就是小李啦 * @author xiaanming * */public class Li {    /**     * 相当于B类有参数为CallBack callBack的f()----&gt;背景三     * @param callBack       * @param question  小王问的问题     */    public void executeMessage(CallBack callBack, String question){        System.out.println(&quot;小王问的问题---&gt;&quot; + question);        //模拟小李办自己的事情需要很长时间        for(int i=0; i&lt;10000;i++){        }        /**         * 小李办完自己的事情之后想到了答案是2         */        String result = &quot;答案是2&quot;;        /**         * 于是就打电话告诉小王，调用小王中的方法         * 这就相当于B类反过来调用A的方法D         */        callBack.solve(result);     }}</code></pre><p>.</p><pre><code>/*** 测试类* @author xiaanming*/public class Test {    public static void main(String[]args){        /**         * new 一个小李         */        Li li = new Li();        /**         * new 一个小王         */        Wang wang = new Wang(li);        /**         * 小王问小李问题         */        wang.askQuestion(&quot;1 + 1 = ?&quot;);    }}</code></pre><p>通过上面的那个例子你是不是差不多明白了回调机制呢，上面是一个异步回调，我们看看同步回调吧，onClick（）方法</p><p>现在来分析分析下Android View的点击方法onclick（）;我们知道onclick()是一个回调方法，当用户点击View就执行这个方法，我们用Button来举例好了:</p><pre><code>//这个是View的一个回调接口/** * Interface definition for a callback to be invoked when a view is clicked.  */public interface OnClickListener {    /**     * Called when a view has been clicked.     *     * @param v The view that was clicked.     */    void onClick(View v);}</code></pre><p>.</p><pre><code>package com.example.demoactivity;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;/** * 这个就相当于Class A * @author xiaanming * 实现了 OnClickListener接口----&gt;背景一 */public class MainActivity extends Activity implements OnClickListener{    /**     * Class A 包含Class B的引用-----&gt;背景二     */    private Button button;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        button = (Button)findViewById(R.id.button1);        /**         * Class A 调用View的方法,而Button extends View-----&gt;A类调用B类的某个方法 C         */        button.setOnClickListener(this);    }    /**     * 用户点击Button时调用的回调函数，你可以做你要做的事     * 这里我做的是用Toast提示OnClick     */    @Override    public void onClick(View v) {        Toast.makeText(getApplication(), &quot;OnClick&quot;, Toast.LENGTH_LONG).show();    }}</code></pre><p>下面是View类的setOnClickListener方法，就相当于B类咯，只把关键代码贴出来</p><pre><code>/**  * 这个View就相当于B类  * @author xiaanming  *  */public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {    /**     * Listener used to dispatch click events.     * This field should be made private, so it is hidden from the SDK.     * {@hide}     */    protected OnClickListener mOnClickListener;    /**     * setOnClickListener()的参数是OnClickListener接口------&gt;背景三     * Register a callback to be invoked when this view is clicked. If this view is not     * clickable, it becomes clickable.     *     * @param l The callback that will run     *     * @see #setClickable(boolean)     */    public void setOnClickListener(OnClickListener l) {        if (!isClickable()) {            setClickable(true);        }        mOnClickListener = l;    }    /**     * Call this view&apos;s OnClickListener, if it is defined.     *     * @return True there was an assigned OnClickListener that was called, false     *         otherwise is returned.     */    public boolean performClick() {        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);        if (mOnClickListener != null) {            playSoundEffect(SoundEffectConstants.CLICK);            //这个不就是相当于B类调用A类的某个方法D，这个D就是所谓的回调方法咯            mOnClickListener.onClick(this);            return true;        }        return false;    }}</code></pre><p>这个例子就是Android典型的回调机制，看完这个你是不是更进一步的理解了回调机制呢？ 线程run()也是一个回调方法，当执行Thread的start（）方法就会回调这个run()方法，还有处理消息都比较经典等等</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/xiaanming/article/details/8703708&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/xiaanming/article/details/8703708&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="接口回调" scheme="https://mlone.top/tags/%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>上转型对象</title>
    <link href="https://mlone.top/post/56fd5bd6.html"/>
    <id>https://mlone.top/post/56fd5bd6.html</id>
    <published>2018-09-17T00:07:18.000Z</published>
    <updated>2019-02-25T10:34:05.450Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/lyt_7cs1dn9/article/details/54908734" target="_blank" rel="noopener">https://blog.csdn.net/lyt_7cs1dn9/article/details/54908734</a></p><a id="more"></a><h2 id="1、-定义"><a href="#1、-定义" class="headerlink" title="1、 定义"></a>1、 定义</h2><p>如果B类是A类的子类或间接子类，当用B类创建对象b并将这个对象b的引用赋给A类对象a时，如：</p><pre><code>A a;a = new B();</code></pre><p>或者</p><pre><code>A a;B b = new B();a = b;</code></pre><p>则称A类对象a是子类B对象b的上转型对象。 </p><h2 id="2、-性质"><a href="#2、-性质" class="headerlink" title="2、 性质"></a>2、 性质</h2><ul><li><p>对象b的上转型a的实体是有子类B创建的，但是上转型对象会失去子类B的一些属性和功能。上转型对象具有以下特点：</p></li><li><p>上转型对象不能操作子类新增加的成员变量，不能使用子类新增的方法。即为较子类B失去一些属性和功能，这些属性和功能是新增的。 </p></li><li><p>上转型对象可以操作子类继承或隐藏的成员变量，也可以使用子类继承的或重写的方法。即为上转型对象可以操纵父类原有的属性和功能，无论这些方法是否被重写。</p></li><li><p>上转型对象调用方法时，就是调用子类继承和重写过的方法。而不会是新增的方法，也不是父类原有的方法。 </p></li><li><p>可以将对象的上转型对象再强制转换到一个子类对象，强制转换过的对象具有子类所有属性和功能。</p></li></ul><h2 id="3、举例"><a href="#3、举例" class="headerlink" title="3、举例"></a>3、举例</h2><p>如：</p><pre><code>OutputStream output;output = new FileOutputStream(filename);</code></pre><p>并且根据Java API知：</p><pre><code>java.lang.Object      java.io.OutputStream         java.io.FileOutputStream</code></pre><p>这时，output就是上转型对象啦。有什么特殊呢？就是output可以使用FileOutputStream从父类OutputStream那里继承来的方法和重写的方法，而不能使用子类FileOutputStream自己新增的方法啦。最后，这种方法是很常用的哦。。。当父类有很多子类时，就能实现方法的多态。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/lyt_7cs1dn9/article/details/54908734&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/lyt_7cs1dn9/article/details/54908734&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="语法" scheme="https://mlone.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java中的传值与传引用</title>
    <link href="https://mlone.top/post/92f278e5.html"/>
    <id>https://mlone.top/post/92f278e5.html</id>
    <published>2018-09-16T10:01:55.000Z</published>
    <updated>2019-02-25T10:25:33.778Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/zhangj95/p/4184180.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangj95/p/4184180.html</a></p><a id="more"></a><p>java函数中的传值和传引用问题一直是个比较“邪门”的问题，其实java函数中的参数都是传递值的，所不同的是对于基本数据类型传递的是参数的一份拷贝，对于类类型传递的是该类参数的引用的拷贝，当在函数体中修改参数值时，无论是基本类型的参数还是引用类型的参数，修改的只是该参数的拷贝，不影响函数实参的值，如果修改的是引用类型的成员值，则该实参引用的成员值是可以改变的，例子如下。</p><p>首先是定义改变参数的:</p><pre><code>public static void changeInt(int i) {// 改变int型变量的函数    i = 100;}public static void changeString(String s) {// 改变String型变量的函数    s = &quot;changeString&quot;;}public static void changeModel(Model model) {// 改变Model型变量的函数    model = new Model();    model.i = 1;    model.s = &quot;changeModel&quot;;}public static void changeModel2(Model model) {// 改变Model型变量的成员的函数    model.i = 1;    model.s = &quot;changeModel&quot;;}// 类Modelclass Model {    public int i = 0;    public String s = &quot;no value&quot;;}// 测试程序public static void main(String[] args) {    int i = 0;    String s = &quot;hello&quot;;    Model model = new Model();    Model model2 = new Model();    changeInt(i);    System.out.println(&quot;i=&quot; + i);    changeString(s);    System.out.println(&quot;s=&quot; + s);    changeModel(model);    System.out.println(&quot;model:&quot; + model.s);    changeModel2(model2);    System.out.println(&quot;model2:&quot; + model2.s);}</code></pre><p>测试结果：</p><p>   i=0</p><p>   s=hello</p><p>   model:no value</p><p>   model2:changeModel</p><p>可以看出i没有改变，s也没有改变，mode也没有改变，model2的s改变了。</p><p>总结：</p><p><strong>java中的形参是复制实参的一份拷贝（对于引用型则是复制引用的拷贝）（在栈中的拷贝）</strong>，所以在函数中改变形参是无法改变实参的值的，改变引用只是将形参所代表的引用指向另外的新的对象，而实参的引用还指向原来的对象，改变形参引用的成员当然会影响实参引用成员的值，因为他们的引用都指向同一个对象。</p><p>原文地址：<a href="http://blog.sina.com.cn/s/blog_5198c7370100dut4.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_5198c7370100dut4.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/zhangj95/p/4184180.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zhangj95/p/4184180.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="语法" scheme="https://mlone.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>匿名内部类访问方法成员变量需要加final的原因及证明</title>
    <link href="https://mlone.top/post/be65bf03.html"/>
    <id>https://mlone.top/post/be65bf03.html</id>
    <published>2018-09-15T11:52:19.000Z</published>
    <updated>2019-02-23T12:13:23.169Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/wjw521wjw521/article/details/77333820" target="_blank" rel="noopener">https://blog.csdn.net/wjw521wjw521/article/details/77333820</a><br><a id="more"></a></p><p>在java编程中，没用的类定义太多对系统来说也是一个负担，这时候我们可以通过定义匿名内部类来简化编程，但匿名内部类访问外部方法的成员变量时都要求外部成员变量添加final修饰符，final修饰变量代表该变量只能被初始化一次，以后不能被修改。但为什么匿名内部类访问外部成员变量就不允许他修改了呢？<br>接下来这个例子应该足够把这些说清楚了：<br>示例代码：</p><pre><code>public class InnerFinalTest {    private static Test test0= null;    public static void main(String[] args) {        new InnerFinalTest().method1();        System.out.println(&quot;-------&quot;);        test0.test();    }    public void method1(){        final Test  test = new Test();            test0 = new Test(){            @Override            public void test(){                                System.out.println(&quot;匿名内部类：&quot; + test);                Field[] field = this.getClass().getDeclaredFields();                for (int i = 0; i &lt; field.length; i++) {                    System.out.println(field[i].getName());                }                }        };        InnerFinalTest ift = new InnerFinalTest();        ift.innerFinalTest(test0);        System.out.println(&quot;外部直接访问变量：&quot;+ test);    }    public void innerFinalTest(Test test){        test.test();            }}</code></pre><p>Test类无关紧要，不过还是贴一下吧</p><pre><code>public class Test {    public void test(){        System.out.println(&quot;啊啊啊啊啊！&quot; );    }}</code></pre><p>说明：<br>为什么我们要将被匿名内部类访问的变量定义成final呢？<br>首先，我们在InnerFinalTest类中定义了一个static变量test0:</p><pre><code>private static Test test0= null;</code></pre><p>该语句说明test0的生命周期和类一样</p><p>接下来在main方法中调用method1（），在method1（）中将我们定义的匿名内部类赋给了test0,这说明如果test0不往别处指的话，我们匿名内部类将被一直引用着，如同吃了九转大金丹，与天地同寿，与日月齐光，匿名内部类生命周期和InnerFinalTest类（匿名类的天地）相同了。</p><p>但是，method1（）调用完了他要释放资源了，所以method1（）方法中：</p><pre><code>final Test  test = new Test();</code></pre><p>test变量也要被释放了，test没了，但匿名内部类引用了test，如果java编译器不搞点小动作，他就没法玩儿了，因为匿名类的生命周期长，还使用着test，而外部变量先撤了，背后捅了匿名内部类一刀子。。。</p><p>匿名内部类说，就防着你这一招呢，所以叫编译器大哥帮忙搞了个小动作，明修栈道暗度陈仓，编译的时候，我自己把你给我的变量备份了一份，表面上看是我引用了你的变量，其实在运行期间我就用我自己备份的了。但是别人表面上看不知道我备份了一份，还以为我用的你的，如果不定义成final，变量在外面被修改了，我没改，那我的结果就会和预期不同，为了防止出现这种情况，所以要被定义成final。</p><p>上面实例代码运行结果：</p><p>匿名内部类：Test@40e455bf</p><p>this$0</p><p>val$test</p><p>外部直接访问变量：Test@40e455bf</p><p>匿名内部类：Test@40e455bf</p><p>this$0</p><p>val$test</p><p>我用反射证明了匿名内部类存在外部变量的备份val$test，其中因为变量是默认类型，所以使用getDeclaredFields得到所有匿名内部类运行期间存在的成员属性。</p><p>（注意，该成员属性在编码期间是不存在的，是编译器主动为匿名内部类添加的成员属性，所以可以通过反射在运行期间一窥究竟。）</p><p>如果去掉匿名内部类对外部变量的引用，如去掉以下代码：</p><pre><code>System.out.println(&quot;匿名内部类：&quot; + test);</code></pre><p>运行结果中会没有了val$test，这也再次证明了以上结论：<strong>匿名内部类备份了变量。</strong></p><p>通过外部变量和内部变量打印内容相同，说明两个变量test和val$test的变量引用指向的内存区域是相同的，（这里可以参考一下原型模式浅克隆）。指向相同对象，虽然对象不能修改，但对象中的属性可以修改，而匿名内部类变量和外部变量指向相同，自然值也同步修改了。</p><p>总结一下，逻辑应该是这样的：<strong>为了解决生命周期不同的问题，匿名内部类备份了变量，为了解决备份变量引出的问题，外部变量要被定义成final。匿名内部类使用final不是怕修改，是怕不能同步修改。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/wjw521wjw521/article/details/77333820&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/wjw521wjw521/article/details/77333820&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="内部类" scheme="https://mlone.top/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>字节流与字符流</title>
    <link href="https://mlone.top/post/2e5c77c2.html"/>
    <id>https://mlone.top/post/2e5c77c2.html</id>
    <published>2018-09-14T11:45:51.000Z</published>
    <updated>2019-02-27T09:53:37.761Z</updated>
    
    <content type="html"><![CDATA[<p>转载自:<a href="http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html" target="_blank" rel="noopener">http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html</a></p><a id="more"></a><p>先来看一下流的概念：</p><p>在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。</p><p><strong>程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。</strong></p><h2 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h2><p>在java.io包中操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。（这四个都是抽象类）</p><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><p>在Java中IO操作也是有相应步骤的，以文件操作为例，主要的操作流程如下：</p><ol><li>使用File类打开一个文件</li><li>通过字节流或字符流的子类，指定输出的位置</li><li>进行读/写操作</li><li>关闭输入/输出</li></ol><p><strong>IO操作属于资源操作，一定要记得关闭</strong></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流主要是操作<strong>byte类型数据，以byte数组为准</strong>，主要操作类就是OutputStream、InputStream</p><p>字节输出流：OutputStream</p><p>OutputStream是整个IO包中<strong>字节输出流的最大父类</strong>，此类的定义如下：</p><p><em>public abstract class OutputStream extends Object implements Closeable,Flushable</em></p><p>从以上的定义可以发现，此类是一个抽象类，如果想要使用此类的话，则首先必须通过子类实例化对象，那么如果现在要操作的是一个文件，则可以使用：FileOutputStream类。通过向上转型之后，可以为OutputStream实例化</p><p><strong>Closeable表示可以关闭的操作，因为程序运行到最后肯定要关闭</strong></p><p><strong>Flushable：表示刷新，清空内存中的数据</strong></p><p>FileOutputStream类的构造方法如下：</p><p>public FileOutputStream(File file)throws FileNotFoundException</p><p>写数据：</p><pre><code>import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建        String str=&quot;Hello World&quot;;        byte[] b=str.getBytes();        out.write(b);//因为是字节流，所以要转化成字节数组进行输出        out.close();    }}</code></pre><p>也可以一个字节一个字节进行输出，如下：</p><pre><code>import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建        String str=&quot;Hello World&quot;;        byte[] b=str.getBytes();        for(int i=0;i&lt;b.length;i++){            out.write(b[i]);        }        out.close();    }}</code></pre><p>以上输出只会进行覆盖，如果要追加的话，请看FileOutputStream类的另一个构造方法：</p><p><strong>public FileOutputStream(File file,boolean append)throws FileNotFoundException</strong></p><p>在构造方法中，如果将append的值设置为true，则表示在文件的末尾追加内容。</p><pre><code>import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        OutputStream out=new FileOutputStream(f,true);//追加内容        String str=&quot;\r\nHello World&quot;;        byte[] b=str.getBytes();        for(int i=0;i&lt;b.length;i++){            out.write(b[i]);        }        out.close();    }}</code></pre><p><strong>文件中换行为：\r\n</strong></p><h3 id="字节输入流：InputStream"><a href="#字节输入流：InputStream" class="headerlink" title="字节输入流：InputStream"></a>字节输入流：InputStream</h3><p>既然程序可以向文件中写入内容，则就可以通过InputStream从文件中把内容读取进来，首先来看InputStream类的定义：</p><p><em>public abstract class InputStream extends Object implements Closeable</em></p><p>与OutputStream类一样，InputStream本身也是一个抽象类，必须依靠其子类，如果现在是从文件中读取，就用FileInputStream来实现。</p><p>观察FileInputStream类的构造方法：</p><p><em>public FileInputStream(File file)throws FileNotFoundException</em></p><p>读文件：</p><pre><code>import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test12 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        InputStream in=new FileInputStream(f);        byte[] b=new byte[1024];        int len=in.read(b);        in.close();        System.out.println(new String(b,0,len));    }}</code></pre><p>但以上方法是有问题的，用不用开辟这么大的一个字节数组，明显是浪费嘛，我们可以根据文件的大小来定义字节数组的大小，File类中的方法：public long length()</p><pre><code>import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test13 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        InputStream in=new FileInputStream(f);        byte[] b=new byte[(int) f.length()];        in.read(b);        in.close();        System.out.println(new String(b));    }}</code></pre><p>我们换种方式，一个字节一个字节读入~</p><pre><code>import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test14 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        InputStream in=new FileInputStream(f);        byte[] b=new byte[(int) f.length()];        for(int i=0;i&lt;b.length;i++){            b[i]=(byte) in.read();        }        in.close();        System.out.println(new String(b));    }}</code></pre><p>但以上情况只适合知道输入文件的大小，不知道的话用如下方法：</p><pre><code>import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test15 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        InputStream in=new FileInputStream(f);        byte[] b=new byte[1024];        int temp=0;        int len=0;        while((temp=in.read())!=-1){//-1为文件读完的标志            b[len]=(byte) temp;            len++;        }        in.close();        System.out.println(new String(b,0,len));    }}</code></pre><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>在程序中一个字符等于两个字节，那么java提供了Reader、Writer两个<strong>专门操作字符流</strong>的类。</p><h3 id="字符输出流：Writer"><a href="#字符输出流：Writer" class="headerlink" title="字符输出流：Writer"></a>字符输出流：Writer</h3><p>Writer本身是一个字符流的输出类，此类的定义如下：</p><p><em>public abstract class Writer extends Object implements Appendable，Closeable，Flushable</em></p><p>此类本身也是一个抽象类，如果要使用此类，则肯定要使用其子类，此时如果是向文件中写入内容，所以应该使用FileWriter的子类。</p><p>FileWriter类的构造方法定义如下：</p><p><em>public FileWriter(File file)throws IOException</em></p><p>字符流的操作比字节流操作好在一点，就是可以直接输出字符串了，不用再像之前那样进行转换操作了。</p><p>写文件：</p><pre><code>import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Test16 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        Writer out=new FileWriter(f);        String str=&quot;Hello World&quot;;        out.write(str);        out.close();    }}</code></pre><p>在默认情况下再次输出会覆盖，追加的方法也是在构造函数上加上追加标记</p><pre><code>import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Test17 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        Writer out=new FileWriter(f,true);//追加        String str=&quot;\r\nHello World&quot;;        out.write(str);        out.close();    }}</code></pre><h3 id="字符输入流：Reader"><a href="#字符输入流：Reader" class="headerlink" title="字符输入流：Reader"></a>字符输入流：Reader</h3><p>Reader是使用字符的方式从文件中取出数据，Reader类的定义如下：</p><p><em>public abstract class Reader extends Objects implements Readable，Closeable</em></p><p>Reader本身也是抽象类，如果现在要从文件中读取内容，则可以直接使用FileReader子类。</p><p>FileReader的构造方法定义如下：</p><p><em>public FileReader(File file)throws FileNotFoundException</em></p><p>以字符数组的形式读取出数据：</p><pre><code>import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class Test18 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        Reader input=new FileReader(f);        char[] c=new char[1024];        int len=input.read(c);        input.close();        System.out.println(new String(c,0,len));    }}</code></pre><p>也可以用循环方式，判断是否读到底：</p><pre><code>import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class Test19 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        Reader input=new FileReader(f);        char[] c=new char[1024];        int temp=0;        int len=0;        while((temp=input.read())!=-1){            c[len]=(char) temp;            len++;        }        input.close();        System.out.println(new String(c,0,len));    }}</code></pre><p><strong>另外：</strong></p><p>文件输入输出流：FileReader  FileWriter（实现对文件内容的<strong>逐字符处理</strong>）</p><p>缓存文件输入输出流：BufferedReader   BufferedWriter（实现对文件内容的<strong>逐行处理</strong>）</p><h2 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h2><p>字节流和字符流使用是非常相似的，那么除了操作代码的不同之外，还有哪些不同呢？</p><p><em>字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的</em></p><p><em>字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容</em></p><p><strong>那开发中究竟用字节流好还是用字符流好呢？</strong></p><p><em>在所有的硬盘上保存文件或进行传输的时候都是以字节的方法进行的，包括图片也是按字节完成，而字符是只有在内存中才会形成的，所以使用字节的操作是最多的。</em></p><p><strong>如果要java程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自:&lt;a href=&quot;http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="语法" scheme="https://mlone.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
</feed>
