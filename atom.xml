<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>easy-go&#39;s blogs</title>
  
  <subtitle>Welcome!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mlone.top/"/>
  <updated>2019-02-25T10:35:06.300Z</updated>
  <id>https://mlone.top/</id>
  
  <author>
    <name>easy go</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java反射机制</title>
    <link href="https://mlone.top/post/3ecb78ee.html"/>
    <id>https://mlone.top/post/3ecb78ee.html</id>
    <published>2018-11-10T10:39:32.000Z</published>
    <updated>2019-02-25T10:35:06.300Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/yrstudy/p/6500982.html" target="_blank" rel="noopener">https://www.cnblogs.com/yrstudy/p/6500982.html</a></p><a id="more"></a><p>往往当我们面对一项新的知识时，我们往往需要知道三个方面，它是什么，它能做什么，它比原有知识强在哪里，我们该怎么使用它。当你能够解决这些问题时，便意味着你已经对这项知识入门了。</p><h2 id="一、是什么"><a href="#一、是什么" class="headerlink" title="一、是什么"></a>一、是什么</h2><p>  Java Reflaction in Action有这么一句话，可以解释。反射是运行中的程序检查自己和软件运行环境的能力，它可以根据它发现的进行改变。通俗的讲就是反射可以在运行时根据指定的类名获得类的信息。</p><h2 id="二、为什么"><a href="#二、为什么" class="headerlink" title="二、为什么"></a>二、为什么</h2><p>   我们为什么要使用反射，它的作用是什么，它在实际的编程中有什么应用。</p><p>　　首先我们先明确两个概念，静态编译和动态编译。</p><p>　　静态编译：在编译时确定类型，绑定对象,即通过。 </p><p>　　动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了java的灵活性，体现了多态的应用，有以降低类之间的藕合性。   </p><p>　　我们可以明确的看出动态编译的好处，而反射就是运用了动态编译创建对象。</p><p>　　那么我们再来看看实际中反射又有什么好处那？</p><p>　　往往对比能更加直观的向我们展示两者的不同。</p><p>　　先从某个代码案例上来解释（套用一篇博文的一个例子：<a href="http://blog.csdn.net/justdoit_potato/article/details/51011843）" target="_blank" rel="noopener">http://blog.csdn.net/justdoit_potato/article/details/51011843）</a></p><p>若是不用反射，它是这样的:</p><pre><code>interface fruit{      public abstract void eat();  }  class Apple implements fruit{      public void eat(){          System.out.println(&quot;Apple&quot;);      }  }  class Orange implements fruit{      public void eat(){          System.out.println(&quot;Orange&quot;);      }  }  // 构造工厂类  // 也就是说以后如果我们在添加其他的实例的时候只需要修改工厂类就行了  class Factory{      public static fruit getInstance(String fruitName){          fruit f=null;          if(&quot;Apple&quot;.equals(fruitName)){              f=new Apple();          }          if(&quot;Orange&quot;.equals(fruitName)){              f=new Orange();          }          return f;      }  }  class hello{      public static void main(String[] a){          fruit f=Factory.getInstance(&quot;Orange&quot;);          f.eat();      }  } </code></pre><p>可以发现，每当我们要添加一种新的水果的时候，我们将不得不改变Factory中的源码，而往往改变原有正确代码是一种十分危险的行为。而且随着水果种类的增加，你会发现你的factory类会越来越臃肿，</p><p>不得不说这是一种十分–的做法。（初学者可能会问，我们为什么不直接在main方法中new水果那，我们可能会需要getInstance方法做一些别的事情。。。所以不直接new）；</p><p>而反射无疑是一种聪明的办法，看代码:</p><pre><code>interface fruit{         public abstract void eat();  }  class Apple implements fruit{      public void eat(){          System.out.println(&quot;Apple&quot;);      }  }  class Orange implements fruit{      public void eat(){          System.out.println(&quot;Orange&quot;);      }  }  class Factory{      public static fruit getInstance(String ClassName){          fruit f=null;          try{              f=(fruit)Class.forName(ClassName).newInstance();          }catch (Exception e) {              e.printStackTrace();          }          return f;      }  }  class hello{      public static void main(String[] a){          fruit f=Factory.getInstance(&quot;Reflect.Apple&quot;);          if(f!=null){              f.eat();          }      }  }</code></pre><p>在出现新品种水果的时候，你完全不用去修改原有代码。</p><p>　　从上面的案例中，我们可以清楚的体会到反射的优越性。</p><p>　　那么有的人又会问，这个例子能完全明白，但是如果放到实际的编程，应用中，我们又会在什么情况下用到反射那？</p><p>　　举一个看到过的例子，在实际开发中，我们需要把一个包中的class new出来，但是这个包中的类总是需要变动，那么怎么办，难道总是修改main方法中xxx=new xxx()吗。这样无疑是麻烦的。而运用反射。我们可以相应的增加一个配置文件，在里面记录包中所有的类名，包中类增加时就加一个类名，删除时就删除一个类名。让main方法去读取这个配置文件中的类名，通过反射获得实例，完全不用我们去修改main方法中的代码。</p><p>　　反射还有什么用那？他甚至可以修改其他类中的私有属性。android开发中，我们需要改变一个私有标志位的时候，android源码并没有提供set方法，我们又不能改变源码，怎么办，反射可以完美解决这个问题。</p><p>　　说了这么多，那么我们的开发中，为什么不全部都用反射那？一个原因，开销，它的开销是什么昂贵的，随意尽量在最需要的地方使用反射。</p><h2 id="三、怎么用"><a href="#三、怎么用" class="headerlink" title="三、怎么用"></a>三、怎么用</h2><p>说完是什么，为什么，我们必然需要掌握如何使用反射，先看反射中涉及了那些方法。</p><p>　 Class c=Class.forName(“className”); 注明：<em>className必须为全限定名，也就是：包名+类名，比如，cn.netjava.pojo.UserInfo; </em></p><pre><code>Object obj=c.newInstance();//创建对象的实例 OK，有了对象就什么都好办了，想要什么信息就有什么信息了。 **获得构造函数的方法：**Constructor getConstructor(Class[] params)//根据指定参数获得public构造器Constructor[] getConstructors()//获得public的所有构造器Constructor getDeclaredConstructor(Class[] params)//根据指定参数获得public和非public的构造器Constructor[] getDeclaredConstructors()//获得public的所有构造器 **获得类方法的方法：**Method getMethod(String name, Class[] params),根据方法名，参数类型获得方法Method[] getMethods()//获得所有的public方法Method getDeclaredMethod(String name, Class[] params)//根据方法名和参数类型，获得public和非public的方法Method[] getDeclaredMethods()//获得所以的public和非public方法 </code></pre><p>   <strong> 获得类中属性的方法：</strong><br>    Field getField(String name)//根据变量名得到相应的public变量</p><pre><code>Field[] getFields()//获得类中所以public的方法Field getDeclaredField(String name)//根据方法名获得public和非public变量Field[] getDeclaredFields()//获得类中所有的public和非public方法</code></pre><p>看到这些方法，你就可以明白，反射是多么的强大了，当你正确使用这些方法的时候，基本上是掌握了反射的技巧。</p><p>参考博文：<a href="http://www.cnblogs.com/jqyp/archive/2012/03/29/2423112.html" target="_blank" rel="noopener">http://www.cnblogs.com/jqyp/archive/2012/03/29/2423112.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/yrstudy/p/6500982.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yrstudy/p/6500982.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="反射" scheme="https://mlone.top/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>java中的Class类</title>
    <link href="https://mlone.top/post/1dc53dc8.html"/>
    <id>https://mlone.top/post/1dc53dc8.html</id>
    <published>2018-11-10T09:39:32.000Z</published>
    <updated>2019-02-25T10:31:26.105Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/yepei/p/5649276.html" target="_blank" rel="noopener">https://www.cnblogs.com/yepei/p/5649276.html</a></p><a id="more"></a><p>Class 类是在Java语言中定义一个特定类的实现。一个类的定义包含成员变量，成员方法，还有这个类实现的接口，以及这个类的父类。Class类的对象用于表示当前运行的 Java 应用程序中的类和接口。 比如：每个数组均属于一个 Class 类对象，所有具有相同元素类型和维数的数组共享一个Class 对象。基本的 Java 类型(boolean, byte, char, short,int, long, float 和 double) 和 void 类型也可表示为 Class 对象。</p><p>以下示例使用 Class 对象显示一个对象的 Class 名：</p><pre><code>void printClassName(Object obj) {    System.out.println(&quot;The class of &quot; + obj + &quot; is &quot; + obj.getClass().getName()); }</code></pre><p> 我们都知道所有的java类都是继承了object这个类，在object这个类中有一个方法：getclass().这个方法是用来取得该类已经被实例化了的对象的该类的引用，这个引用指向的是Class类的对象（呵呵，有点别扭）。我们自己无法生成一个Class对象（构造函数为private)，而这个Class类的对象是在当各类被调入时，由 Java 虚拟机自动创建 Class 对象，或通过类装载器中的 defineClass 方法生成。 我们生成的对象都会有个字段记录该对象所属类在CLass类的对象的所在位置。如下图所示：</p><p><img src="\assets\blogImg\4\6.png" alt="图6"></p><p> 我们可以把每个Class类的对象当做众多类的代理。而且在每个Class类对象中有会有字段记录他引用的这个类的类加载器。如果该字段为null,表示该类的加载器为bootstrap loader.具体原因见我之前分享过的一篇“《ClassLoader工作机制 》”一文。</p><p><img src="\assets\blogImg\4\7.png" alt="图7"></p><p>我们知道java中有多个加载器，每个加载器能载入多个类，所以只要取得Class类对象，就可利用其getClassLoader()方法取得该类加载器的引用。</p><p>jvm为每种类管理者独一的Class对象。因此我们可以用双等号操作符来比较对象：a1.getClass()==A.class;应该返回的是true。</p><p><strong>forName(String classname)</strong>和 forName(Stringclassname，{<em>}boolean initialze,</em>ClassLoader <em>loader)</em>方法。</p><p>该方法返回给定串名相应的Class对象。若给定一个类或接口的完整路径名，那么此方法将试图定位、装载和连接该类。若成功，返回该类对象。否则，抛出ClassNotFoundException异常。例如，下面代码段返回名为java.lang.Thread的运行Class描述器。Classt=Class.forName(“java.lang.Thread”);此方法是需要指定类加载器的，当用到仅有一个String参数的forName方法时，Class对象将默认调用当前类加载器作为加载器和将第二参数为true。第二个参数说明：如果是false时，调用forName方法只是在命令类加载器载入该类，而不初始化该类的静态区块，只有当该类第一次实例化时，静态区块才被调用。当为true时，则载入时就调用静态区块。</p><p><strong>getClassLoader()</strong></p><p>获取该类的类装载器</p><p><strong>getComponentType()</strong></p><p>如果当前类表示一个数组，则返回表示该数组组件的Class对象，否则返回null。</p><p><strong>getConstructor(Class[])</strong></p><p>返回当前Class对象表示的类的指定的公有构造子对象。</p><p><strong>getConstructors()</strong></p><p>返回当前Class对象表示的类的所有公有构造子对象数组。</p><p><strong>getDeclaredConstructor(Class[])</strong></p><p>返回当前Class对象表示的类的指定已说明的一个构造子对象。</p><p><strong>getDeclaredConstructors()</strong></p><p>返回当前Class对象表示的类的所有已说明的构造子对象数组。</p><p><strong>getDeclaredField(String)</strong></p><p>返回当前Class对象表示的类或接口的指定已说明的一个域对象。</p><p><strong>getDeclaredFields()</strong></p><p>返回当前Class对象表示的类或接口的所有已说明的域对象数组。</p><p><strong>getDeclaredMethod(String,Class[])</strong></p><p>返回当前Class对象表示的类或接口的指定已说明的一个方法对象。</p><p><strong>getDeclaredMethods()</strong></p><p>返回Class对象表示的类或接口的所有已说明的方法数组。</p><p><strong>getField(String)</strong></p><p>返回当前Class对象表示的类或接口的指定的公有成员域对象。</p><p><strong>getFields()</strong></p><p>返回当前Class对象表示的类或接口的所有可访问的公有域对象数组。</p><p><strong>getInterfaces()</strong></p><p>返回当前对象表示的类或接口实现的接口。</p><p><strong>getMethod(String,Class[])</strong></p><p>返回当前Class对象表示的类或接口的指定的公有成员方法对象。</p><p><strong>getMethods()</strong></p><p>返回当前Class对象表示的类或接口的所有公有成员方法对象数组，包括已声明的和从父类继承的方法。</p><p><strong>getModifiers()</strong></p><p>返回该类或接口的Java语言修改器代码。</p><p><strong>getName()</strong></p><p>返回Class对象表示的类型(类、接口、数组或基类型)的完整路径名字符串。</p><p><strong>getResource(String)</strong></p><p>按指定名查找资源。</p><p><strong>getResourceAsStream(String)</strong></p><p>用给定名查找资源。</p><p><strong>getSigners()</strong></p><p>获取类标记。</p><p><strong>getSuperclass()</strong></p><p>如果此对象表示除Object外的任一类,那么返回此对象的父类对象。</p><p><strong>isArray()</strong></p><p>如果Class对象表示一个数组则返回true,否则返回false。</p><p><strong>isAssignableFrom(Class)</strong></p><p>判定Class对象表示的类或接口是否同参数指定的Class表示的类或接口相同，或是其父类。</p><p><strong>isInstance(Object)</strong></p><p>此方法是Java语言instanceof操作的动态等价方法。</p><p><strong>isInterface()</strong></p><p>判定指定的Class对象是否表示一个接口类型。</p><p><strong>isPrimitive()</strong><br>判定指定的Class对象是否表示一个Java的基类型。</p><p><strong>newInstance()</strong></p><p>创建类的新实例。</p><p><strong>toString()</strong></p><p>将对象转换为字符串。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/yepei/p/5649276.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yepei/p/5649276.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GC执行finalize方法的过程</title>
    <link href="https://mlone.top/post/f6af4d9c.html"/>
    <id>https://mlone.top/post/f6af4d9c.html</id>
    <published>2018-11-05T06:33:50.000Z</published>
    <updated>2019-02-25T09:50:59.913Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/Smina/p/7189427.html" target="_blank" rel="noopener">https://www.cnblogs.com/Smina/p/7189427.html</a></p><a id="more"></a><p>注：本文的目的并不是鼓励使用finalize方法，而是大致理清其作用、问题以及GC执行finalize的过程。</p><h2 id="1-finalize的作用"><a href="#1-finalize的作用" class="headerlink" title="1. finalize的作用"></a>1. finalize的作用</h2><ul><li>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</li><li>finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性</li><li>不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题]</li></ul><h2 id="2-finalize的问题"><a href="#2-finalize的问题" class="headerlink" title="2. finalize的问题"></a>2. finalize的问题</h2><ul><li>一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法</li><li>System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</li><li>Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</li><li>finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</li><li>对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</li><li>finalize方法至多由GC执行一次(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)</li></ul><h2 id="3-finalize的执行过程-生命周期"><a href="#3-finalize的执行过程-生命周期" class="headerlink" title="3. finalize的执行过程(生命周期)"></a>3. finalize的执行过程(生命周期)</h2><p>(1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</p><p>(2) 具体的finalize流程：</p><ul><li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li><li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li><li>finalized: 表示GC已经对该对象执行过finalize方法</li><li>reachable: 表示GC Roots引用可达</li><li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li><li>unreachable：对象不可通过上面两种途径可达</li></ul><p>状态变迁图：</p><p><img src="\assets\blogImg\4\5.jpg" alt="图5"></p><p>变迁说明：</p><ol><li>新建对象首先处于[reachable, unfinalized]状态(A)</li><li>随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</li><li>若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</li><li>在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</li><li>处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</li><li>程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</li><li>若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</li><li>若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</li><li>注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法</li></ol><h2 id="4-一些代码示例"><a href="#4-一些代码示例" class="headerlink" title="4. 一些代码示例"></a>4. 一些代码示例</h2><h3 id="对象复活"><a href="#对象复活" class="headerlink" title="对象复活"></a>对象复活</h3><pre><code>public class GC {  // 这里的GC是类名，并非垃圾回收器    public static GC SAVE_HOOK = null;     public static void main(String[] args) throws InterruptedException {        // 新建对象，因为SAVE_HOOK指向这个对象，对象此时的状态是(reachable,unfinalized)        SAVE_HOOK = new GC();         //将SAVE_HOOK设置成null，此时刚才创建的对象就不可达了，因为没有句柄再指向它了，对象此时状态是(unreachable，unfinalized)        SAVE_HOOK = null;         //强制系统执行垃圾回收，系统发现刚才创建的对象处于unreachable状态，并检测到这个对象的类覆盖了finalize方法，因此把这个对象放入F-Queue队列，由低优先级线程执行它的finalize方法，此时对象的状态变成(unreachable, finalizable)或者是(finalizer-reachable,finalizable)        System.gc();         // sleep，目的是给低优先级线程从F-Queue队列取出对象并执行其finalize方法提供机会。在执行完对象的finalize方法中的super.finalize()时，对象的状态变成(unreachable,finalized)状态，但接下来在finalize方法中又执行了SAVE_HOOK = this;这句话，又有句柄指向这个对象了，对象又可达了。因此对象的状态又变成了(reachable, finalized)状态。        Thread.sleep(500);        // 这里楼主说对象处于(reachable,finalized)状态应该是合理的。对象的finalized方法被执行了，因此是finalized状态。又因为在finalize方法是执行了SAVE_HOOK=this这句话，本来是unreachable的对象，又变成reachable了。        if (null != SAVE_HOOK) { //此时对象应该处于(reachable, finalized)状态             // 这句话会输出，注意对象由unreachable，经过finalize复活了。            System.out.println(&quot;Yes , I am still alive&quot;);         } else {             System.out.println(&quot;No , I am dead&quot;);         }         // 再一次将SAVE_HOOK放空，此时刚才复活的对象，状态变成(unreachable,finalized)        SAVE_HOOK = null;         // 再一次强制系统回收垃圾，此时系统发现对象不可达，虽然覆盖了finalize方法，但已经执行过了，因此直接回收。        System.gc();         // 为系统回收垃圾提供机会        Thread.sleep(500);         if (null != SAVE_HOOK) {             // 这句话不会输出，因为对象已经彻底消失了。            System.out.println(&quot;Yes , I am still alive&quot;);         } else {             System.out.println(&quot;No , I am dead&quot;);         }     }     @Override     protected void finalize() throws Throwable { // 覆写Object类中的finalize方法        super.finalize();  // 调用Object类中finalize方法        System.out.println(&quot;execute method finalize()&quot;);         // 这句话让对象的状态由unreachable变成reachable，就是对象复活        SAVE_HOOK = this;     } }</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/Smina/p/7189427.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/Smina/p/7189427.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java中的finalize方法[转载]</title>
    <link href="https://mlone.top/post/b52b9753.html"/>
    <id>https://mlone.top/post/b52b9753.html</id>
    <published>2018-11-05T05:33:50.000Z</published>
    <updated>2019-02-25T09:50:58.539Z</updated>
    
    <content type="html"><![CDATA[<p>[转载自：<a href="https://blog.csdn.net/Justin_zhao/article/details/74358828" target="_blank" rel="noopener">Java中的finalize()方法</a>]</p><p><em>Java中假定finalize的工作原理为：一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的finalize方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！</em><br><a id="more"></a><br><em>finalize()的作用：finalize用于在GC发生前事先调用去回收JNI调用中申请的特殊内存，下次GC发生时候保证GC后所有该对象的内存都释放了。</em></p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>Java的垃圾回收器只会释放由我们new出来的内存堆块，那些不是由new出来的“特殊内存”，垃圾回收器是不会管理的。</li><li>所谓的特殊内存指通过JNI用C/C++向系统申请的内存，这些内存如果不手动去清除就会一直占据在内存中。</li><li>而且，垃圾回收本身就有开销，所以虚拟机不会经常GC，只有当内存快要耗尽的时候JVM才会触发GC。</li></ul><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><h5 id="由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize-方法让我们来执行清理工作。"><a href="#由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize-方法让我们来执行清理工作。" class="headerlink" title="-由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize()方法让我们来执行清理工作。"></a>-由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize()方法让我们来执行清理工作。</h5><p>-当系统进行GC的时候会先调用finalize方法，然后再下次才会回收对象的内存。因为native中申请的内存，GC没有办法回收所以finalize被用来做垃圾回前的重要清理工作：释放特殊内存。</p><h5 id="所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！"><a href="#所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！" class="headerlink" title="-所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！"></a>-所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！</h5><p>-如果GC不发生那么finalize也不会发生，finalize是Object的protect方法，不可以在类族外访问。</p><h3 id="不是析构函数"><a href="#不是析构函数" class="headerlink" title="不是析构函数"></a>不是析构函数</h3><ul><li>Java因为有GC机制，所以没有析构函数的概念！</li><li>finalize不是C++中的析构函数：析构函数肯定是会销毁该对象的，但是finalize因为gc机制不会经常发生，所以其被执行的是不确定的。（不知道是不是我没理解透，没觉得这两个有什么可比性，一个主动发生一个被动发生）</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>调用System.gc()，可以强制让gc发生来触发finalize方法！但是GC也只是GC垃圾的对象（没有被引用的），非垃圾的对象的finalize不会被调用。程序终止和GC不是一个概念。</li><li>正常情况下你调用finalize(）都是直接super.finalize()使用父类的就行了。</li><li>finalize一般不用！被执行的不确定性太大。不要指望使用finalize来回收你的对象，它只会在系统进行GC的时候清理特殊内存，不受你的控制！</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;[转载自：&lt;a href=&quot;https://blog.csdn.net/Justin_zhao/article/details/74358828&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java中的finalize()方法&lt;/a&gt;]&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Java中假定finalize的工作原理为：一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的finalize方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！&lt;/em&gt;&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Java中HashMap的实现原理</title>
    <link href="https://mlone.top/post/1ed5a07.html"/>
    <id>https://mlone.top/post/1ed5a07.html</id>
    <published>2018-11-03T13:09:08.000Z</published>
    <updated>2019-02-23T13:34:12.185Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/yuanblog/p/4441017.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuanblog/p/4441017.html</a></p><a id="more"></a><h3 id="一、Java中的hashCode和equals"><a href="#一、Java中的hashCode和equals" class="headerlink" title="一、Java中的hashCode和equals"></a>一、Java中的hashCode和equals</h3><h4 id="1、关于hashCode"><a href="#1、关于hashCode" class="headerlink" title="1、关于hashCode"></a>1、关于hashCode</h4><p>   1.hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的</p><p>   2.如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同</p><p>   3.如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点</p><p>   4.两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”</p><p><strong>再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。</strong></p><p>以下对hashCode的解读摘自其他博客：</p><pre><code>1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有例如内存中有这样的位置0  1  2  3  4  5  6  7 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。但如果用hashcode那就会使效率提高很多。我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。那么，重写了equals()，为什么还要重写hashCode()呢？想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊</code></pre><h4 id="2、关于equals"><a href="#2、关于equals" class="headerlink" title="2、关于equals"></a>2、关于equals</h4><p>1.equals和==<br>==用于比较引用和比较基本数据类型时具有不同的功能：<br>比较基本数据类型，如果两个值相同，则结果为true<br>而在比较引用时，如果引用指向内存中的同一对象，结果为true;</p><p>equals()作为方法，实现对象的比较。由于==运算符不允许我们进行覆盖，也就是说它限制了我们的表达。因此我们复写equals()方法，达到比较对象内容是否相同的目的。而这些通过==运算符是做不到的。</p><p>2.object类的equals()方法的比较规则为：如果两个对象的类型一致，并且内容一致，则返回true,这些类有：</p><pre><code>java.io.file,java.util.Date,java.lang.string,包装类（Integer,Double等）String s1=new String(&quot;abc&quot;);String s2=new String(&quot;abc&quot;);System.out.println(s1==s2);System.out.println(s1.equals(s2));运行结果为false true</code></pre><h3 id="二、HashMap的实现原理"><a href="#二、HashMap的实现原理" class="headerlink" title="二、HashMap的实现原理"></a>二、HashMap的实现原理</h3><h4 id="1-HashMap概述"><a href="#1-HashMap概述" class="headerlink" title="1.HashMap概述"></a>1.HashMap概述</h4><p>   HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>   在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p><p><img src="/assets/blogImg/4/4.jpg" alt="图4"></p><p>从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。</p><p>其中Java源码如下：</p><pre><code>/**  * The table, resized as necessary. Length MUST Always be a power of two.  */transient Entry[] table;static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final K key;    V value;    Entry&lt;K,V&gt; next;    final int hash;        ……}</code></pre><p>可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。</p><h4 id="2-HashMap实现存储和读取"><a href="#2-HashMap实现存储和读取" class="headerlink" title="2.HashMap实现存储和读取"></a>2.HashMap实现存储和读取</h4><h5 id="1）存储"><a href="#1）存储" class="headerlink" title="1）存储"></a>1）存储</h5><pre><code>public V put(K key, V value) {    // HashMap允许存放null键和null值。    // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。    if (key == null)        return putForNullKey(value);    // 根据key的keyCode重新计算hash值。    int hash = hash(key.hashCode());    // 搜索指定hash值在对应table中的索引。    int i = indexFor(hash, table.length);    // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {            // 如果发现已有该键值，则存储新的值，并返回原始值            V oldValue = e.value;            e.value = value;            e.recordAccess(this);            return oldValue;        }    }    // 如果i索引处的Entry为null，表明此处还没有Entry。    modCount++;    // 将key、value添加到i索引处。    addEntry(hash, key, value, i);    return null;}</code></pre><p>根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。</p><p>hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。</p><pre><code>1 static int hash(int h) {2     h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);3     return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);4 }</code></pre><p>我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。</p><p>根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。</p><p><strong>通过这种方式就可以高效的解决HashMap的冲突问题。</strong></p><h5 id="2）读取"><a href="#2）读取" class="headerlink" title="2）读取"></a>2）读取</h5><pre><code>public V get(Object key) {    if (key == null)        return getForNullKey();    int hash = hash(key.hashCode());    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];        e != null;        e = e.next) {        Object k;        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))            return e.value;    }    return null;}</code></pre><p>从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。</p><h5 id="3）归纳起来简单地说"><a href="#3）归纳起来简单地说" class="headerlink" title="3）归纳起来简单地说:"></a>3）归纳起来简单地说:</h5><p>HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。</p><h4 id="3-HashMap的resize"><a href="#3-HashMap的resize" class="headerlink" title="3.HashMap的resize"></a>3.HashMap的resize</h4><p>当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。</p><p>那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小<em>loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过16</em>0.75=12的时候，就把数组的大小扩展为2<em>16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.75</em>1000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。</p><h4 id="总结：HashMap的实现原理："><a href="#总结：HashMap的实现原理：" class="headerlink" title="总结：HashMap的实现原理："></a>总结：HashMap的实现原理：</h4><p>  <strong>1. 利用key的hashCode重新hash计算出当前对象的元素在数组中的下标。</strong></p><p>  <strong>2. 存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中。</strong></p><p>  <strong>3. 获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</strong></p><p>  <strong>4. 理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/yuanblog/p/4441017.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/yuanblog/p/4441017.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM启动参数设置</title>
    <link href="https://mlone.top/post/61cc7df2.html"/>
    <id>https://mlone.top/post/61cc7df2.html</id>
    <published>2018-10-15T14:30:16.000Z</published>
    <updated>2019-02-25T14:42:03.776Z</updated>
    
    <content type="html"><![CDATA[<p>参考1：<a href="https://blog.csdn.net/sivyer123/article/details/17139443" target="_blank" rel="noopener">JVM 堆内存设置原理</a></p><a id="more"></a><p>参考2：<a href="https://www.cnblogs.com/smyhvae/p/4736162.html" target="_blank" rel="noopener">Java虚拟机详解03—-常用JVM配置参数</a></p><h1 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h1><ul><li>-Xmx3550m：设置JVM<strong>最大堆内存</strong>为3550M。</li><li>-Xms3550m：设置JVM<strong>初始堆内存</strong>为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li><li>-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如&gt;2MB）时将会在很大程度上降低系统的性能。</li><li>-Xmn2g：设置<strong>年轻代</strong>大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。</li><li>-XX:NewSize=1024m：设置年轻代初始值为1024M。</li><li>-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。</li><li>-XX:PermSize=256m：设置<strong>持久代初始值</strong>为256M。</li><li>-XX:MaxPermSize=256m：设置<strong>持久代最大值</strong>为256M。</li><li>-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。</li><li>-XX:SurvivorRatio=4：设置<strong>年轻代中Eden区与Survivor区的比值</strong>。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。</li><li>-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</li></ul><h1 id="疑问解答"><a href="#疑问解答" class="headerlink" title="疑问解答"></a>疑问解答</h1><p>-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？<br>如下：</p><p>高优先级：-XX:NewSize/-XX:MaxNewSize </p><p>中优先级：-Xmn（默认等效  -Xmn=-XX:NewSize=-XX:MaxNewSize=?） </p><p>低优先级：-XX:NewRatio </p><p>推荐使用-Xmn参数，原因是这个参数简洁，相当于一次设定 NewSize/MaxNewSIze，而且两者相等，适用于生产环境。-Xmn 配合 -Xms/-Xmx，即可将堆内存布局完成。</p><p>-Xmn参数是在JDK 1.4 开始支持。</p><h1 id="垃圾回收器选择"><a href="#垃圾回收器选择" class="headerlink" title="垃圾回收器选择"></a>垃圾回收器选择</h1><p>JVM给出了3种选择：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器。</p><p>默认情况下JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行智能判断。</p><h2 id="串行收集器"><a href="#串行收集器" class="headerlink" title="串行收集器"></a>串行收集器</h2><ul><li>-XX:+UseSerialGC：设置串行收集器。</li></ul><h2 id="并行收集器（吞吐量优先）"><a href="#并行收集器（吞吐量优先）" class="headerlink" title="并行收集器（吞吐量优先）"></a>并行收集器（吞吐量优先）</h2><ul><li>-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。</li><li>-XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。</li><li>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。</li><li>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。</li><li>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。</li></ul><h2 id="并发收集器（响应时间优先）"><a href="#并发收集器（响应时间优先）" class="headerlink" title="并发收集器（响应时间优先）"></a>并发收集器（响应时间优先）</h2><ul><li>-XX:+UseConcMarkSweepGC：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。</li><li>-XX:+UseParNewGC：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。</li><li>-XX:CMSFullGCsBeforeCompaction=0：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。</li><li>-XX:+UseCMSCompactAtFullCollection：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。</li><li>-XX:+CMSIncrementalMode：设置为增量收集模式。一般适用于单CPU情况。</li><li>-XX:CMSInitiatingOccupancyFraction=70：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。</li></ul><h2 id="其它垃圾回收参数"><a href="#其它垃圾回收参数" class="headerlink" title="其它垃圾回收参数"></a>其它垃圾回收参数</h2><ul><li>-XX:+ScavengeBeforeFullGC：年轻代GC优于Full GC执行。</li><li>-XX:-DisableExplicitGC：不响应 System.gc() 代码。</li><li>-XX:+UseThreadPriorities：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。</li><li>-XX:SoftRefLRUPolicyMSPerMB=0：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。</li><li>-XX:TargetSurvivorRatio=90：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。</li></ul><h1 id="辅助信息参数设置"><a href="#辅助信息参数设置" class="headerlink" title="辅助信息参数设置"></a>辅助信息参数设置</h1><ul><li>-XX:-CITime：打印消耗在JIT编译的时间。</li><li>-XX:ErrorFile=./hs_err_pid.log：保存错误日志或数据到指定文件中。</li><li>-XX:HeapDumpPath=./java_pid.hprof：指定Dump堆内存时的路径。</li><li>-XX:-HeapDumpOnOutOfMemoryError：当首次遭遇内存溢出时Dump出此时的堆内存。</li><li>-XX:OnError=”;”：出现致命ERROR后运行自定义命令。</li><li>-XX:OnOutOfMemoryError=”;”：当首次遭遇内存溢出时执行自定义命令。</li><li>-XX:-PrintClassHistogram：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。</li><li>-XX:-PrintConcurrentLocks：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。</li><li>-XX:-PrintCompilation：当一个方法被编译时打印相关信息。</li><li>-XX:-PrintGC：每次GC时打印相关信息。</li><li>-XX:-PrintGCDetails：每次GC时打印详细信息。</li><li>-XX:-PrintGCTimeStamps：打印每次GC的时间戳。</li><li>-XX:-TraceClassLoading：跟踪类的加载信息。</li><li>-XX:-TraceClassLoadingPreorder：跟踪被引用到的所有类的加载信息。</li><li>-XX:-TraceClassResolution：跟踪常量池。</li><li>-XX:-TraceClassUnloading：跟踪类的卸载信息。</li></ul><h1 id="关于参数名称等"><a href="#关于参数名称等" class="headerlink" title="关于参数名称等"></a>关于参数名称等</h1><ul><li><p>标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容；例如：</p><p>  – -client——设置JVM使用Client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试；在32位环境下直接运行Java程序默认启用该模式。</p><p>  – -server——设置JVM使Server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下默认启用该模式。</p></li><li><p>非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容；</p></li><li>非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用；</li></ul><h1 id="JVM服务参数调优实战"><a href="#JVM服务参数调优实战" class="headerlink" title="JVM服务参数调优实战"></a>JVM服务参数调优实战</h1><h2 id="大型网站服务器案例"><a href="#大型网站服务器案例" class="headerlink" title="大型网站服务器案例"></a>大型网站服务器案例</h2><p>承受海量访问的动态Web应用</p><p>服务器配置：8 CPU, 8G MEM, JDK 1.6.X</p><p>参数方案：</p><p>-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC</p><p>调优说明：</p><ul><li>-Xmx 与 -Xms 相同以避免JVM反复重新申请内存。-Xmx 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。</li><li>-Xmn1256m 设置年轻代大小为1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。</li><li>-Xss128k 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能。</li><li>-XX:SurvivorRatio=6 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。</li><li>-XX:ParallelGCThreads=8 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。</li><li>-XX:MaxTenuringThreshold=0 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0。</li><li>-XX:+UseConcMarkSweepGC 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况。</li></ul><h2 id="内部集成构建服务器案例"><a href="#内部集成构建服务器案例" class="headerlink" title="内部集成构建服务器案例"></a>内部集成构建服务器案例</h2><p>高性能数据处理的工具应用<br>服务器配置：1 CPU, 4G MEM, JDK 1.6.X</p><p>参数方案：</p><p>-server -XX:PermSize=196m -XX:MaxPermSize=196m -Xmn320m -Xms768m -Xmx1024m</p><p>调优说明：</p><ul><li>-XX:PermSize=196m -XX:MaxPermSize=196m 根据集成构建的特点，大规模的系统编译可能需要加载大量的Java类到内存中，所以预先分配好大量的持久代内存是高效和必要的。</li><li>-Xmn320m 遵循年轻代大小为整个堆的3/8原则。</li><li>-Xms768m -Xmx1024m 根据系统大致能够承受的堆内存大小设置即可。</li></ul><p>在64位服务器上运行应用程序，构建执行时，用 jmap -heap 11540 命令观察JVM堆内存状况如下：</p><pre><code>Attaching to process ID 11540, please wait...Debugger attached successfully.Server compiler detected.JVM version is 20.12-b01using thread-local object allocation.Parallel GC with 4 thread(s)Heap Configuration:   MinHeapFreeRatio = 40   MaxHeapFreeRatio = 70   MaxHeapSize      = 1073741824 (1024.0MB)   NewSize          = 335544320 (320.0MB)   MaxNewSize       = 335544320 (320.0MB)   OldSize          = 5439488 (5.1875MB)   NewRatio         = 2   SurvivorRatio    = 8   PermSize         = 205520896 (196.0MB)   MaxPermSize      = 205520896 (196.0MB)Heap Usage:PS Young GenerationEden Space:   capacity = 255852544 (244.0MB)   used     = 101395504 (96.69828796386719MB)   free     = 154457040 (147.3017120361328MB)   39.63044588683081% usedFrom Space:   capacity = 34144256 (32.5625MB)   used     = 33993968 (32.41917419433594MB)   free     = 150288 (0.1433258056640625MB)   99.55984397492803% usedTo Space:   capacity = 39845888 (38.0MB)   used     = 0 (0.0MB)   free     = 39845888 (38.0MB)   0.0% usedPS Old Generation   capacity = 469762048 (448.0MB)   used     = 44347696 (42.29325866699219MB)   free     = 425414352 (405.7067413330078MB)   9.440459523882184% usedPS Perm Generation   capacity = 205520896 (196.0MB)   used     = 85169496 (81.22396087646484MB)   free     = 120351400 (114.77603912353516MB)   41.440796365543285% used</code></pre><p>结果是比较健康的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考1：&lt;a href=&quot;https://blog.csdn.net/sivyer123/article/details/17139443&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVM 堆内存设置原理&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存设置原理</title>
    <link href="https://mlone.top/post/4cc01209.html"/>
    <id>https://mlone.top/post/4cc01209.html</id>
    <published>2018-10-15T14:30:16.000Z</published>
    <updated>2019-02-25T14:50:44.523Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/sivyer123/article/details/17139443" target="_blank" rel="noopener">https://blog.csdn.net/sivyer123/article/details/17139443</a></p><a id="more"></a><h1 id="堆内存设置"><a href="#堆内存设置" class="headerlink" title="堆内存设置"></a>堆内存设置</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>方法区：Permanent 即 持久代（Permanent Generation），主要存放的是Java类定义信息，与垃圾收集器要收集的Java对象关系不大。</p><p>堆内存：Heap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。</p><p><img src="/assets/blogImg/4/19.png" alt="图片19"></p><h3 id="持久代"><a href="#持久代" class="headerlink" title="持久代"></a>持久代</h3><p>　　用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 Hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。</p><h3 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h3><p>　　所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。</p><p>　　大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。</p><p>　　2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。<strong>而且，因为需要交换的原因，Survivor区至少有一个是空的。</strong>特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</p><p>　　针对年轻代的垃圾回收即 Young GC。</p><h3 id="年老代"><a href="#年老代" class="headerlink" title="年老代"></a>年老代</h3><p>　　在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p>　　针对年老代的垃圾回收即 Full GC。</p><p>所以，当一组对象生成时，<strong>内存申请过程</strong>如下：</p><p>　　<em>JVM会试图为相关Java对象在年轻代的Eden区中初始化一块内存区域。</em></p><p>　　<em>当Eden区空间足够时，内存申请结束。否则执行下一步。</em></p><p>　　<em>JVM试图释放在Eden区中所有不活跃的对象（Young GC）。释放后若Eden空间仍然不足以放入新对象，JVM则试图将部分Eden区中活跃对象放入Survivor区。</em></p><p>　　<em>Survivor区被用来作为Eden区及年老代的中间交换区域。当年老代空间足够时，Survivor区中存活了一定次数的对象会被移到年老代。</em></p><p>　　<em>当年老代空间不够时，JVM会在年老代进行完全的垃圾回收（Full GC）。</em></p><p>　　<em>Full GC后，若Survivor区及年老代仍然无法存放从Eden区复制过来的对象，则会导致JVM无法在Eden区为新生成的对象申请内存，即出现“Out of Memory”。</em></p><h3 id="OOM（“Out-of-Memory”）异常一般主要有如下2种原因："><a href="#OOM（“Out-of-Memory”）异常一般主要有如下2种原因：" class="headerlink" title="OOM（“Out of Memory”）异常一般主要有如下2种原因："></a>OOM（“Out of Memory”）异常一般主要有如下2种原因：</h3><ol><li>持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace</li></ol><p>　　通常由于持久代设置过小，动态加载了大量Java类而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。</p><ol start="2"><li>年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace</li></ol><p>　　这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。</p><p>　　例如循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/sivyer123/article/details/17139443&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/sivyer123/article/details/17139443&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>运行时数据区概括</title>
    <link href="https://mlone.top/post/3447574e.html"/>
    <id>https://mlone.top/post/3447574e.html</id>
    <published>2018-10-14T14:30:16.000Z</published>
    <updated>2019-02-25T14:42:03.789Z</updated>
    
    <content type="html"><![CDATA[<p>参考：</p><a id="more"></a><p><a href="https://www.cnblogs.com/SaraMoring/p/5687466.html" target="_blank" rel="noopener">Java内存分配之堆、栈和常量池</a></p><p><a href="https://blog.csdn.net/aijiudu/article/details/72991993" target="_blank" rel="noopener">JVM架构和GC垃圾回收机制详解</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjE5MTE1Nw==&amp;mid=2653193961&amp;idx=2&amp;sn=cdfa0d38829a0dc1ad5d23350e1aca90&amp;chksm=8c99f433bbee7d25f353b6156375a0d0d430080e1c7489f47499fa3f4051e0fa4449811cfddb&amp;mpshare=1&amp;scene=1&amp;srcid=0529n9lAnXTfdGBzFnANpp8I#rd" target="_blank" rel="noopener">聊下JVM内存模型</a></p><p>运行时数据区包括：本地方法栈，虚拟机栈区，程序计数器，方法区，堆区。</p><p><img src="/assets/blogImg/4/16.jpg" alt="图片16"></p><p><strong>本地方法栈(Native Method Stack)：</strong>用于保存<strong>本地方法信息</strong>。<em>对每一个线程，将创建一个单独的本地方法栈</em>。</p><p><em>Java 虚拟机实现可能会使用到传统的栈（通常称之为“ C Stacks”）来支持 native 方（ 指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（ Native MethodStack）。</em></p><p><strong>虚拟机栈 ：</strong>也就是我们常说的栈区，线程私有，存放<strong>基本类型的变量数据，对象的引用变量和返回地址</strong>，在编译期间完成分配。</p><p><em>栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量数据（int, short, long, byte, float, double, boolean, char）和对象句柄(引用)。</em></p><p><strong>程序计数器（PC寄存器） ：</strong>线程私有，每个线程都有自己独立的寄存器来保存<strong>当前指令的地址，*</strong>一旦该指令被执行，寄存器变会被更新至下条指令的地址。 *</p><p><strong>方法区（持久代） ：</strong>所有线程共享，存储已被虚拟机加载的，在编译期被确定并保存在.class文件中的一些类级别的数据，如<strong>类信息，常量，静态变量，即编译器编译后的代码等数据</strong>。这个区域的内存回收目标主要是<em>针对常量池的对象的回收和对类型的卸载</em>。</p><p><strong>堆区（年轻代+老年代） ：</strong> JAVA 堆，也称 GC 堆，所有线程共享，存放new创建的对象实例和数组， JAVA 堆是垃圾收集器管理的主要区域。</p><p><em>堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，但这也导致了它的缺点：存取速度较慢。</em></p><p><strong>由于方法区和堆区的内存由多个线程共享，所以存储的数据不是线程安全的。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考：&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java运行时数据区</title>
    <link href="https://mlone.top/post/9806100a.html"/>
    <id>https://mlone.top/post/9806100a.html</id>
    <published>2018-10-14T13:30:16.000Z</published>
    <updated>2019-02-25T14:44:44.588Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自公众号：AskHarries</p><a id="more"></a><p><img src="/assets/blogImg/4/15.png" alt="图片15"></p><h2 id="1-JVM运行时数据区"><a href="#1-JVM运行时数据区" class="headerlink" title="1. JVM运行时数据区"></a>1. JVM运行时数据区</h2><p><img src="/assets/blogImg/4/16.jpg" alt="图片16"></p><h2 id="2-程序计数器-PC寄存器"><a href="#2-程序计数器-PC寄存器" class="headerlink" title="2. 程序计数器(PC寄存器)"></a>2. 程序计数器(PC寄存器)</h2><p>每个线程都会有自己私有的程序计数器(PC)。可以看作是当前线程所执行的字节码的行号指示器。</p><p>也可以理解为下一条将要执行的指令的地址或者行号。字节码解释器就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,分支、 循环、 跳转、 异常处理、 线程上下文切换，线程恢复时，都要依赖PC.</p><ul><li>如果线程正在执行的是一个Java方法，PC值为正在执行的虚拟机字节码指令的地址</li><li>如果线程正在执行的是Native方法，PC值为空(未定义)</li></ul><h2 id="3-虚拟机栈-VM-Stack"><a href="#3-虚拟机栈-VM-Stack" class="headerlink" title="3.虚拟机栈(VM Stack)"></a>3.虚拟机栈(VM Stack)</h2><p>VM Stack也是线程私有的区域。他是java方法执行时的字典：它里面记录了局部变量表、 操作数栈、 动态链接、 方法出口等信息。</p><p><strong>在《java虚拟机规范》一书中对这部分的描述如下：</strong></p><p><em>栈帧（ Frame）是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接 (Dynamic Linking)、 方法返回值和异常分派（ Dispatch Exception）。<br>栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束。<br>栈帧的存储空间分配在 Java 虚拟机栈（ §2.5.5）之中，每一个栈帧都有自己的局部变量表（ Local Variables， §2.6.1）、操作数栈（ OperandStack， §2.6.2）和指向当前方法所属的类的运行时常量池（ §2.5.5）的引用。</em></p><h2 id="4-本地方法栈-Native-Method-Stack"><a href="#4-本地方法栈-Native-Method-Stack" class="headerlink" title="4. 本地方法栈(Native Method Stack)"></a>4. 本地方法栈(Native Method Stack)</h2><p><em>Java 虚拟机实现可能会使用到传统的栈（通常称之为“ C Stacks”）来支持 native 方法（ 指使用 Java 以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（ Native MethodStack）。</em></p><p>VM Stack是为执行java方法服务的，此处的Native Method Stack是为执行本地方法服务的。<br>此处的本地方法指定是和具体的底层操作系统层面相关的接口调用了(这部分太高高级了，不想深究……)。</p><p>《java虚拟机规范》中没有对这部分做具体的规定。所以就由VM的实现者自由发挥了。</p><p>有的虚拟机(比如HotSpot)将VM Stack和Native Method Stack合二为一，所以VM的另一种内存区域图就如下面所示了：</p><p><img src="/assets/blogImg/4/17.jpg" alt="图片17"></p><h2 id="5-Java堆-Heap"><a href="#5-Java堆-Heap" class="headerlink" title="5.Java堆(Heap)"></a>5.Java堆(Heap)</h2><p><em>在 Java 虚拟机中，堆（ Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。</em></p><p>以下是本人对《java虚拟机规范》一书中对Java堆的介绍的总结:</p><ul><li>在虚拟机启动的时候就被创建</li><li>是所有线程共享的内存区域</li><li><p>存储了被自动内存管理系统所管理的各种对象</p><pre><code>---- 这些受管理的对象无需，也无法显式地被销毁---- 自动内存管理系统:Automatic StorageManagement System，也即是常说的”Garbage Collector(垃圾收集器)”---- 并未指明用什么具体的技术去实现自动内存管理系统</code></pre></li><li>Java 堆的容量可以是固定大小的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩</li><li>Java 堆所使用的内存不需要保证是连续的</li><li>如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那 Java 虚拟机将会抛出一个OutOfMemoryError 异常</li><li><p>实现者应当提供给程序员或者最终用户调节 Java 堆初始容量的手段</p><pre><code>---- 对于可以动态扩展和收缩 Java 堆来说，则应当提供调节其最大、最小容量的手段</code></pre></li><li><p>所有的对象实例以及数组都要在堆上分配</p></li></ul><p><img src="/assets/blogImg/4/18.jpg" alt="图片18"></p><h2 id="6-方法区-Method-Area"><a href="#6-方法区-Method-Area" class="headerlink" title="6.方法区(Method Area)"></a>6.方法区(Method Area)</h2><p>方法区是由所有线程共享的内存区域。</p><p>方法区存储的大致内容如下:</p><ul><li><p>每一个类的结构信息</p><pre><code>---- 运行时常量池（ Runtime Constant Pool）---- 字段和方法数据---- 构造函数和普通方法的字节码内容</code></pre></li><li><p>类、实例、接口初始化时用到的特殊方法</p></li></ul><p>每一个运行时常量池都分配在 Java 虚拟机的方法区之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。</p><ul><li>当创建类或接口的时候，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值，那 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li></ul><h2 id="7-直接内存-Direct-Memory"><a href="#7-直接内存-Direct-Memory" class="headerlink" title="7.直接内存(Direct Memory)"></a>7.直接内存(Direct Memory)</h2><p>此处的直接内存并不是由JVM管理的内存。他是利用本地方法库直接在java堆之外申请的内存区域。</p><p>比如NIO中的DirectByteBuffer就是操作直接内存的。</p><p>直接内存的好处就是避免了在java堆和native堆直接同步数据的步骤。但是他并不是由JVM来管理的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文转载自公众号：AskHarries&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="GC" scheme="https://mlone.top/tags/GC/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://mlone.top/post/91e798bc.html"/>
    <id>https://mlone.top/post/91e798bc.html</id>
    <published>2018-10-12T13:30:16.000Z</published>
    <updated>2019-02-25T14:46:08.838Z</updated>
    
    <content type="html"><![CDATA[<p>来自：Hollis（微信号：hollischuang）</p><a id="more"></a><p>前几天，发了一篇文章，介绍了一下<a href="http://mp.weixin.qq.com/s?__biz=MzI3NzE0NjcwMg==&amp;mid=2650121579&amp;idx=1&amp;sn=373fb812e6ff056b2e5b41cc46968cc9&amp;chksm=f36bb84ac41c315cb7c3e9d7e99b68bee7b2ac2dc8a6ed7e4a5829c5f2434ffa08e9eb14d40f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">JVM内存结构、Java内存模型以及Java对象模型之间的区别</a>。</p><p>有很多小伙伴反馈希望可以深入的讲解下每个知识点。Java内存模型，是这三个知识点当中最晦涩难懂的一个，而且涉及到很多背景知识和相关知识。</p><p>网上有很多关于Java内存模型的文章，在《深入理解Java虚拟机》和《Java并发编程的艺术》等书中也都有关于这个知识点的介绍。但是，很多人读完之后还是搞不清楚，甚至有的人说自己更懵了。本文，就来整体的介绍一下Java内存模型，目的很简单，让你读完本文以后，就知道到底Java内存模型是什么，为什么要有Java内存模型，Java内存模型解决了什么问题等。</p><p>本文中，有很多定义和说法，都是笔者自己理解后定义出来的。希望能够让读者可以对Java内存模型有更加清晰的认识。当然，如有偏颇，欢迎指正。</p><h2 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h2><p>在介绍Java内存模型之前，先来看一下到底什么是计算机内存模型，然后再来看Java内存模型在计算机内存模型的基础上做了哪些事情。要说计算机的内存模型，就要说一下一段古老的历史，看一下为什么要有内存模型。</p><p><strong>内存模型，英文名Memory Model，他是一个很老的老古董了。他是与计算机硬件有关的一个概念。那么我先给你介绍下他和硬件到底有啥关系。</strong></p><h3 id="CPU和缓存一致性"><a href="#CPU和缓存一致性" class="headerlink" title="CPU和缓存一致性"></a>CPU和缓存一致性</h3><p>我们应该都知道，计算机在执行程序的时候，每条指令都是在CPU中执行的，而执行的时候，又免不了要和数据打交道。而计算机上面的数据，是存放在主存当中的，也就是计算机的物理内存啦。</p><p>刚开始，还相安无事的，但是随着CPU技术的发展，CPU的执行速度越来越快。而由于内存的技术并没有太大的变化，所以从内存中读取和写入数据的过程和CPU的执行速度比起来差距就会越来越大,这就导致CPU每次操作内存都要耗费很多等待时间。</p><p><em>这就像一家创业公司，刚开始，创始人和员工之间工作关系其乐融融，但是随着创始人的能力和野心越来越大，逐渐和员工之间出现了差距，普通员工原来越跟不上CEO的脚步。老板的每一个命令，传到到基层员工之后，由于基层员工的理解能力、执行能力的欠缺，就会耗费很多时间。这也就无形中拖慢了整家公司的工作效率</em>。</p><p>可是，不能因为内存的读写速度慢，就不发展CPU技术了吧，总不能让内存成为计算机处理的瓶颈吧。</p><p>所以，人们想出来了一个好的办法，就是在CPU和内存之间增加高速缓存。缓存的概念大家都知道，就是保存一份数据拷贝。他的特点是速度快，内存小，并且昂贵。</p><p>那么，程序的执行过程就变成了：</p><p><strong>当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</strong></p><p><em>之后，这家公司开始设立中层管理人员，管理人员直接归CEO领导，领导有什么指示，直接告诉管理人员，然后就可以去做自己的事情了。管理人员负责去协调底层员工的工作。因为管理人员是了解手下的人员以及自己负责的事情的。所以，大多数时候，公司的各种决策，通知等，CEO只要和管理人员之间沟通就够了。</em></p><p>而随着CPU能力的不断提升，一层缓存就慢慢的无法满足要求了，就逐渐的衍生出多级缓存。</p><p>按照数据读取顺序和与CPU结合的紧密程度，CPU缓存可以分为一级缓存（L1），二级缓存（L3），部分高端CPU还具有三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。</p><p>这三种缓存的技术难度和制造成本是相对递减的，所以其容量也是相对递增的。</p><p>那么，在有了多级缓存之后，程序的执行就变成了：</p><p><strong>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。</strong></p><p><em>随着公司越来越大，老板要管的事情越来越多，公司的管理部门开始改革，开始出现高层，中层，底层等管理者。一级一级之间逐层管理。</em></p><p>单核CPU只含有一套L1，L2，L3缓存；</p><p>如果CPU含有多个核心，即多核CPU，则每个核心都含有一套L1（甚至和L2）缓存，而共享L3（或者和L2）缓存。</p><p><em>公司也分很多种，有些公司只有一个大Boss，他一个人说了算。但是有些公司有比如联席总经理、合伙人等机制。</em></p><p><em>单核CPU就像一家公司只有一个老板，所有命令都来自于他，那么就只需要一套管理班底就够了。</em></p><p><em>多核CPU就像一家公司是由多个合伙人共同创办的，那么，就需要给每个合伙人都设立一套供自己直接领导的高层管理人员，多个合伙人共享使用的是公司的底层员工。</em></p><p><em>还有的公司，不断壮大，开始差分出各个子公司。各个子公司就是多个CPU了，互相之前没有共用的资源。互不影响。</em></p><p>下图为一个单CPU双核的缓存结构。</p><p><img src="/assets/blogImg/4/11.jpg" alt="图片11"></p><p>随着计算机能力不断提升，开始支持多线程。那么问题就来了。我们分别来分析下单线程、多线程在单核CPU、多核CPU中的影响。</p><p><strong>单线程。</strong>cpu核心的缓存只被一个线程访问。缓存独占，不会出现访问冲突等问题。</p><p><strong>单核CPU，多线程。</strong>进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。但由于任何时刻只能有一个线程在执行，因此不会出现缓存访问冲突。</p><p><strong>多核CPU，多线程。</strong>每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的cache之间的数据就有可能不同。</p><p>在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p><p><em>如果这家公司的命令都是串行下发的话，那么就没有任何问题。</em></p><p><em>如果这家公司的命令都是并行下发的话，并且这些命令都是由同一个CEO下发的，这种机制是也没有什么问题。因为他的命令执行者只有一套管理体系。</em></p><p><em>如果这家公司的命令都是并行下发的话，并且这些命令是由多个合伙人下发的，这就有问题了。因为每个合伙人只会把命令下达给自己直属的管理人员，而多个管理人员管理的底层员工可能是公用的。</em></p><p><em>比如，合伙人1要辞退员工a，合伙人2要给员工a升职，升职后的话他再被辞退需要多个合伙人开会决议。两个合伙人分别把命令下发给了自己的管理人员。合伙人1命令下达后，管理人员a在辞退了员工后，他就知道这个员工被开除了。而合伙人2的管理人员2这时候在没得到消息之前，还认为员工a是在职的，他就欣然的接收了合伙人给他的升职a的命令。</em></p><p><img src="/assets/blogImg/4/12.jpg" alt="图片12"></p><h3 id="处理器优化和指令重排"><a href="#处理器优化和指令重排" class="headerlink" title="处理器优化和指令重排"></a>处理器优化和指令重排</h3><p>上面提到在在CPU和主存之间增加缓存，在多线程场景下会存在<strong>缓存一致性问题。</strong>除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是<strong>处理器优化。</strong></p><p>除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如Java虚拟机的即时编译器（JIT）也会做<strong>指令重排。</strong></p><p>可想而知，如果任由处理器优化和编译器对指令重排的话，就可能导致各种各样的问题。</p><p><em>关于员工组织调整的情况，如果允许人事部在接到多个命令后进行随意拆分乱序执行或者重排的话，那么对于这个员工以及这家公司的影响是非常大的。</em></p><h2 id="并发编程的问题"><a href="#并发编程的问题" class="headerlink" title="并发编程的问题"></a>并发编程的问题</h2><p>前面说的和硬件有关的概念你可能听得有点蒙，还不知道他到底和软件有啥关系。但是关于并发编程的问题你应该有所了解，比如原子性问题，可见性问题和有序性问题。</p><p>其实，原子性问题，可见性问题和有序性问题。是人们抽象定义出来的。而这个抽象的底层问题就是前面提到的缓存一致性问题、处理器优化问题和指令重排问题等。</p><p>这里简单回顾下这三个问题，并不准备深入展开，感兴趣的读者可以自行学习。我们说，并发编程，为了保证数据的安全，需要满足以下三个特性：</p><p><strong>原子性</strong>是指在一个操作中就是cpu不可以在中途暂停然后再调度，既不被中断操作，要不执行完成，要不就不执行。</p><p><strong>可见性</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p><strong>有序性</strong>即程序执行的顺序按照代码的先后顺序执行。</p><p>有没有发现，<strong>缓存一致性问题</strong>其实就是<strong>可见性问题</strong>。而<strong>处理器优化</strong>是可以导致<strong>原子性问题</strong>的。<strong>指令重排</strong>即会导致<strong>有序性问题</strong>。所以，后文将不再提起硬件层面的那些概念，而是直接使用大家熟悉的原子性、可见性和有序性。</p><h2 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h2><p>前面提到的，缓存一致性问题、处理器器优化的指令重排问题是硬件的不断升级导致的。那么，有没有什么机制可以很好的解决上面的这些问题呢？</p><p>最简单直接的做法就是废除处理器和处理器的优化技术、废除CPU缓存，让CPU直接和主存交互。但是，这么做虽然可以保证多线程下的并发问题。但是，这就有点因噎废食了。</p><p>所以，为了保证并发编程中可以满足原子性、可见性及有序性。有一个重要的概念，那就是——内存模型。</p><p><strong>为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。</strong>通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p><p>内存模型解决并发问题主要采用两种方式：<strong>限制处理器优化</strong>和<strong>使用内存屏障。</strong>本文就不深入底层原理来展开介绍了，感兴趣的朋友可以自行学习。</p><h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>前面介绍过了计算机内存模型，这是解决多线程场景下并发问题的一个重要规范。那么具体的实现是如何的呢，不同的编程语言，在实现上可能有所不同。</p><p>我们知道，Java程序是需要运行在Java虚拟机上面的，<strong>Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</strong></p><p>提到Java内存模型，一般指的是JDK 5 开始使用的新的内存模型，主要由JSR-133: JavaTM Memory Model and Thread Specification 描述。感兴趣的可以参看下这份PDF文档（<a href="http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）" target="_blank" rel="noopener">http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf）</a></p><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。</p><p>而JMM就作用于工作内存和主存之间数据同步过程。他规定了如何做数据同步以及什么时候做数据同步。</p><p><img src="/assets/blogImg/4/13.jpg" alt="图片13"></p><p>这里面提到的主内存和工作内存，读者可以简单的类比成计算机内存模型中的主存和缓存的概念。特别需要注意的是，主内存和工作内存与JVM内存结构中的Java堆、栈、方法区等并不是同一个层次的内存划分，无法直接类比。《深入理解Java虚拟机》中认为，如果一定要勉强对应起来的话，从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分。工作内存则对应于虚拟机栈中的部分区域。</p><p><strong>所以，再来总结下，JMM是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</strong></p><h2 id="Java内存模型的实现"><a href="#Java内存模型的实现" class="headerlink" title="Java内存模型的实现"></a>Java内存模型的实现</h2><p>了解Java多线程的朋友都知道，在Java中提供了一系列和并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p><p>在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，<strong>Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</strong></p><p>本文并不准备把所有的关键字逐一介绍其用法，因为关于各个关键字的用法，网上有很多资料。读者可以自行学习。本文还有一个重点要介绍的就是，我们前面提到，并发编程要解决原子性、有序性和一致性的问题，我们就再来看下，在Java中，分别使用什么方式来保证。</p><p><strong>原子性</strong></p><p>在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit。在synchronized的实现原理文章中，介绍过，这两个字节码，在Java中对应的关键字就是synchronized。</p><p>因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。</p><p><strong>可见性</strong></p><p>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p><p>Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p><p>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性。只不过实现方式不同，这里不再展开了。</p><p><strong>有序性</strong></p><p>在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：</p><p>volatile关键字会禁止指令重排。synchronized关键字保证同一时刻只允许一条线程操作。</p><p>好了，这里简单的介绍完了Java并发编程中解决原子性、可见性以及有序性可以使用的关键字。读者可能发现了，好像synchronized关键字是万能的，他可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。</p><p>但是synchronized是比较影响性能的，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在读完本文之后，相信你应该了解了什么是Java内存模型、Java内存模型的作用以及Java中内存模型做了什么事情等。</p><p>关于Java中这些和内存模型有关的关键字，希望读者还可以继续深入学习，并且自己写几个例子亲自体会一下。可以参考《深入理解Java虚拟机》和《Java并发编程的艺术》两本书。</p><p><img src="/assets/blogImg/4/14.png" alt="图片14"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自：Hollis（微信号：hollischuang）&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://mlone.top/categories/JVM/"/>
    
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
      <category term="JVM" scheme="https://mlone.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Array and Collection Framework</title>
    <link href="https://mlone.top/post/5495d47.html"/>
    <id>https://mlone.top/post/5495d47.html</id>
    <published>2018-10-03T10:21:32.000Z</published>
    <updated>2019-02-23T10:39:56.794Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/ada_dengpan/article/details/51200907" target="_blank" rel="noopener">https://blog.csdn.net/ada_dengpan/article/details/51200907</a></p><a id="more"></a><h3 id="Array数组"><a href="#Array数组" class="headerlink" title="Array数组"></a>Array数组</h3><pre><code>* （1）Array数组** 和C/C++以及其他语言一样，Java中的数组有差不多一样的语法* 只是Java中除了8种基本类型，数组也是作为对象处理的，所以创建对象时也需要使用new关键字* 和大多数编程语言一样，数组一旦创建，大小便不可改变* Java中有一个Arrays封装类，专门用来操作基本数组* Arrays中拥有一组static函数：*     --equals():比较两个array是否相等。array拥有相同元素个数，且所有对应元素两两相等*     --fill():将指定的数据类型填入array数组中*     --sort():用来对array数组进行排序*     --binarySearch():在排好的array数组中寻找元素*     --System.arraycopy():array数组的复制** int [] intArr = new int[10];*</code></pre><h3 id="Collection集合框架"><a href="#Collection集合框架" class="headerlink" title="Collection集合框架"></a>Collection集合框架</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><pre><code>* （2）Array是Java中随机访问一连串对象最有效率的数据结构，但很不灵活，大小固定，且不知道里面有多少元素* 为此JDK（）已经为我们提供了一系列的类来实现功能强大且更灵活的基本数据结构，这些类均在java.util包中。* 其继承结构如下：* --Collection（集合）**   --List（列表）*         --LinkedList（链表：链式存储）*         --ArrayList（线性表：顺序存储）*         --Vector（矢量）（已淘汰）*              --Stack（栈）**   --Set（集合）*         --HashSet*              --LinkedHashSet**         --TreeSet（实现了SortedSet接口）*   **   --Queue（队列）**   --Map（图）*         --HashTable（哈希表：散列表）（已淘汰）*         --HashMap（哈希图；散列表）*              --LinkedHashMap*         --TreeMap*         --WeakHashMap*         </code></pre><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><pre><code>* （2.1）List**              List是一个接口，不能实例化，若要实例化要通过创建ArrayList或LinkedList** （2.1.1）ArrayList里面的内部类实现，是通过一定的增长规则动态复制增加数组长度来实现动态增加元素的，*              如果在大量数据的情况下，在某一位置随机插入或删除元素，就会产生性能问题。** （2.1.2）LinkedList可以解决这类问题，但LinkedList在通过下标取元素的时候，一定要遍历整个链表节点匹配，*              在数据量大的情况下，效率不高。** （2.1.3）Vector是一种过时的动态数组，是线程同步的，效率很低，一般不赞成使用：**              Stack是Java实现了一个堆栈，先进后出（FILO）结构。**</code></pre><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><pre><code>** （2.2）Set*              Set接口继承Collection接口，最大的特点是集合中的元素都是唯一的，没有重复元素。*              它有两个类：HashSet和TreeSet**              （2.2.1）--HashSet*                    --不允许出现重复元素；*                    --不保证集合中元素的顺序都是哈希算法来的~*                    --允许包含值为null的元素，但最多只能有一个null元素。**              （2.2.2）--TreeSet*                    --不允许出现重复元素；*                    --集合中元素的顺序按某种规则进行排序；*                    --不允许包含值为null的元素**              （2.2.3）遍历时删除问题*              1、//使用迭代器遍历Set集合.*               Iterator&lt;String&gt; it  = set.iterator();*               while(it.hasNext()){*               String temp = it.next();*               System.out.println(&quot;元素：&quot;+ temp);*                it.remove();*                }*               2、//使用增强for循环解决 （底层实现还是迭代器）*                for(String item : set){*                System.out.println(&quot;元素：&quot;+ item);*                }*                *              使用增强for循环遍历List（所有实现子类ArrayList，Stack等）元素对其中元素进行删除，*              会抛出java.util.ConcurrentModificationException的异常�??*              若使用下面这种方式：*              for(int i= 0; i &lt; list.size(); i++){*                    list.remove(i);*              }*              则会删除下标为偶数的元素，因为每次删除后，后面的元素的下标全部减1,相当于元素位置全部左移一位，*              再次删除时，会跳过一个元素进行删除，这是非常不好的。*              如果非要这样删除，可以倒着来：*              for(int i = list.size()-1; i &gt;= 0; i--){*                         list.remove(i);*              }*              或者新建一个要删除的List，最后一起删除list.removeAll(deleteList);**</code></pre><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><pre><code>** （2.3）Map*         Map接口，没有继承Collection接口，它是一个独立的接口。使用key-value的键值对存储数据，*               常用的两个子类是HashMap和TreeMap。**         （2.3.1）--HashMap：Map基于散列表的实现。插入和查询“键值对”的位置是固定的，*                         可以通过构造器设置容量capacity和负载因子loadfactor，以调整容器的装载能力。**         （2.3.2）--LinkedHashMap：类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序*                         或者是最近最少使用（LRU）的次序。只比HashMap慢一点，*                         而在迭代访问时反而更快，因为它使用链表维护内部次序。**         （2.3.3）--TreeMap：基于红黑树数据结构的实现的，查看“键”或“键值对”时，它们会被排序（次序由Comparabel或Comparator决定）*                         TreeMap的特点在于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。**         （2.3.4）--WeakHashMap：弱键（weak key）Map，Map中使用的对象也被允许释放：这是为解决特殊问题设计的。*                         如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。**         （2.3.5）--IdentifyHashMap:使用==代替equals()对“键”作比较 hash map。专为解决特殊问题而设计的。*</code></pre><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><pre><code>* （3）线程安全**        Vector是线程同步的，也就是线程安全的，对多线程的操作采用了synchronized处理。但因为效率低已不建议使用，*        而ArrayList和LinkedList虽然是线程异步的、效率高，但都是线程不安全的，在多线程环境中，对数据的修改会造成错误的结果。** 有两种解决方案：*       （3.1）使用同步包装器**         List safedList = Collections.synchronizedList(new ArrayList());*         Set safedSet = Collections.synchronizedSet(new HashSet);*         Map safedMap = Collections.synchronizedSet(new HashSet);**         查看其源码，发现是Collections类给不安全的集合类包装了一层（即虚拟机自动给集合实现加锁接口），然后生成一个新的类*   新类里面采用了synchronized对集合的操作进行了同步处理*          public int size(){                     synchronized(mutex){return c.size();}            }            public boolean isEmpty(){                    synchronized(mutex){return c.isEmpty();}            }            public boolean contains(Object o){                     synchronized(mutex){return c.contains(o);}            }            public Object[] toArray(){                    synchronized(mutex){return c.toArray();}           }            public &lt;T&gt; T[] toArray(T[] a){                     synchronized(mutex){return c.toArray(a);}            }           public Iterator&lt;E&gt; iterator(){                     return c.iterator(); //Must be manually synched by uers!                                          //必须由用户手动同步            }           public boolean add(E e){                     synchronized(mutex){return c.add(e);}            }           public boolean remove(Object o){                     synchronized(mutex){return c.remove(o);}            }           public boolean containsAll(Collection&lt;?&gt; coll){                     synchronized(mutex){return c.containsAll(coll);}            }           public boolean addAll(Collection&lt;? extends E&gt; coll){                     synchronized(mutex){return c.addAll(coll);}            }           public boolean removeAll(Collection&lt;?&gt; coll){                     synchronized(mutex){return c.removeAll(coll);}            }           public boolean retainAll(Collection&lt;?&gt; coll){                     synchronized(mutex){return c.retainAll(coll);}            }           public void clear(){                     synchronized(mutex){c.clear();}            } *                     * * * *  （3.2）使用安全的集合： *         Java5.0新加入的ConcurrentLinkedQueue、ConcurrentHashMap *         CopyOnWriteArrayList和CopyOnWriteArraySet,这些集合类都是线程安全的。 *         都在java.util.concurrent包下。而至于这些新的类为什么能保证线程安全，这里不作详述。 *                     *     PS:concurrent *        adj.〈正式的;同时发生的;同时完成的;同时存在的。 *        n.[数] 共点;同时发生的事情 */</code></pre>]]></content>
    
    <summary type="html">
    
      java数组和集合框架
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="Java" scheme="https://mlone.top/tags/Java/"/>
    
      <category term="集合框架" scheme="https://mlone.top/tags/%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java RMI详解</title>
    <link href="https://mlone.top/post/d2873939.html"/>
    <id>https://mlone.top/post/d2873939.html</id>
    <published>2018-10-01T06:32:51.000Z</published>
    <updated>2019-02-23T12:56:12.450Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/a19881029/article/details/9465663" target="_blank" rel="noopener">https://blog.csdn.net/a19881029/article/details/9465663</a></p><a id="more"></a><p><strong>RMI:远程方法调用</strong>(Remote Method Invocation)：<em>能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法。</em></p><p><img src="/assets/blogImg/4/2.png" alt="图2"></p><p><strong>RMI远程调用步骤：</strong></p><p>1，客户对象调用客户端辅助对象上的方法</p><p>2，客户端辅助对象打包调用信息（变量，方法名），通过网络发送给服务端辅助对象</p><p>3，服务端辅助对象将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象</p><p>4，调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象</p><p>5，服务端辅助对象将结果打包，发送给客户端辅助对象</p><p>6，客户端辅助对象将返回值解包，返回给客户对象</p><p>7，客户对象获得返回值</p><p>对于客户对象来说，步骤2-6是完全透明的</p><p>搭建一个RMI服务的过程分为以下7步;</p><h4 id="1，创建远程方法接口，该接口必须继承自Remote接口"><a href="#1，创建远程方法接口，该接口必须继承自Remote接口" class="headerlink" title="1，创建远程方法接口，该接口必须继承自Remote接口"></a>1，创建远程方法接口，该接口必须继承自Remote接口</h4><p>Remote 接口是一个标识接口，用于标识所包含的方法可以从非本地虚拟机上调用的接口，Remote接口本身不包含任何方法</p><pre><code>package server;import java.rmi.Remote;import java.rmi.RemoteException;public interface Hello extends Remote {    public String sayHello(String name) throws RemoteException;}</code></pre><p>由于远程方法调用的本质依然是网络通信，只不过隐藏了底层实现，网络通信是经常会出现异常的，所以<strong>接口的所有方法都必须抛出RemoteException</strong>以说明该方法是有风险的</p><h4 id="2，创建远程方法接口实现类："><a href="#2，创建远程方法接口实现类：" class="headerlink" title="2，创建远程方法接口实现类："></a>2，创建远程方法接口实现类：</h4><p>UnicastRemoteObject类的构造函数抛出了RemoteException，故其继承类不能使用默认构造函数，<strong>继承类的构造函数必须也抛出RemoteException</strong></p><p>由于<strong>方法参数</strong>与<strong>返回值</strong>最终都将在网络上传输，故必须是<strong>可序列化的</strong></p><pre><code>package server;import java.rmi.RemoteException;import java.rmi.server.UnicastRemoteObject;public class HelloImpl extends UnicastRemoteObject implements Hello {    private static final long serialVersionUID = -271947229644133464L;    public HelloImpl() throws RemoteException{        super();    }    public String sayHello(String name) throws RemoteException {        return &quot;Hello,&quot;+name;    }}</code></pre><h4 id="3，利用java自带rmic工具生成sutb存根类-jdk1-5-0-15-bin-rmic"><a href="#3，利用java自带rmic工具生成sutb存根类-jdk1-5-0-15-bin-rmic" class="headerlink" title="3，利用java自带rmic工具生成sutb存根类(jdk1.5.0_15/bin/rmic)"></a>3，利用java自带rmic工具生成sutb存根类(jdk1.5.0_15/bin/rmic)</h4><p>jdk1.2以后的RMI可以通过反射API可以直接将请求发送给真实类，所以不需要skeleton类了</p><p>sutb存根为远程方法类在本地的代理，是在服务端代码的基础上生成的，需要HelloImpl.class文件，由于HelloImpl继承了Hello接口，故Hello.class文件也是不可少的</p><p>Test</p><p>– server</p><p>—- Hello.class</p><p>—- HelloImpl.class</p><p>方式一：</p><pre><code>[name@name Test]$ cd /home/name/Test/[name@name Test]$ rmic server.HelloImpl</code></pre><p>方式二：</p><pre><code>[name@name Test]$ rmic -classpath /home/name/Test server.HelloImpl</code></pre><p>运行成功后将会生成HelloImpl_Stub.class文件</p><h4 id="4，启动RMI注册服务-jdk1-5-0-15-bin-rmiregistry"><a href="#4，启动RMI注册服务-jdk1-5-0-15-bin-rmiregistry" class="headerlink" title="4，启动RMI注册服务(jdk1.5.0_15/bin/rmiregistry)"></a>4，启动RMI注册服务(jdk1.5.0_15/bin/rmiregistry)</h4><p>方式一：后台启动rmiregistry服务</p><pre><code>[name@name jdk]$ jdk1.5.0_15/bin/rmiregistry 12312 &amp;[1] 22720[name@name jdk]$ ps -ef|grep rmiregistryname    22720 13763  0 16:43 pts/3    00:00:00 jdk1.5.0_15/bin/rmiregistry 12312name    22737 13763  0 16:43 pts/3    00:00:00 grep rmiregistry</code></pre><p><strong>如果不带具体端口号，则默认为1099</strong></p><p>方式二：人工创建rmiregistry服务，需要在代码中添加：</p><pre><code>LocateRegistry.createRegistry(12312);</code></pre><h4 id="5，编写服务端代码"><a href="#5，编写服务端代码" class="headerlink" title="5，编写服务端代码"></a>5，编写服务端代码</h4><pre><code>package server;import java.rmi.Naming;import java.rmi.registry.LocateRegistry;public class HelloServer {    public static void main(String[] args) {        try{            Hello h = new HelloImpl();            //创建并导出接受指定port请求的本地主机上的Registry实例。            //LocateRegistry.createRegistry(12312);            /**    Naming 类提供在对象注册表中存储和获得远程对远程对象引用的方法             *  Naming 类的每个方法都可将某个名称作为其一个参数，             *  该名称是使用以下形式的 URL 格式（没有 scheme 组件）的 java.lang.String:             *  //host:port/name             *  host：注册表所在的主机（远程或本地)，省略则默认为本地主机             *  port：是注册表接受调用的端口号，省略则默认为1099，RMI注册表registry使用的著名端口             *  name：是未经注册表解释的简单字符串             */            //Naming.bind(&quot;//host:port/name&quot;, h);            Naming.bind(&quot;rmi://192.168.58.164:12312/Hello&quot;, h);            System.out.println(&quot;HelloServer启动成功&quot;);        }catch(Exception e){            e.printStackTrace();        }    }}</code></pre><p><strong>先创建注册表，然后才能在注册表中存储远程对象信息</strong></p><h4 id="6，运行服务端（58-164）："><a href="#6，运行服务端（58-164）：" class="headerlink" title="6，运行服务端（58.164）："></a>6，运行服务端（58.164）：</h4><p>Test</p><p>– server</p><p>—- Hello.class</p><p>—- HelloImpl.class</p><p>—- HelloServer.class</p><pre><code>[name@name ~]$ java server.HelloServerHelloServer 启动成功</code></pre><p>当然/home/name/Test一定要在系统CLASSPATH中，否则会报找不到相应的.class文件</p><h4 id="7，编写客户端代码"><a href="#7，编写客户端代码" class="headerlink" title="7，编写客户端代码"></a>7，编写客户端代码</h4><pre><code>package client;import java.net.MalformedURLException;import java.rmi.Naming;import java.rmi.NotBoundException;import java.rmi.RemoteException;import server.Hello;public class HelloClient {    public static void main(String[] args) {        try {            Hello h = (Hello)Naming.lookup(&quot;rmi://192.168.58.164:12312/Hello&quot;);            System.out.println(h.sayHello(&quot;zx&quot;));        } catch (MalformedURLException e) {            System.out.println(&quot;url格式异常&quot;);        } catch (RemoteException e) {            System.out.println(&quot;创建对象异常&quot;);            e.printStackTrace();        } catch (NotBoundException e) {            System.out.println(&quot;对象未绑定&quot;);        }    }}</code></pre><h4 id="8，运行客户端（58-163）："><a href="#8，运行客户端（58-163）：" class="headerlink" title="8，运行客户端（58.163）："></a>8，运行客户端（58.163）：</h4><p>Test</p><p>– client</p><p>—- HelloClient.class</p><p>– server</p><p>—- Hello.class</p><p>—- HelloImpl_Stub.class//服务端生成的存根文件</p><pre><code>[name@name client]$ java client.HelloClientHello,zx</code></pre><p>同服务器端，/home/name/Test一定要在系统CLASSPATH中</p><p><img src="/assets/blogImg/4/3.png" alt="图3"></p><p><strong>PS：</strong></p><p>1，客户端所在服务和服务端所在的服务器网络一定要通（一开始浪费了很多时间，最后才发现是网络不通）</p><p>2，所有代码在jdk1.5.0_15，Linux服务器上调试通过</p><p>3，如果java命令运行提示找不到类文件，则为CLASSPATH配置问题</p><pre><code>[name@name ~]$ vi .bash_profile JAVA_HOME=/home/name/jdk/jdk1.5.0_15export JAVA_HOMEPATH=$JAVA_HOME/bin:$PATHexport PATHCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:/home/name/Testexport CLASSPATH</code></pre><p>JAVA_HOME为jdk的根目录</p><p>PATH为java工具类路径(java，javac，rmic等)</p><p>CLASSPATH为java .class文件的存放路径，使用java命令运行.class文件时即会在该参数配置的路径下寻找相应文件</p><h4 id="java-RMI的缺点："><a href="#java-RMI的缺点：" class="headerlink" title="java RMI的缺点："></a>java RMI的缺点：</h4><p>1，从代码中也可以看到，代码依赖于ip与端口</p><p>2，RMI依赖于Java远程消息交换协议JRMP（Java Remote Messaging Protocol），该协议为java定制，要求服务端与客户端都为java编写</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/a19881029/article/details/9465663&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/a19881029/article/details/9465663&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="RMI" scheme="https://mlone.top/tags/RMI/"/>
    
  </entry>
  
  <entry>
    <title>java序列化(Serializable)的作用和反序列化</title>
    <link href="https://mlone.top/post/693bdb7c.html"/>
    <id>https://mlone.top/post/693bdb7c.html</id>
    <published>2018-10-01T05:20:13.000Z</published>
    <updated>2019-02-23T12:33:37.273Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/zero0/articles/1874841.html" target="_blank" rel="noopener">https://www.cnblogs.com/zero0/articles/1874841.html</a><br><a id="more"></a></p><p>这里转载一篇讲解java序列化(Serializable)和反序列化方面的感觉很好的文章。 </p><h3 id="1、序列化是干什么的？"><a href="#1、序列化是干什么的？" class="headerlink" title="1、序列化是干什么的？"></a>1、序列化是干什么的？</h3><p>简单说就是为了<strong>保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。</strong>虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 </p><h3 id="2、什么情况下需要序列化"><a href="#2、什么情况下需要序列化" class="headerlink" title="2、什么情况下需要序列化"></a>2、什么情况下需要序列化</h3><p><strong>a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</strong></p><p><strong>b）当你想用套接字在网络上传送对象的时候；</strong> </p><p><strong>c）当你想通过RMI传输对象的时候；</strong></p><h3 id="6、相关注意事项"><a href="#6、相关注意事项" class="headerlink" title="6、相关注意事项"></a>6、相关注意事项</h3><p><em>a）序列化时，只对对象的状态进行保存，而不管对象的方法；</em> </p><p><em>b）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口</em>； </p><p><em>c）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化；</em> </p><p><em>d）并非所有的对象都可以序列化。</em></p><p>至于为什么不可以，有很多原因了,比如： </p><p>1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输  等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。</p><p>2.资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现。 </p><h3 id="详细描述"><a href="#详细描述" class="headerlink" title="详细描述:"></a>详细描述:</h3><p>序列化的过程就是对象写入字节流和从字节流中读取对象。将对象状态转换成字节流之后，可以用java.io包中的各种字节流类将其保存到文件中，管道到另一 线程中或通过网络连接将对象数据发送到另一主机。对象序列化功能非常简单、强大，在RMI、Socket、JMS、EJB都有应用。对象序列化问题在网络 编程中并不是最激动人心的课题，但却相当重要，具有许多实用意义。 </p><p>一：对象序列化可以实现分布式对象。主要应用例如：RMI要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。 </p><p>二：java 对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用 对象序列化可以进行对象的“深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。 </p><p>从上面的叙述中，我们知道了对象序列化是java编程中的必备武器，那么让我们从基础开始，好好学习一下它的机制和用法。 </p><p>java序列化比较简单，通常不需要编写保存和恢复对象状态的定制代码。实现java.io.Serializable接口的类对象可以转换成字 节流或从 字节流恢复，不需要在类中增加任何代码。只有极少数情况下才需要定制代码保存或恢复对象状态。这里要注意：不是每个类都可序列化，有些类是不能序列化的， 例如涉及线程的类与特定JVM有非常复杂的关系。 </p><h3 id="序列化机制："><a href="#序列化机制：" class="headerlink" title="序列化机制："></a>序列化机制：</h3><p>序列化分为两大部分：序列化和反序列化。<br>序列化是这 个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。<br>反序列化就是打开字节流并重构对象。</p><p>对象序列化不仅要将基本数据类型转换成字节 表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。ObjectOutputStream中的序列化过程与字节流连接，包括对象类型和版本信 息。</p><p>反序列化时，JVM用头信息生成对象实例，然后将对象字节流中的数据复制到对象数据成员中。下面我们分两大部分来阐述： </p><h3 id="处理对象流："><a href="#处理对象流：" class="headerlink" title="处理对象流："></a>处理对象流：</h3><p>（序列化过程和反序列化过程） </p><p>java.io包有两个序列化对象的类。ObjectOutputStream负责将对象写入字节流，ObjectInputStream从字节流重构对象。 </p><p>我们先了解ObjectOutputStream类吧。ObjectOutputStream类扩展DataOutput接口。<br>writeObject() 方法是最重要的方法，用于对象序列化。如果对象包含其他对象的引用，则writeObject()方法递归序列化这些对象。每个 ObjectOutputStream维护序列化的对象引用表，防止发送同一对象的多个拷贝。（这点很重要）由于writeObject()可以序列化整 组交叉引用的对象，因此同一ObjectOutputStream实例可能不小心被请求序列化同一对象。这时，进行反引用序列化，而不是再次写入对象字节 流。<br>下面，让我们从例子中来了解ObjectOutputStream这个类吧。</p><pre><code>// 序列化 today’s date 到一个文件中. FileOutputStream f = new FileOutputStream(“tmp”);     //创建一个包含恢复对象(即对象进行反序列化信息)的”tmp”数据文件 ObjectOutputStream s = new ObjectOutputStream(f); s.writeObject(“Today”);    //写入字符串对象; s.writeObject(new Date());    //写入瞬态对象; s.flush(); </code></pre><p>现在，让我们来了解ObjectInputStream这个类。它与ObjectOutputStream相似。它扩展DataInput接口。 ObjectInputStream中的方法镜像DataInputStream中读取Java基本数据类型的公开方法。readObject()方法从 字节流中反序列化对象。每次调用readObject()方法都返回流中下一个Object。对象字节流并不传输类的字节码，而是包括类名及其签名。 readObject()收到对象时，JVM装入头中指定的类。如果找不到这个类，则readObject()抛出 ClassNotFoundException,如果需要传输对象数据和字节码，则可以用RMI框架。ObjectInputStream的其余方法用于 定制反序列化过程。<br>例子如下： </p><pre><code>//从文件中反序列化 string 对象和 date 对象 FileInputStream in = new FileInputStream(“tmp”); ObjectInputStream s = new ObjectInputStream(in); String today = (String)s.readObject();   //恢复对象; Date date = (Date)s.readObject(); </code></pre><h3 id="定制序列化过程"><a href="#定制序列化过程" class="headerlink" title="定制序列化过程:"></a>定制序列化过程:</h3><p>序列化通常可以自动完成，但有时可能要对这个过程进行控制。java可以将类声明为serializable，但仍可手工控制声明为static或transient的数据成员。 </p><p>例子：一个非常简单的序列化类。 </p><pre><code>public class simpleSerializableClass implements Serializable{     String sToday=”Today:”;     transient Date dtToday=new Date(); } </code></pre><p>序列化时，类的所有数据成员应可序列化除了声明为transient或static的成员。将变量声明为transient告诉JVM我们会负责将变元序列 化。将数据成员声明为transient后，序列化过程就无法将其加进对象字节流中，没有从transient数据成员发送的数据。后面数据反序列化时， 要重建数据成员（因为它是类定义的一部分），但不包含任何数据，因为这个数据成员不向流中写入任何数据。记住，对象流不序列化static或 transient。我们的类要用writeObject()与readObject()方法以处理这些数据成员。使用writeObject()与 readObject()方法时，还要注意按写入的顺序读取这些数据成员。</p><p>关于如何使用定制序列化的部分代码如下：</p><pre><code>//重写writeObject()方法以便处理transient的成员。 public void writeObject(ObjectOutputStream outputStream) throws IOException{     outputStream.defaultWriteObject(); //使定制的writeObject()方法可以利用自动序列化中内置的逻辑。     outputStream.writeObject(oSocket.getInetAddress());     outputStream.writeInt(oSocket.getPort()); } //重写readObject()方法以便接收transient的成员。 private void readObject(ObjectInputStream inputStream) throws IOException,ClassNotFoundException{     inputStream.defaultReadObject(); //defaultReadObject()补充自动序列化     InetAddress oAddress=(InetAddress)inputStream.readObject();     int iPort =inputStream.readInt();     oSocket = new Socket(oAddress,iPort);     iID=getID();     dtToday =new Date(); } </code></pre><h3 id="完全定制序列化过程"><a href="#完全定制序列化过程" class="headerlink" title="完全定制序列化过程:"></a>完全定制序列化过程:</h3><p>如果一个类要完全负责自己的序列化，则实现Externalizable接口而不是Serializable接口。Externalizable接口定义包 括两个方法writeExternal()与readExternal()。利用这些方法可以控制对象数据成员如何写入字节流.类实现 Externalizable时，头写入对象流中，然后类完全负责序列化和恢复数据成员，除了头以外，根本没有自动序列化。这里要注意了。声明类实现 Externalizable接口会有重大的安全风险。writeExternal()与readExternal()方法声明为public，恶意类可 以用这些方法读取和写入对象数据。如果对象包含敏感信息，则要格外小心。这包括使用安全套接或加密整个字节流。</p><p>到此为至，我们学习了序列化的基础部分知识。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/zero0/articles/1874841.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zero0/articles/1874841.html&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="序列化" scheme="https://mlone.top/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Callable、Future和FutureTask</title>
    <link href="https://mlone.top/post/6e36e91a.html"/>
    <id>https://mlone.top/post/6e36e91a.html</id>
    <published>2018-09-28T14:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.772Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/dolphin0520/p/3949310.html" target="_blank" rel="noopener">Java并发编程：Callable、Future和FutureTask</a></p><a id="more"></a><p>　　在前面的文章中我们讲述了创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。</p><p>　　这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。</p><p>　　如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>　　而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p><p>　　今天我们就来讨论一下Callable、Future和FutureTask三个类的使用方法。以下是本文的目录大纲：</p><p>　　一.Callable与Runnable</p><p>　　二.Future</p><p>　　三.FutureTask</p><p>　　四.使用示例</p><h2 id="一-Callable与Runnable"><a href="#一-Callable与Runnable" class="headerlink" title="一.Callable与Runnable"></a>一.Callable与Runnable</h2><p>　先说一下java.lang.Runnable吧，它是一个接口，在它里面只声明了一个run()方法：</p><pre><code>public interface Runnable {    public abstract void run();}</code></pre><p>　　由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p><p>　　Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：</p><pre><code>public interface Callable&lt;V&gt; {    /**     * Computes a result, or throws an exception if unable to do so.     *     * @return computed result     * @throws Exception if unable to compute a result     */    V call() throws Exception;}</code></pre><p> 　　可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p><p>　　那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本:</p><pre><code>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);</code></pre><p>　　第一个submit方法里面的参数类型就是Callable。</p><p>　　暂时只需要知道Callable一般是和ExecutorService配合来使用的，具体的使用方法讲在后面讲述。</p><p>　　一般情况下我们使用第一个submit方法和第三个submit方法，第二个submit方法很少使用。</p><h2 id="二-Future"><a href="#二-Future" class="headerlink" title="二.Future"></a>二.Future</h2><p>　　Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p><p>　　Future类位于java.util.concurrent包下，它是一个接口：</p><pre><code>public interface Future&lt;V&gt; {    boolean cancel(boolean mayInterruptIfRunning);    boolean isCancelled();    boolean isDone();    V get() throws InterruptedException, ExecutionException;    V get(long timeout, TimeUnit unit)        throws InterruptedException, ExecutionException, TimeoutException;}</code></pre><p>　　在Future接口中声明了5个方法，下面依次解释每个方法的作用：</p><ul><li>cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</li><li>isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</li><li>isDone方法表示任务是否已经完成，若任务完成，则返回true；</li><li>get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</li><li>get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</li></ul><p>　　也就是说Future提供了三种功能：</p><p>　　1）判断任务是否完成；</p><p>　　2）能够中断任务；</p><p>　　3）能够获取任务执行结果。</p><p>　　因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p><h2 id="三-FutureTask"><a href="#三-FutureTask" class="headerlink" title="三.FutureTask"></a>三.FutureTask</h2><p>　　我们先来看一下FutureTask的实现：</p><pre><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</code></pre><p>　　FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：</p><pre><code>public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {    void run();}</code></pre><p> 　　可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><p>　　FutureTask提供了2个构造器：</p><pre><code>public FutureTask(Callable&lt;V&gt; callable) {}public FutureTask(Runnable runnable, V result) {}</code></pre><p>事实上，FutureTask是Future接口的一个唯一实现类。</p><h2 id="四-使用示例"><a href="#四-使用示例" class="headerlink" title="四.使用示例"></a>四.使用示例</h2><p>　<strong>1.使用Callable+Future获取执行结果</strong></p><pre><code>public class Test {    public static void main(String[] args) {        ExecutorService executor = Executors.newCachedThreadPool();        Task task = new Task();        Future&lt;Integer&gt; result = executor.submit(task);        executor.shutdown();        try {            Thread.sleep(1000);        } catch (InterruptedException e1) {            e1.printStackTrace();        }        System.out.println(&quot;主线程在执行任务&quot;);        try {            System.out.println(&quot;task运行结果&quot;+result.get());        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        System.out.println(&quot;所有任务执行完毕&quot;);    }}</code></pre><p>.</p><pre><code>class Task implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        System.out.println(&quot;子线程在进行计算&quot;);        Thread.sleep(3000);        int sum = 0;        for(int i=0;i&lt;100;i++)            sum += i;        return sum;    }}</code></pre><p> 　　执行结果：</p><pre><code>子线程在进行计算主线程在执行任务task运行结果4950所有任务执行完毕</code></pre><p>　　<strong>2.使用Callable+FutureTask获取执行结果</strong></p><pre><code>public class Test {    public static void main(String[] args) {        //第一种方式        ExecutorService executor = Executors.newCachedThreadPool();        Task task = new Task();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);        executor.submit(futureTask);        executor.shutdown();        //第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread        /*Task task = new Task();        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);        Thread thread = new Thread(futureTask);        thread.start();*/        try {            Thread.sleep(1000);        } catch (InterruptedException e1) {            e1.printStackTrace();        }        System.out.println(&quot;主线程在执行任务&quot;);        try {            System.out.println(&quot;task运行结果&quot;+futureTask.get());        } catch (InterruptedException e) {            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        System.out.println(&quot;所有任务执行完毕&quot;);    }}</code></pre><p>.</p><pre><code>class Task implements Callable&lt;Integer&gt;{    @Override    public Integer call() throws Exception {        System.out.println(&quot;子线程在进行计算&quot;);        Thread.sleep(3000);        int sum = 0;        for(int i=0;i&lt;100;i++)            sum += i;        return sum;    }}</code></pre><p>如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3949310.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java并发编程：Callable、Future和FutureTask&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal详解</title>
    <link href="https://mlone.top/post/443887f3.html"/>
    <id>https://mlone.top/post/443887f3.html</id>
    <published>2018-09-27T14:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.781Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/dreamroute/p/5034726.html" target="_blank" rel="noopener">https://www.cnblogs.com/dreamroute/p/5034726.html</a></p><a id="more"></a><p>　　ThreadLocal翻译成中文比较准确的叫法应该是：线程局部变量。</p><p>　　这个玩意有什么用处，或者说为什么要有这么一个东东？先解释一下，在并发编程的时候，成员变量如果不做任何处理其实是线程不安全的，各个线程都在操作同一个变量，显然是不行的，并且我们也知道volatile这个关键字也是不能保证线程安全的。那么在有一种情况之下，我们需要满足这样一个条件：变量是同一个，但是每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本。这种情况之下ThreadLocal就非常使用，比如说DAO的数据库连接，我们知道DAO是单例的，那么他的属性Connection就不是一个线程安全的变量。而我们每个线程都需要使用他，并且各自使用各自的。这种情况，ThreadLocal就比较好的解决了这个问题。</p><p>　　我们从源码的角度来分析这个问题。</p><p>　　首先定义一个ThreadLocal：</p><pre><code>public final class ConnectionUtil {    private ConnectionUtil() {}    private static final ThreadLocal&lt;Connection&gt; conn = new ThreadLocal&lt;&gt;();    public static Connection getConn() {        Connection con = conn.get();        if (con == null) {            try {                Class.forName(&quot;com.mysql.jdbc.Driver&quot;);                con = DriverManager.getConnection(&quot;url&quot;, &quot;userName&quot;, &quot;password&quot;);                conn.set(con);            } catch (ClassNotFoundException | SQLException e) {                // ...            }        }        return con;    }}</code></pre><p>　　这样子，都是用同一个连接，但是每个连接都是新的，是同一个连接的副本。</p><p>　　那么实现机制是如何的呢？</p><p>　　1、每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个ThreadLocal。</p><pre><code>/* ThreadLocal values pertaining to this thread. This map is maintained  * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;</code></pre><p>　　2、当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。</p><pre><code>public T get() {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null)            return (T)e.value;    }    return setInitialValue();}</code></pre><p>　　3、当我们调用set()方法的时候，很常规，就是将值设置进ThreadLocal中。</p><p>　　4、总结：当我们调用get方法的时候，其实每个当前线程中都有一个ThreadLocal。每次获取或者设置都是对该ThreadLocal进行的操作，是与其他线程分开的。</p><p>　　5、应用场景：当很多线程需要多次使用同一个对象，并且需要该对象具有相同初始化值的时候最适合使用ThreadLocal。</p><p>　　6、其实说再多也不如看一下源码来得清晰。如果要看源码，其中涉及到一个WeakReference和一个Map，这两个地方需要了解下，这两个东西分别是a.Java的弱引用，也就是GC的时候会销毁该引用所包裹(引用)的对象，这个threadLocal作为key可能被销毁，但是只要我们定义成他的类不卸载，tl这个强引用就始终引用着这个ThreadLocal的，永远不会被gc掉。b.和HashMap差不多。</p><p>　　事实上，从本质来讲，就是每个线程都维护了一个map，而这个map的key就是threadLocal，而值就是我们set的那个值，每次线程在get的时候，都从自己的变量中取值，既然从自己的变量中取值，那肯定就不存在线程安全问题，总体来讲，ThreadLocal这个变量的状态根本没有发生变化，他仅仅是充当一个key的角色，另外提供给每一个线程一个初始值。如果允许的话，我们自己就能实现一个这样的功能，只不过恰好JDK就已经帮我们做了这个事情。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/dreamroute/p/5034726.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/dreamroute/p/5034726.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>join方法简单总结</title>
    <link href="https://mlone.top/post/318e1afb.html"/>
    <id>https://mlone.top/post/318e1afb.html</id>
    <published>2018-09-22T14:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.786Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/lcplcpjava/p/6896904.html" target="_blank" rel="noopener">java 线程方法join的简单总结</a></p><a id="more"></a><p>　　虽然关于讨论线程join方法的博客已经很多了，不过个人感觉挺多都讨论得不够全面，所以我觉得有必要对其进行一个全面的总结。</p><h2 id="一、作用"><a href="#一、作用" class="headerlink" title="一、作用"></a>一、作用</h2><p>　　Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并行执行变为串行执行。具体看代码：</p><pre><code>public class JoinTest {    public static void main(String [] args) throws InterruptedException {        ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);        ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);        t1.start();        /**join的意思是使得放弃当前线程的执行，并返回对应的线程，例如下面代码的意思就是：         程序在main线程中调用t1线程的join方法，则main线程放弃cpu控制权，并返回t1线程继续执行直到线程t1执行完毕         所以结果是t1线程执行完后，才到主线程执行，相当于在main线程中同步t1线程，t1执行完了，main线程才有执行的机会         */        t1.join();        t2.start();    }}class ThreadJoinTest extends Thread{    public ThreadJoinTest(String name){        super(name);    }    @Override    public void run(){        for(int i=0;i&lt;1000;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>上面程序结果是先打印完小明线程，在打印小东线程；　　</p><p>　　上面注释也大概说明了join方法的作用：在A线程中调用了B线程的join()方法时，表示只有当B线程执行完毕时，A线程才能继续执行。注意，这里调用的join方法是没有传参的，join方法其实也可以传递一个参数给它的，具体看下面的简单例子：</p><pre><code>public class JoinTest {    public static void main(String [] args) throws InterruptedException {        ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);        ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);        t1.start();        /**join方法可以传递参数，join(10)表示main线程会等待t1线程10毫秒，10毫秒过去后，         * main线程和t1线程之间执行顺序由串行执行变为普通的并行执行         */        t1.join(10);        t2.start();    }}class ThreadJoinTest extends Thread{    public ThreadJoinTest(String name){        super(name);    }    @Override    public void run(){        for(int i=0;i&lt;1000;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>上面代码结果是：程序执行前面10毫秒内打印的都是小明线程，10毫秒后，小明和小东程序交替打印。</p><p>　　所以，join方法中如果传入参数，则表示这样的意思：如果A线程中掉用B线程的join(10)，则表示A线程会等待B线程执行10毫秒，10毫秒过后，A、B线程并行执行。需要注意的是，jdk规定，join(0)的意思不是A线程等待B线程0秒，而是A线程等待B线程无限时间，直到B线程执行完毕，即join(0)等价于join()。　　</p><h2 id="二、join与start调用顺序问题"><a href="#二、join与start调用顺序问题" class="headerlink" title="二、join与start调用顺序问题"></a>二、join与start调用顺序问题</h2><p>　　上面的讨论大概知道了join的作用了，那么，入股 join在start前调用，会出现什么后果呢？先看下面的测试结果</p><pre><code>public class JoinTest {    public static void main(String [] args) throws InterruptedException {        ThreadJoinTest t1 = new ThreadJoinTest(&quot;小明&quot;);        ThreadJoinTest t2 = new ThreadJoinTest(&quot;小东&quot;);        /**join方法可以在start方法前调用时，并不能起到同步的作用         */        t1.join();        t1.start();        //Thread.yield();        t2.start();    }}class ThreadJoinTest extends Thread{    public ThreadJoinTest(String name){        super(name);    }    @Override    public void run(){        for(int i=0;i&lt;1000;i++){            System.out.println(this.getName() + &quot;:&quot; + i);        }    }}</code></pre><p>上面代码执行结果是：小明和小东线程交替打印。</p><p>　　所以得到以下结论：join方法必须在线程start方法调用之后调用才有意义。这个也很容易理解：如果一个线程都没有start，那它也就无法同步了。</p><h2 id="三、join方法实现原理"><a href="#三、join方法实现原理" class="headerlink" title="三、join方法实现原理"></a>三、join方法实现原理</h2><p>　　有了上面的例子，我们大概知道join方法的作用了，那么，join方法实现的原理是什么呢？</p><p>　　其实，join方法是通过调用线程的wait方法来达到同步的目的的。例如，A线程中调用了B线程的join方法，则相当于A线程调用了B线程的wait方法，在调用了B线程的wait方法后，A线程就会进入阻塞状态，具体看下面的源码：</p><pre><code>public final synchronized void join(long millis)    throws InterruptedException {        long base = System.currentTimeMillis();        long now = 0;        if (millis &lt; 0) {            throw new IllegalArgumentException(&quot;timeout value is negative&quot;);        }        if (millis == 0) {            while (isAlive()) {                wait(0);            }        } else {            while (isAlive()) {                long delay = millis - now;                if (delay &lt;= 0) {                    break;                }                wait(delay);                now = System.currentTimeMillis() - base;            }        }    }}</code></pre><p>　　从源码中可以看到：<strong>join方法的原理就是调用相应线程的wait方法进行等待操作的，</strong>例如A线程中调用了B线程的join方法，则相当于在A线程中调用了B线程的wait方法，当B线程执行完（或者到达等待时间），B线程会自动调用自身的notifyAll方法唤醒A线程，从而达到同步的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/lcplcpjava/p/6896904.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;java 线程方法join的简单总结&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>wait和sleep方法的区别</title>
    <link href="https://mlone.top/post/16df4c2a.html"/>
    <id>https://mlone.top/post/16df4c2a.html</id>
    <published>2018-09-21T12:39:28.000Z</published>
    <updated>2019-02-25T14:42:03.787Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://www.cnblogs.com/loren-Yang/p/7538482.html" target="_blank" rel="noopener">https://www.cnblogs.com/loren-Yang/p/7538482.html</a></p><a id="more"></a><h2 id="1、两者的区别"><a href="#1、两者的区别" class="headerlink" title="1、两者的区别"></a>1、两者的区别</h2><ul><li>这两个方法来自不同的类分别是Thread和Object  </li><li>最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法(锁代码块和方法锁)。</li><li>wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用(使用范围)</li><li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常  </li><li>sleep方法属于Thread类中方法，表示让一个线程进入睡眠状态，等待一定的时间之后，自动醒来进入到可运行状态，不会马上进入运行状态，因为线程调度机制恢复线程的运行也需要时间，一个线程对象调用了sleep方法之后，并不会释放他所持有的所有对象锁，所以也就不会影响其他进程对象的运行。但在sleep的过程中过程中有可能被其他对象调用它的interrupt(),产生InterruptedException异常，如果你的程序不捕获这个异常，线程就会异常终止，进入TERMINATED状态，如果你的程序捕获了这个异常，那么程序就会继续执行catch语句块(可能还有finally语句块)以及以后的代码。  </li><li>注意sleep()方法是一个静态方法，也就是说他只对当前对象有效，通过t.sleep()让t对象进入sleep，这样的做法是错误的，它只会是使当前线程被sleep 而不是t线程 </li><li>wait属于Object的成员方法，一旦一个对象调用了wait方法，必须要采用notify()和notifyAll()方法唤醒该进程;如果线程拥有某个或某些对象的同步锁，那么在调用了wait()后，这个线程就会释放它持有的所有同步资源，而不限于这个被调用了wait()方法的对象。wait()方法也同样会在wait的过程中有可能被其他对象调用interrupt()方法而产生 </li></ul><p>　　如果线程A希望立即结束线程B，则可以对线程B对应的Thread实例调用interrupt方法。如果此刻线程B正在wait/sleep/join，则线程B会立刻抛出InterruptedException，在catch() {} 中直接return即可安全地结束线程。</p><p>　　需要注意的是，InterruptedException是线程自己从内部抛出的，并不是interrupt()方法抛出的。对某一线程调用interrupt()时，如果该线程正在执行普通的代码，那么该线程根本就不会抛出InterruptedException。但是，一旦该线程进入到wait()/sleep()/join()后，就会立刻抛出InterruptedException。</p><p>　　waite()和notify()因为会对对象的“锁标志”进行操作，所以它们必须在synchronized函数或synchronized block中进行调用。如果在non-synchronized函数或non-synchronizedblock中进行调用，虽然能编译通过，但在运行时会发生illegalMonitorStateException的异常。</p><h2 id="补充两个重要的方法：-yield-和join"><a href="#补充两个重要的方法：-yield-和join" class="headerlink" title="补充两个重要的方法： yield()和join()"></a>补充两个重要的方法： yield()和join()</h2><p>　　yield方法暂停当前正在执行的线程对象。  </p><p>　　yield()方法是停止当前线程，让同等优先权的线程或更高优先级的线程有执行的机会。如果没有的话，那么yield()方法将不会起作用，并且由可执行状态后马上又被执行。   </p><p>　　join方法是用于在某一个线程的执行过程中调用另一个线程执行，等到被调用的线程执行结束后，再继续执行当前线程。</p><p>　　如：</p><pre><code>t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。 </code></pre><h2 id="说一下为什么使用wait-方法时，一般是需要while循环而不是if？"><a href="#说一下为什么使用wait-方法时，一般是需要while循环而不是if？" class="headerlink" title="说一下为什么使用wait()方法时，一般是需要while循环而不是if？"></a>说一下为什么使用wait()方法时，一般是需要while循环而不是if？</h2><pre><code>while(!执行条件） {    wait();}....if(!执行条件） {    wait();}....</code></pre><p>　　while会一直执行循环，直到条件满足，执行条件才会继续往下执行。if只会执行一次判断条件，不满足就会等待。这样就会出现问题。</p><p>　　我们知道用notify() 和notifyAll()可以唤醒线程，一般我们常用的是notifyAll()，因为notify()，只会随机唤醒一个睡眠线程，并不一定是我们想要唤醒的线程。如果使用的是notifyAll()，唤醒所有的线程，那你怎么知道他想唤醒的是某个正在等待的wait()线程呢，如果用while()方法，就会再次判断条件是不是成立，满足执行条件了，就会接着执行，而if会直接唤醒wait()方法，继续往下执行，根本不管这个notifyAll()是不是想唤醒的是自己还是别人，可能此时if的条件根本没成立。</p><p>举个例子：</p><p>　　while去水果店买苹果，没有了，然后while就和水果店老板说，有水果的时候通知我，我先回去了。if也去水果店买苹果，没有了，然后if就和水果店老板说，有水果的时候通知我，我先回去了。过一段时间，水果店老板发短信告诉while和if，有水果了，while去一看，水果店只是进了香蕉，并不是苹果，所以不是想要的水果，于是回去继续等水果店老板通知，而if根本就不看是不是自己想要的苹果，直接就叫老板送10斤水果过来，这样会导致你得到错误的结果。</p><p>参考文献：</p><p><a href="http://wkf41068.iteye.com/blog/1835697" target="_blank" rel="noopener">Java中wait 和sleep 方法比较</a></p><p><a href="http://blog.csdn.net/clam_clam/article/details/6803667" target="_blank" rel="noopener">JAVA-sleep()和wait()的区别</a></p><p><a href="http://www.cnblogs.com/hongten/p/hongten_java_sleep_wait.html" target="_blank" rel="noopener">java中的sleep()和wait()的区别</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://www.cnblogs.com/loren-Yang/p/7538482.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/loren-Yang/p/7538482.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>早绑定与晚绑定</title>
    <link href="https://mlone.top/post/72dff8df.html"/>
    <id>https://mlone.top/post/72dff8df.html</id>
    <published>2018-09-20T01:00:07.000Z</published>
    <updated>2019-02-23T10:22:12.406Z</updated>
    
    <content type="html"><![CDATA[<p>静态绑定（早绑定）：<br>程序在编译阶段根据参数个数确定调用哪个函数（重载）。<br><a id="more"></a><br>动态绑定（晚绑定）：<br>以封装和继承为基础，将成员函数和析构函数声明为虚函数（virtual）。<br>构造函数不能声明为virtual：</p><pre><code>Shape *shape1 = new Circle(3.5, 4.0);shape -&gt; calcArea(); //父类指针调用子类面积函数delete Shape1；//先调用子类析构函数，再调用父类析构函数shape1 = NULL;return 0;</code></pre><p>C++:</p><pre><code>virtual double cost()=0; //纯虚函数</code></pre><p>纯虚函数在类内声明，在类内或类外定义函数，而纯虚函数无函数体。<br>含有纯虚函数的类称为抽象类；<br>只含有纯虚函数的类称为接口类（没有任何数据成员）。</p><p>Java:    通过”abstract”关键字实现多态。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;静态绑定（早绑定）：&lt;br&gt;程序在编译阶段根据参数个数确定调用哪个函数（重载）。&lt;br&gt;
    
    </summary>
    
      <category term="笔记" scheme="https://mlone.top/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="https://mlone.top/tags/Java/"/>
    
      <category term="C++" scheme="https://mlone.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>wait、notify/notifyAll详解</title>
    <link href="https://mlone.top/post/362a4e44.html"/>
    <id>https://mlone.top/post/362a4e44.html</id>
    <published>2018-09-19T12:39:28.000Z</published>
    <updated>2019-02-25T14:42:03.784Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/moongeek/p/7631447.html" target="_blank" rel="noopener">Java多线程学习之wait、notify/notifyAll 详解</a></p><a id="more"></a><p><strong>1、wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。</strong></p><p><strong>2、wait()使当前线程阻塞，前提是 必须先获得锁，一般配合synchronized 关键字使用，即，一般在synchronized 同步代码块里使用 wait()、notify/notifyAll() 方法。</strong></p><p><strong>3、 由于 wait()、notify/notifyAll() 在synchronized 代码块执行，说明当前线程一定是获取了锁的。</strong></p><p>　　<em>当线程执行wait()方法时候，会释放当前的锁，然后让出CPU，进入等待状态。</em></p><p>　　<em>只有当 notify/notifyAll() 被执行时候，才会唤醒一个或多个正处于等待状态的线程，然后继续往下执行，直到执行完synchronized 代码块的代码或是中途遇到wait() ，再次释放锁</em>。</p><p>　　也就是说，notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程。</p><p><strong>4、wait() 需要被try catch包围，中断也可以使wait等待的线程唤醒。</strong></p><p><strong>5、notify 和wait 的顺序不能错，如果A线程先执行notify方法，B线程在执行wait方法，那么B线程是无法被唤醒的。</strong></p><p><strong>6、notify 和 notifyAll的区别</strong></p><p>　　<em>notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于操作系统对多线程管理的实现。notifyAll 会唤醒所有等待(对象的)线程，尽管哪一个线程将会第一个处理取决于操作系统的实现。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行。</em></p><p><strong>7、在多线程中要测试某个条件的变化，使用if 还是while？</strong></p><p>　　要注意，notify唤醒沉睡的线程后，<strong>线程会接着上次的执行继续往下执行。所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑，显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while来执行，以确保条件满足和一定执行。</strong>如下代码：</p><pre><code>public class K {    //状态锁    private Object lock;    //条件变量    private int now,need;    public void produce(int num){        //同步        synchronized (lock){           //当前有的不满足需要，进行等待            while(now &lt; need){                try {                    //等待阻塞                    wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }                System.out.println(&quot;我被唤醒了！&quot;);            }           // 做其他的事情        }    }}</code></pre><p>　　显然，只有当前值满足需要值的时候，线程才可以往下执行，所以，必须使用while 循环阻塞。注意，wait() 当被唤醒时候，只是让while循环继续往下走.如果此处用if的话，意味着if继续往下走，会跳出if语句块。但是，notifyAll 只是负责唤醒线程，并不保证条件云云，所以需要手动来保证程序的逻辑。</p><p><strong>8、实现生产者和消费者问题 </strong></p><p>　　什么是生产者-消费者问题呢？</p><p><img src="/assets/blogImg/4/10.jpg" alt="图片10"></p><p>如上图，假设有一个公共的容量有限的池子，有两种人，一种是生产者，另一种是消费者。需要满足如下条件：</p><p>　　　　1、生产者产生资源往池子里添加，前提是池子没有满，如果池子满了，则生产者暂停生产，直到自己的生成能放下池子。</p><p>　　　　2、消费者消耗池子里的资源，前提是池子的资源不为空，否则消费者暂停消耗，进入等待直到池子里有资源数满足自己的需求。</p><p>　　– 仓库类　</p><pre><code>import java.util.LinkedList;/** *  生产者和消费者的问题 *  wait、notify/notifyAll() 实现 */public class Storage1 implements AbstractStorage {    //仓库最大容量    private final int MAX_SIZE = 100;    //仓库存储的载体    private LinkedList list = new LinkedList();    //生产产品    public void produce(int num){        //同步        synchronized (list){            //仓库剩余的容量不足以存放即将要生产的数量，暂停生产            while(list.size()+num &gt; MAX_SIZE){                System.out.println(&quot;【要生产的产品数量】:&quot; + num + &quot;\t【库存量】:&quot;                        + list.size() + &quot;\t暂时不能执行生产任务!&quot;);                try {                    //条件不满足，生产阻塞                    list.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            for(int i=0;i&lt;num;i++){                list.add(new Object());            }            System.out.println(&quot;【已经生产产品数】:&quot; + num + &quot;\t【现仓储量为】:&quot; + list.size());            list.notifyAll();        }    }    //消费产品    public void consume(int num){        synchronized (list){            //不满足消费条件            while(num &gt; list.size()){                System.out.println(&quot;【要消费的产品数量】:&quot; + num + &quot;\t【库存量】:&quot;                        + list.size() + &quot;\t暂时不能执行生产任务!&quot;);                try {                    list.wait();                } catch (InterruptedException e) {                    e.printStackTrace();                }            }            //消费条件满足，开始消费            for(int i=0;i&lt;num;i++){                list.remove();            }            System.out.println(&quot;【已经消费产品数】:&quot; + num + &quot;\t【现仓储量为】:&quot; + list.size());            list.notifyAll();        }    }}</code></pre><p>　　- 抽象仓库类</p><pre><code>public interface AbstractStorage {    void consume(int num);    void produce(int num);}</code></pre><p>　　- 生产者</p><pre><code>public class Producer extends Thread{    //每次生产的数量    private int num ;    //所属的仓库    public AbstractStorage abstractStorage;    public Producer(AbstractStorage abstractStorage){        this.abstractStorage = abstractStorage;    }    public void setNum(int num){        this.num = num;    }    // 线程run函数    @Override    public void run()    {        produce(num);    }    // 调用仓库Storage的生产函数    public void produce(int num)    {        abstractStorage.produce(num);    }}</code></pre><p>　　- 消费者</p><pre><code>public class Consumer extends Thread{    // 每次消费的产品数量    private int num;    // 所在放置的仓库    private AbstractStorage abstractStorage1;    // 构造函数，设置仓库    public Consumer(AbstractStorage abstractStorage1)    {        this.abstractStorage1 = abstractStorage1;    }    // 线程run函数    public void run()    {        consume(num);    }    // 调用仓库Storage的生产函数    public void consume(int num)    {        abstractStorage1.consume(num);    }    public void setNum(int num){        this.num = num;    }}</code></pre><p>　　- 测试</p><pre><code>public class Test{    public static void main(String[] args) {        // 仓库对象        AbstractStorage abstractStorage = new Storage1();        // 生产者对象        Producer p1 = new Producer(abstractStorage);        Producer p2 = new Producer(abstractStorage);        Producer p3 = new Producer(abstractStorage);        Producer p4 = new Producer(abstractStorage);        Producer p5 = new Producer(abstractStorage);        Producer p6 = new Producer(abstractStorage);        Producer p7 = new Producer(abstractStorage);        // 消费者对象        Consumer c1 = new Consumer(abstractStorage);        Consumer c2 = new Consumer(abstractStorage);        Consumer c3 = new Consumer(abstractStorage);        // 设置生产者产品生产数量        p1.setNum(10);        p2.setNum(10);        p3.setNum(10);        p4.setNum(10);        p5.setNum(10);        p6.setNum(10);        p7.setNum(80);        // 设置消费者产品消费数量        c1.setNum(50);        c2.setNum(20);        c3.setNum(30);        // 线程开始执行        c1.start();        c2.start();        c3.start();        p1.start();        p2.start();        p3.start();        p4.start();        p5.start();        p6.start();        p7.start();    }}</code></pre><p>　　- 输出</p><pre><code>【要消费的产品数量】:50    【库存量】:0    暂时不能执行生产任务!【要消费的产品数量】:20    【库存量】:0    暂时不能执行生产任务!【要消费的产品数量】:30    【库存量】:0    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:10【要消费的产品数量】:30    【库存量】:10    暂时不能执行生产任务!【要消费的产品数量】:20    【库存量】:10    暂时不能执行生产任务!【要消费的产品数量】:50    【库存量】:10    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:20【已经生产产品数】:10    【现仓储量为】:30【要消费的产品数量】:50    【库存量】:30    暂时不能执行生产任务!【已经消费产品数】:20    【现仓储量为】:10【要消费的产品数量】:30    【库存量】:10    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:20【要消费的产品数量】:50    【库存量】:20    暂时不能执行生产任务!【要消费的产品数量】:30    【库存量】:20    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:30【已经消费产品数】:30    【现仓储量为】:0【要消费的产品数量】:50    【库存量】:0    暂时不能执行生产任务!【已经生产产品数】:10    【现仓储量为】:10【要消费的产品数量】:50    【库存量】:10    暂时不能执行生产任务!【已经生产产品数】:80    【现仓储量为】:90【已经消费产品数】:50    【现仓储量为】:40</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/moongeek/p/7631447.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java多线程学习之wait、notify/notifyAll 详解&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>抽象类</title>
    <link href="https://mlone.top/post/3dbae4e.html"/>
    <id>https://mlone.top/post/3dbae4e.html</id>
    <published>2018-09-18T10:25:14.000Z</published>
    <updated>2019-02-25T10:55:43.845Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/wei_zhi/article/details/52736350/" target="_blank" rel="noopener">https://blog.csdn.net/wei_zhi/article/details/52736350/</a></p><a id="more"></a><h2 id="一、抽象类的基本概念"><a href="#一、抽象类的基本概念" class="headerlink" title="一、抽象类的基本概念"></a>一、抽象类的基本概念</h2><p>普通类是一个完善的功能类，可以直接产生实例化对象，并且在普通类中可以包含有构造方法、普通方法、static方法、常量和变量等内容。</p><p>而抽象类是指在普通类的结构里面增加<strong>抽象方法</strong>的组成部分。</p><p>那么什么叫抽象方法呢？在所有的普通方法上面都会有一个“{}”，这个表示方法体，有方法体的方法一定可以被对象直接使用。而<strong>抽象方法，是指没有方法体的方法，同时抽象方法还必须使用关键字abstract做修饰。</strong></p><p>而<strong>拥有抽象方法的类就是抽象类，抽象类要使用abstract关键字声明。</strong></p><p>范例：定义一个抽象类:</p><pre><code>abstract class A{//定义一个抽象类    public void fun(){//普通方法        System.out.println(&quot;存在方法体的方法&quot;);    }    public abstract void print();//抽象方法，没有方法体，有abstract关键字做修饰}</code></pre><h2 id="二、抽象类的使用"><a href="#二、抽象类的使用" class="headerlink" title="二、抽象类的使用"></a>二、抽象类的使用</h2><p>我们先看范例。 </p><p>范例：直接实例化抽象类的对象:</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public void fun(){//普通方法        System.out.println(&quot;存在方法体的方法&quot;);    }    public abstract void print();//抽象方法，没有方法体，有abstract关键字做修饰}public class TestDemo {    public static void main(String[] args) {        A a = new A();    }}</code></pre><p>运行：</p><pre><code>Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem:     Cannot instantiate the type A    at com.wz.abstractdemo.TestDemo.main(TestDemo.java:15)</code></pre><p>从上可知，<strong>A是抽象的，无法直接进行实例化操作。</strong>为什么不能直接实例化呢？当一个类实例化之后，就意味着这个对象可以调用类中的属性或者放过了，但在抽象类里存在抽象方法，而抽象方法没有方法体，没有方法体就无法进行调用。既然无法进行方法调用的话，又怎么去产生实例化对象呢。</p><p>抽象类的使用原则如下：</p><ul><li><p>抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public； </p></li><li><p>抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理； </p></li><li><p>抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；</p></li><li><p>子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。）；</p></li></ul><p>范例：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public void fun(){//普通方法        System.out.println(&quot;存在方法体的方法&quot;);    }    public abstract void print();//抽象方法，没有方法体，有abstract关键字做修饰}//单继承class B extends A{//B类是抽象类的子类，是一个普通类    @Override    public void print() {//强制要求覆写        System.out.println(&quot;Hello World !&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A a = new B();//向上转型        a.fun();//被子类所覆写的过的方法    }}</code></pre><p>运行结果：</p><pre><code>Hello World!</code></pre><p>现在就可以清楚的发现： </p><ul><li><p>抽象类继承子类里面有明确的方法覆写要求，而普通类可以有选择性的来决定是否需要覆写；</p></li><li><p>抽象类实际上就比普通类多了一些抽象方法而已，其他组成部分和普通类完全一样； </p></li><li><p>普通类对象可以直接实例化，但抽象类的对象必须经过向上转型之后才可以得到。</p></li></ul><p>虽然一个类的子类可以去继承任意的一个普通类，可是从开发的实际要求来讲，普通类尽量不要去继承另外一个普通类，而是去继承抽象类。</p><h2 id="三、抽象类的使用限制"><a href="#三、抽象类的使用限制" class="headerlink" title="三、抽象类的使用限制"></a>三、抽象类的使用限制</h2><p><strong>（1）抽象类中有构造方法么？ </strong></p><p><em>由于抽象类里会存在一些属性，那么抽象类中一定存在构造方法，其存在目的是为了属性的初始化。</em></p><p><em>并且子类对象实例化的时候，依然满足先执行父类构造，再执行子类构造的顺序。</em></p><p>范例如下：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public A(){        System.out.println(&quot;*****A类构造方法*****&quot;);    }    public abstract void print();//抽象方法，没有方法体，有abstract关键字做修饰}//单继承class B extends A{//B类是抽象类的子类，是一个普通类    public B(){        System.out.println(&quot;*****B类构造方法*****&quot;);    }    @Override    public void print() {//强制要求覆写        System.out.println(&quot;Hello World !&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A a = new B();//向上转型    }}</code></pre><p>执行结果：</p><pre><code>*****A类构造方法**********B类构造方法*****</code></pre><p><strong>（2）抽象类可以用final声明么？</strong> </p><p><em>不能，因为抽象类必须有子类，而final定义的类不能有子类</em>；</p><p><strong>（3）抽象类能否使用static声明？</strong> </p><p>先看一个关于外部抽象类的范例：</p><pre><code>package com.wz.abstractdemo;static abstract class A{//定义一个抽象类    public abstract void print();}class B extends A{    public void print(){        System.out.println(&quot;**********&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A a = new B();//向上转型        a.print();    }}</code></pre><p>执行结果:</p><pre><code>Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem: Illegal modifier for the class A; only public, abstract &amp; final are permittedat com.wz.abstractdemo.A.&lt;init&gt;(TestDemo.java:3)at com.wz.abstractdemo.B.&lt;init&gt;(TestDemo.java:9)at com.wz.abstractdemo.TestDemo.main(TestDemo.java:18)</code></pre><p>再看一个关于内部抽象类：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    static abstract class B{//static定义的内部类属于外部类        public abstract void print();    }}class C extends A.B{    public void print(){        System.out.println(&quot;**********&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A.B ab = new C();//向上转型        ab.print();    }}</code></pre><p>执行结果：</p><pre><code>**********</code></pre><p>由此可见，外部抽象类不允许使用static声明，而内部的抽象类运行使用static声明。使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</p><p><strong>（4）可以直接调用抽象类中用static声明的方法么？ </strong></p><p><em>任何时候，如果要执行类中的static方法的时候，都可以在没有对象的情况下直接调用，对于抽象类也一样。</em></p><p>范例如下：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public static void print(){        System.out.println(&quot;Hello World !&quot;);    }}public class TestDemo {    public static void main(String[] args) {        A.print();    }}</code></pre><p>运行结果：</p><pre><code>Hello World !</code></pre><p><strong>（5）有时候由于抽象类中只需要一个特定的系统子类操作，所以可以忽略掉外部子类。这样的设计在系统类库中会比较常见，目的是对用户隐藏不需要知道的子类。</strong> </p><p>范例如下：</p><pre><code>package com.wz.abstractdemo;abstract class A{//定义一个抽象类    public abstract void print();    private static class B extends A{//内部抽象类子类        public void print(){//覆写抽象类的方法            System.out.println(&quot;Hello World !&quot;);        }    }    //这个方法不受实例化对象的控制    public static A getInstance(){        return new B();    }}public class TestDemo {    public static void main(String[] args) {        //此时取得抽象类对象的时候完全不需要知道B类这个子类的存在        A a = A.getInstance();        a.print();    }}</code></pre><p>运行结果：</p><pre><code>Hello World !</code></pre><h2 id="四、抽象类的应用——模板设计模式"><a href="#四、抽象类的应用——模板设计模式" class="headerlink" title="四、抽象类的应用——模板设计模式"></a>四、抽象类的应用——模板设计模式</h2><p>例如，现在有三类事物： </p><p>（1）机器人：充电，工作； </p><p>（2）人：吃饭，工作，睡觉； </p><p>（3）猪：进食，睡觉。 </p><p>现要求实现一个程序，可以实现三种不同事物的行为。</p><p>先定义一个抽象行为类：</p><pre><code>package com.wz.abstractdemo;public abstract class Action{    public static final int EAT = 1 ;    public static final int SLEEP = 3 ;    public static final int WORK = 5 ;    public abstract void eat();    public abstract void sleep();    public abstract void work();    public void commond(int flags){      switch(flags){        case EAT:            this.eat();            break;        case SLEEP:            this.sleep();            break;        case WORK:            this.work();            break;        case EAT + SLEEP:            this.eat();            this.sleep();            break;        case SLEEP + WORK:            this.sleep();            this.work();            break;        default:            break;        }    }}</code></pre><p>定义一个机器人的类：</p><pre><code>package com.wz.abstractdemo;public class Robot extends Action{    @Override    public void eat() {        System.out.println(&quot;机器人充电&quot;);    }    @Override    public void sleep() {    }    @Override    public void work() {        System.out.println(&quot;机器人工作&quot;);    }}</code></pre><p>定义一个人的类：</p><pre><code>package com.wz.abstractdemo;public class Human extends Action{    @Override    public void eat() {        System.out.println(&quot;人吃饭&quot;);    }    @Override    public void sleep() {        System.out.println(&quot;人睡觉&quot;);    }    @Override    public void work() {        System.out.println(&quot;人工作&quot;);    }}</code></pre><p>定义一个猪的类:</p><pre><code>package com.wz.abstractdemo;public class Pig extends Action{    @Override    public void eat() {        System.out.println(&quot;猪进食&quot;);    }    @Override    public void sleep() {        System.out.println(&quot;猪睡觉&quot;);    }    @Override    public void work() {    }}</code></pre><p>测试主类：</p><pre><code>package com.wz.abstractdemo;public class AbstractDemo {    public static void main(String[] args) {        fun(new Robot());        fun(new Human());        fun(new Pig());    }    public static void fun(Action act){        act.commond(Action.EAT);        act.commond(Action.SLEEP);        act.commond(Action.WORK);    }}</code></pre><p>运行结果：</p><pre><code>机器人充电机器人工作人吃饭人睡觉人工作猪进食猪睡觉</code></pre><p><strong>所有的子类如果要想正常的完成操作，必须按照指定的方法进行覆写才可以，而这个时候抽象类所起的功能就是一个类定义模板的功能。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/wei_zhi/article/details/52736350/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/wei_zhi/article/details/52736350/&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Volatile关键字</title>
    <link href="https://mlone.top/post/3fbd301a.html"/>
    <id>https://mlone.top/post/3fbd301a.html</id>
    <published>2018-09-17T14:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.783Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></p><a id="more"></a><p>　　volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p><p>　　volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。</p><p>　　以下是本文的目录大纲：</p><p>　　一.内存模型的相关概念</p><p>　　二.并发编程中的三个概念</p><p>　　三.Java内存模型</p><p>　　四..深入剖析volatile关键字</p><p>　　五.使用volatile关键字的场景</p><h2 id="一-内存模型的相关概念"><a href="#一-内存模型的相关概念" class="headerlink" title="一.内存模型的相关概念"></a>一.内存模型的相关概念</h2><p>　　大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p><p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p><pre><code>i = i + 1;</code></pre><p>当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p><p>　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p><p>　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p><p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p><p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p><p>　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p><p>　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p><p>　　1）通过在总线加LOCK#锁的方式</p><p>　　2）通过缓存一致性协议</p><p>　　这2种方式都是硬件层面上提供的方式。</p><p>　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p><p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p><p>　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><p><img src="/assets/blogImg/4/8.jpg" alt="图片8"></p><h2 id="二-并发编程中的三个概念"><a href="#二-并发编程中的三个概念" class="headerlink" title="二.并发编程中的三个概念"></a>二.并发编程中的三个概念</h2><p>　　在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>　　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>　　一个很经典的例子就是银行账户转账问题：</p><p>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p><p>　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p><p>　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p><p>　　同样地反映到并发编程中会出现什么结果呢？</p><p>　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p><pre><code>i = 9;</code></pre><p>　　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p><p>　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><p>　　举个简单的例子，看下面这段代码：</p><pre><code>//线程1执行的代码int i = 0;i = 10;//线程2执行的代码j = i;</code></pre><p>　　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p><p>　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p><p>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p><pre><code>int i = 0;              boolean flag = false;i = 1;                //语句1  flag = true;          //语句2</code></pre><p>　　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p><p>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p><p>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p><p>　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p><pre><code>int a = 10;    //语句1int r = 2;    //语句2a = a + 3;    //语句3r = a*a;     //语句4</code></pre><p>这段代码有4个语句，那么可能的一个执行顺序是：</p><p><img src="/assets/blogImg/4/9.jpg" alt="图片9"></p><p>　　那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3</p><p>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p><p>　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p><pre><code>//线程1:context = loadContext();   //语句1inited = true;             //语句2//线程2:while(!inited ){  sleep()}doSomethingwithconfig(context);</code></pre><p>　　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p><p> 　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p><p>　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p><h2 id="三-Java内存模型"><a href="#三-Java内存模型" class="headerlink" title="三.Java内存模型"></a>三.Java内存模型</h2><p>　　在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p><p>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p><p>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p><p>　　举个简单的例子：在java中，执行下面这个语句：</p><pre><code>i  = 10;</code></pre><p>　　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p><p>　　那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p><h3 id="1-原子性-1"><a href="#1-原子性-1" class="headerlink" title="1.原子性"></a>1.原子性</h3><p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p><p>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p><p>　　请分析以下哪些操作是原子性操作：</p><pre><code>x = 10;         //语句1y = x;         //语句2x++;           //语句3x = x + 1;     //语句4</code></pre><p> 　　咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p><p>　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p><p>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p><p>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p><p> 　　所以上面4个语句只有语句1的操作具备原子性。</p><p>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p><p>　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p><p>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p><h3 id="2-可见性-1"><a href="#2-可见性-1" class="headerlink" title="2.可见性"></a>2.可见性</h3><p>　　对于可见性，Java提供了volatile关键字来保证可见性。</p><p>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p><p>　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p><p>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h3 id="3-有序性-1"><a href="#3-有序性-1" class="headerlink" title="3.有序性"></a>3.有序性</h3><p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><p>　　另外，<strong>Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</strong></p><p>下面就来具体介绍下happens-before原则（先行发生原则）：</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><p>　　这8条原则摘自《深入理解Java虚拟机》。</p><p>　　这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p><p>　　下面我们来解释一下前4条规则：</p><p>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p><p>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p><p>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p><p>　　第四条规则实际上就是体现happens-before原则具备传递性。</p><h2 id="四-深入剖析volatile关键字"><a href="#四-深入剖析volatile关键字" class="headerlink" title="四.深入剖析volatile关键字"></a>四.深入剖析volatile关键字</h2><p>在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p><h3 id="1-volatile关键字的两层语义"><a href="#1-volatile关键字的两层语义" class="headerlink" title="1.volatile关键字的两层语义"></a>1.volatile关键字的两层语义</h3><p>　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p><p>　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><p>　　2）禁止进行指令重排序。</p><p>　　先看一段代码，假如线程1先执行，线程2后执行：</p><pre><code>//线程1boolean stop = false;while(!stop){    doSomething();}//线程2stop = true;</code></pre><p>　　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p><p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p><p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p><p>　　但是用volatile修饰之后就变得不一样了：</p><p>　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p><p>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p><p>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p><p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p><p>　　那么线程1读取到的就是最新的正确的值。</p><h3 id="2-volatile保证原子性吗？"><a href="#2-volatile保证原子性吗？" class="headerlink" title="2.volatile保证原子性吗？"></a>2.volatile保证原子性吗？</h3><p>　　从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p><p>　　下面看一个例子：</p><pre><code>public class Test {    public volatile int inc = 0;    public void increase() {        inc++;    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p> 　　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p><p>　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p><p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p><p>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p><p>　　假如某个时刻变量inc的值为10，</p><p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p><p>　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p><p>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p><p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1。</p><p>　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p><p>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p><p>　　把上面的代码改成以下任何一种都可以达到效果：</p><p>　　采用synchronized：</p><pre><code>public class Test {    public  int inc = 0;    public synchronized void increase() {        inc++;    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p>　　采用Lock：</p><pre><code>public class Test {    public  int inc = 0;    Lock lock = new ReentrantLock();    public  void increase() {        lock.lock();        try {            inc++;        } finally{            lock.unlock();        }    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p>　　采用AtomicInteger：</p><pre><code>public class Test {    public  AtomicInteger inc = new AtomicInteger();    public  void increase() {        inc.getAndIncrement();    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p>　　在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p><h3 id="3-volatile能保证有序性吗？"><a href="#3-volatile能保证有序性吗？" class="headerlink" title="3.volatile能保证有序性吗？"></a>3.volatile能保证有序性吗？</h3><p>　　在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p><p>　　volatile关键字禁止指令重排序有两层意思：</p><p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p><p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p><p>　　可能上面说的比较绕，举个简单的例子：</p><pre><code>//x、y为非volatile变量//flag为volatile变量x = 2;        //语句1y = 0;        //语句2flag = true;  //语句3x = 4;         //语句4y = -1;       //语句5</code></pre><p> 　　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p><p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><p>　　那么我们回到前面举的一个例子：</p><pre><code>//线程1:context = loadContext();   //语句1inited = true;             //语句2//线程2:while(!inited ){  sleep()}doSomethingwithconfig(context);</code></pre><p>　　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p><p>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p><h3 id="4-volatile的原理和实现机制"><a href="#4-volatile的原理和实现机制" class="headerlink" title="4.volatile的原理和实现机制"></a>4.volatile的原理和实现机制</h3><p>　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p><p>　　下面这段话摘自《深入理解Java虚拟机》：</p><p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p><p>　　2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><h2 id="五-使用volatile关键字的场景"><a href="#五-使用volatile关键字的场景" class="headerlink" title="五.使用volatile关键字的场景"></a>五.使用volatile关键字的场景</h2><p>　　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p><p>　　1）对变量的写操作不依赖于当前值</p><p>　　2）该变量没有包含在具有其他变量的不变式中</p><p>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p><p>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p><p>　　下面列举几个Java中使用volatile的几个场景。</p><h3 id="1-状态标记量"><a href="#1-状态标记量" class="headerlink" title="1.状态标记量"></a>1.状态标记量</h3><pre><code>volatile boolean flag = false;while(!flag){    doSomething();}public void setFlag() {    flag = true;}</code></pre><p>.</p><pre><code>volatile boolean inited = false;//线程1:context = loadContext();  inited = true;            //线程2:while(!inited ){sleep()}doSomethingwithconfig(context);</code></pre><h3 id="2-double-check"><a href="#2-double-check" class="headerlink" title="2.double check"></a>2.double check</h3><pre><code>class Singleton{    private volatile static Singleton instance = null;    private Singleton() {    }    public static Singleton getInstance() {        if(instance==null) {            synchronized (Singleton.class) {                if(instance==null)                    instance = new Singleton();            }        }        return instance;    }}</code></pre><p>　　至于为何需要这么写请参考：</p><p>　　《Java 中的双重检查（Double-Check）》<a href="http://blog.csdn.net/dl88250/article/details/5439024" target="_blank" rel="noopener">http://blog.csdn.net/dl88250/article/details/5439024</a></p><p>　　和<a href="http://www.iteye.com/topic/652440" target="_blank" rel="noopener">http://www.iteye.com/topic/652440</a></p><p>　　参考资料：</p><p>　　《Java编程思想》</p><p>　　《深入理解Java虚拟机》</p><p>　　<a href="http://jiangzhengjun.iteye.com/blog/652532" target="_blank" rel="noopener">http://jiangzhengjun.iteye.com/blog/652532</a></p><p>　　<a href="http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p><p>　　<a href="http://ifeve.com/volatile/" target="_blank" rel="noopener">http://ifeve.com/volatile/</a></p><p>　　<a href="http://blog.csdn.net/ccit0519/article/details/11241403" target="_blank" rel="noopener">http://blog.csdn.net/ccit0519/article/details/11241403</a></p><p>　　<a href="http://blog.csdn.net/ns_code/article/details/17101369" target="_blank" rel="noopener">http://blog.csdn.net/ns_code/article/details/17101369</a></p><p>　　<a href="http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html" target="_blank" rel="noopener">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p><p>　　<a href="http://www.cppblog.com/elva/archive/2011/01/21/139019.html" target="_blank" rel="noopener">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p><p>　　<a href="http://ifeve.com/volatile-array-visiblity/" target="_blank" rel="noopener">http://ifeve.com/volatile-array-visiblity/</a></p><p>　　<a href="http://www.bdqn.cn/news/201312/12579.shtml" target="_blank" rel="noopener">http://www.bdqn.cn/news/201312/12579.shtml</a></p><p>　　<a href="http://exploer.blog.51cto.com/7123589/1193399" target="_blank" rel="noopener">http://exploer.blog.51cto.com/7123589/1193399</a></p><p>　　<a href="http://www.cnblogs.com/Mainz/p/3556430.html" target="_blank" rel="noopener">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3920373.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java并发编程：volatile关键字解析&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="并发" scheme="https://mlone.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized锁机制</title>
    <link href="https://mlone.top/post/a9e12473.html"/>
    <id>https://mlone.top/post/a9e12473.html</id>
    <published>2018-09-17T11:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.780Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://zhh9106.iteye.com/blog/2151791" target="_blank" rel="noopener">https://zhh9106.iteye.com/blog/2151791</a></p><a id="more"></a><p>在java编程中，经常需要用到同步，而用得最多的也许是synchronized关键字了，下面看看这个关键字的用法。</p><p>因为synchronized关键字涉及到锁的概念，所以先来了解一些相关的锁知识。</p><p>java的内置锁：每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</p><p>java内置锁是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果B线程不释放这个锁，那么A线程将永远等待下去。</p><p>java的对象锁和类锁：java的对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的，对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的</p><p>上面已经对锁的一些概念有了一点了解，下面探讨synchronized关键字的用法。</p><p>synchronized的用法：synchronized修饰方法和synchronized修饰代码块。 </p><p>下面分别分析这两种用法在对象锁和类锁上的效果。</p><p>对象锁的synchronized修饰方法和代码块：</p><pre><code>1.public class TestSynchronized   2.{    3.    public void test1()   4.    {    5.         synchronized(this)   6.         {    7.              int i = 5;    8.              while( i-- &gt; 0)   9.              {    10.                   System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    11.                   try   12.                   {    13.                        Thread.sleep(500);    14.                   }   15.                   catch (InterruptedException ie)   16.                   {    17.                   }    18.              }    19.         }    20.    }    21.      22.    public synchronized void test2()   23.    {    24.         int i = 5;    25.         while( i-- &gt; 0)   26.         {    27.              System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    28.              try   29.              {    30.                   Thread.sleep(500);    31.              }   32.              catch (InterruptedException ie)   33.              {    34.              }    35.         }    36.    }    37.      38.    public static void main(String[] args)   39.    {    40.         final TestSynchronized myt2 = new TestSynchronized();    41.         Thread test1 = new Thread(  new Runnable() {  public void run() {  myt2.test1();  }  }, &quot;test1&quot;  );    42.         Thread test2 = new Thread(  new Runnable() {  public void run() { myt2.test2();   }  }, &quot;test2&quot;  );    43.         test1.start();;    44.         test2.start();    45.//         TestRunnable tr=new TestRunnable();  46.//         Thread test3=new Thread(tr);  47.//         test3.start();  48.    }   49.    50.}</code></pre><p>输出：</p><pre><code>1. test2 : 4  2. test2 : 3  3. test2 : 2  4. test2 : 1  5. test2 : 0  6. test1 : 4  7. test1 : 3  8. test1 : 2  9. test1 : 1  10. test1 : 0</code></pre><p>上述的代码，第一个方法时用了同步代码块的方式进行同步，传入的对象实例是this，表明是当前对象，当然，如果需要同步其他对象实例，也不可传入其他对象的实例；第二个方法是修饰方法的方式进行同步。因为第一个同步代码块传入的this，所以两个同步代码所需要获得的对象锁都是同一个对象锁，下面main方法时分别开启两个线程，分别调用test1和test2方法，那么两个线程都需要获得该对象锁，另一个线程必须等待。上面也给出了运行的结果可以看到：直到test2线程执行完毕，释放掉锁，test1线程才开始执行。</p><p><em>（可能这个结果有人会有疑问，代码里面明明是先开启test1线程，为什么先执行的是test2呢？这是因为java编译器在编译成字节码的时候，会对代码进行一个重排序，也就是说，编译器会根据实际情况对代码进行一个合理的排序，编译前代码写在前面，在编译后的字节码不一定排在前面，所以这种运行结果是正常的， 这里是题外话，最主要是检验synchronized的用法的正确性）</em></p><p>如果我们把test2方法的synchronized关键字去掉，执行结果会如何呢？</p><pre><code>1.test1 : 4  2.test2 : 4  3.test2 : 3  4.test1 : 3  5.test1 : 2  6.test2 : 2  7.test2 : 1  8.test1 : 1  9.test2 : 0  10.test1 : 0</code></pre><p>上面是执行结果，我们可以看到，结果输出是交替着进行输出的，这是因为，某个线程得到了对象锁，但是另一个线程还是可以访问没有进行同步的方法或者代码。进行了同步的方法（加锁方法）和没有进行同步的方法（普通方法）是互不影响的，一个线程进入了同步方法，得到了对象锁，其他线程还是可以访问那些没有同步的方法（普通方法）。</p><p><em>这里涉及到内置锁的一个概念（此概念出自java并发编程实战第二章）：对象的内置锁和对象的状态之间是没有内在的关联的，虽然大多数类都将内置锁用做一种有效的加锁机制，但对象的域并不一定通过内置锁来保护。当获取到与对象关联的内置锁时，并不能阻止其他线程访问该对象，当某个线程获得对象的锁之后，只能阻止其他线程获得同一个锁。之所以每个对象都有一个内置锁，是为了免去显式地创建锁对象。</em></p><p>所以synchronized只是一个内置锁的加锁机制，当某个方法加上synchronized关键字后，就表明要获得该内置锁才能执行，并不能阻止其他线程访问不需要获得该内置锁的方法。</p><p>类锁的修饰（静态）方法和代码块：</p><pre><code>1.public class TestSynchronized   2.{    3.    public void test1()   4.    {    5.         synchronized(TestSynchronized.class)   6.         {    7.              int i = 5;    8.              while( i-- &gt; 0)   9.              {    10.                   System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    11.                   try   12.                   {    13.                        Thread.sleep(500);    14.                   }   15.                   catch (InterruptedException ie)   16.                   {    17.                   }    18.              }    19.         }    20.    }    21.      22.    public static synchronized void test2()   23.    {    24.         int i = 5;    25.         while( i-- &gt; 0)   26.         {    27.              System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    28.              try   29.              {    30.                   Thread.sleep(500);    31.              }   32.              catch (InterruptedException ie)   33.              {    34.              }    35.         }    36.    }    37.      38.    public static void main(String[] args)   39.    {    40.         final TestSynchronized myt2 = new TestSynchronized();    41.         Thread test1 = new Thread(  new Runnable() {  public void run() {  myt2.test1();  }  }, &quot;test1&quot;  );    42.         Thread test2 = new Thread(  new Runnable() {  public void run() { TestSynchronized.test2();   }  }, &quot;test2&quot;  );    43.         test1.start();    44.         test2.start();    45.//         TestRunnable tr=new TestRunnable();  46.//         Thread test3=new Thread(tr);  47.//         test3.start();  48.    }   49.    50.}</code></pre><p>输出：</p><pre><code>1.test1 : 4  2.test1 : 3  3.test1 : 2  4.test1 : 1  5.test1 : 0  6.test2 : 4  7.test2 : 3  8.test2 : 2  9.test2 : 1  10.test2 : 0</code></pre><p>其实，类锁修饰方法和代码块的效果和对象锁是一样的，因为类锁只是一个抽象出来的概念，只是为了区别静态方法的特点，因为静态方法是所有对象实例共用的，所以对应着synchronized修饰的静态方法的锁也是唯一的，所以抽象出来个类锁。其实这里的重点在下面这块代码，synchronized同时修饰静态和非静态方法</p><pre><code>1.public class TestSynchronized   2.{    3.    public synchronized void test1()   4.    {    5.              int i = 5;    6.              while( i-- &gt; 0)   7.              {    8.                   System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    9.                   try   10.                   {    11.                        Thread.sleep(500);    12.                   }   13.                   catch (InterruptedException ie)   14.                   {    15.                   }    16.              }    17.    }    18.      19.    public static synchronized void test2()   20.    {    21.         int i = 5;    22.         while( i-- &gt; 0)   23.         {    24.              System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);    25.              try   26.              {    27.                   Thread.sleep(500);    28.              }   29.              catch (InterruptedException ie)   30.              {    31.              }    32.         }    33.    }    34.      35.    public static void main(String[] args)   36.    {    37.         final TestSynchronized myt2 = new TestSynchronized();    38.         Thread test1 = new Thread(  new Runnable() {  public void run() {  myt2.test1();  }  }, &quot;test1&quot;  );    39.         Thread test2 = new Thread(  new Runnable() {  public void run() { TestSynchronized.test2();   }  }, &quot;test2&quot;  );    40.         test1.start();    41.         test2.start();    42.//         TestRunnable tr=new TestRunnable();  43.//         Thread test3=new Thread(tr);  44.//         test3.start();  45.    }   46.    47.}  </code></pre><p>输出：</p><pre><code>1.test1 : 4  2.test2 : 4  3.test1 : 3  4.test2 : 3  5.test2 : 2  6.test1 : 2  7.test2 : 1  8.test1 : 1  9.test1 : 0  10.test2 : 0</code></pre><p><strong>上面代码synchronized同时修饰静态方法和实例方法，但是运行结果是交替进行的，这证明了类锁和对象锁是两个不一样的锁，控制着不同的区域，它们是互不干扰的。同样，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。</strong></p><p><strong>到这里，对synchronized的用法已经有了一定的了解。这时有一个疑问，既然有了synchronized修饰方法的同步方式，为什么还需要synchronized修饰同步代码块的方式呢？而这个问题也是synchronized的缺陷所在</strong></p><p>synchronized的缺陷：当某个线程进入同步方法获得对象锁，那么其他线程访问这里对象的同步方法时，必须等待或者阻塞，这对高并发的系统是致命的，这很容易导致系统的崩溃。如果某个线程在同步方法里面发生了死循环，那么它就永远不会释放这个对象锁，那么其他线程就要永远的等待。这是一个致命的问题。</p><p>当然同步方法和同步代码块都会有这样的缺陷，只要用了synchronized关键字就会有这样的风险和缺陷。既然避免不了这种缺陷，那么就应该将风险降到最低。这也是同步代码块在某种情况下要优于同步方法的方面。例如在某个类的方法里面：这个类里面声明了一个对象实例，SynObject so=new SynObject()；在某个方法里面调用了这个实例的方法so.testsy();但是调用这个方法需要进行同步，不能同时有多个线程同时执行调用这个方法。</p><p>这时如果直接用synchronized修饰调用了so.testsy();代码的方法，那么当某个线程进入了这个方法之后，这个对象其他同步方法都不能给其他线程访问了。假如这个方法需要执行的时间很长，那么其他线程会一直阻塞，影响到系统的性能。</p><p>如果这时用synchronized来修饰代码块：synchronized（so）{so.testsy();}，那么这个方法加锁的对象是so这个对象，跟执行这行代码的对象没有关系，当一个线程执行这个方法时，这对其他同步方法时没有影响的，因为他们持有的锁都完全不一样。</p><p>不过这里还有一种特例，就是上面演示的第一个例子，对象锁synchronized同时修饰方法和代码块，这时也可以体现到同步代码块的优越性，如果test1方法同步代码块后面有非常多没有同步的代码，而且有一个100000的循环，这导致test1方法会执行时间非常长，那么如果直接用synchronized修饰方法，那么在方法没执行完之前，其他线程是不可以访问test2方法的，但是如果用了同步代码块，那么当退出代码块时就已经释放了对象锁，当线程还在执行test1的那个100000的循环时，其他线程就已经可以访问test2方法了。这就让阻塞的机会或者线程更少。让系统的性能更优越。</p><p>一个类的对象锁和另一个类的对象锁是没有关联的，当一个线程获得A类的对象锁时，它同时也可以获得B类的对象锁。</p><p>可能上面只有理论和代码，对刚接触的人比较难理解，下面举一个例子，</p><p>这个例子是摘自博客：<a href="http://www.cnblogs.com/GnagWang/archive/2011/02/27/1966606.html" target="_blank" rel="noopener">http://www.cnblogs.com/GnagWang/archive/2011/02/27/1966606.html</a></p><p>打个比方：一个object就像一个大房子，大门永远打开。房子里有 很多房间（也就是方法）。</p><p>这些房间有上锁的（synchronized方法）， 和不上锁之分（普通方法）。房门口放着一把钥匙（key），这把钥匙可以打开所有上锁的房间。</p><p>另外我把所有想调用该对象方法的线程比喻成想进入这房子某个 房间的人。所有的东西就这么多了，下面我们看看这些东西之间如何作用的。</p><p>在此我们先来明确一下我们的前提条件。该对象至少有一个synchronized方法，否则这个key还有啥意义。当然也就不会有我们的这个主题了。</p><p>一个人想进入某间上了锁的房间，他来到房子门口，看见钥匙在那儿（说明暂时还没有其他人要使用上锁的 房间）。于是他走上去拿到了钥匙，并且按照自己 的计划使用那些房间。注意一点，他每次使用完一次上锁的房间后会马上把钥匙还回去。即使他要连续使用两间上锁的房间，中间他也要把钥匙还回去，再取回来。</p><p>因此，普通情况下钥匙的使用原则是：“随用随借，用完即还。”</p><p>这时其他人可以不受限制的使用那些不上锁的房间，一个人用一间可以，两个人用一间也可以，没限制。但是如果当某个人想要进入上锁的房间，他就要跑到大门口去看看了。有钥匙当然拿了就走，没有的话，就只能等了。</p><p>要是很多人在等这把钥匙，等钥匙还回来以后，谁会优先得到钥匙？Not guaranteed。象前面例子里那个想连续使用两个上锁房间的家伙，他中间还钥匙的时候如果还有其他人在等钥匙，那么没有任何保证这家伙能再次拿到。 （JAVA规范在很多地方都明确说明不保证，像Thread.sleep()休息后多久会返回运行，相同优先权的线程那个首先被执行，当要访问对象的锁被 释放后处于等待池的多个线程哪个会优先得到，等等。我想最终的决定权是在JVM，之所以不保证，就是因为JVM在做出上述决定的时候，绝不是简简单单根据 一个条件来做出判断，而是根据很多条。而由于判断条件太多，如果说出来可能会影响JAVA的推广，也可能是因为知识产权保护的原因吧。SUN给了个不保证 就混过去了。无可厚非。但我相信这些不确定，并非完全不确定。因为计算机这东西本身就是按指令运行的。即使看起来很随机的现象，其实都是有规律可寻。学过 计算机的都知道，计算机里随机数的学名是伪随机数，是人运用一定的方法写出来的，看上去随机罢了。另外，或许是因为要想弄的确太费事，也没多大意义，所 以不确定就不确定了吧。）</p><p>再来看看同步代码块。和同步方法有小小的不同。</p><p>1.从尺寸上讲，同步代码块比同步方法小。你可以把同步代码块看成是没上锁房间里的一块用带锁的屏风隔开的空间。</p><p>2.同步代码块还可以人为的指定获得某个其它对象的key。就像是指定用哪一把钥匙才能开这个屏风的锁，你可以用本房的钥匙；你也可以指定用另一个房子的钥匙才能开，这样的话，你要跑到另一栋房子那儿把那个钥匙拿来，并用那个房子的钥匙来打开这个房子的带锁的屏风。</p><p> 记住你获得的那另一栋房子的钥匙，并不影响其他人进入那栋房子没有锁的房间。</p><p> 为什么要使用同步代码块呢？我想应该是这样的：首先对程序来讲同步的部分很影响运行效率，而一个方法通常是先创建一些局部变量，再对这些变量做一些 操作，如运算，显示等等；而同步所覆盖的代码越多，对效率的影响就越严重。因此我们通常尽量缩小其影响范围。</p><p>如何做？同步代码块。我们只把一个方法中该同 步的地方同步，比如运算。</p><p> 另外，同步代码块可以指定钥匙这一特点有个额外的好处，是可以在一定时期内霸占某个对象的key。还记得前面说过普通情况下钥匙的使用原则吗。现在不是普通情况了。你所取得的那把钥匙不是永远不还，而是在退出同步代码块时才还。</p><p>  还用前面那个想连续用两个上锁房间的家伙打比方。怎样才能在用完一间以后，继续使用另一间呢。用同步代码块吧。先创建另外一个线程，做一个同步代码 块，把那个代码块的锁指向这个房子的钥匙。然后启动那个线程。只要你能在进入那个代码块时抓到这房子的钥匙，你就可以一直保留到退出那个代码块。也就是说 你甚至可以对本房内所有上锁的房间遍历，甚至再sleep(10<em>60</em>1000)，而房门口却还有1000个线程在等这把钥匙呢。很过瘾吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://zhh9106.iteye.com/blog/2151791&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhh9106.iteye.com/blog/2151791&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="并发编程" scheme="https://mlone.top/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="线程" scheme="https://mlone.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="java" scheme="https://mlone.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>接口回调</title>
    <link href="https://mlone.top/post/b027d2d7.html"/>
    <id>https://mlone.top/post/b027d2d7.html</id>
    <published>2018-09-17T10:07:18.000Z</published>
    <updated>2019-02-25T14:52:05.176Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/xiaanming/article/details/8703708" target="_blank" rel="noopener">https://blog.csdn.net/xiaanming/article/details/8703708</a></p><a id="more"></a><p>以前不理解什么叫回调，天天听人家说加一个回调方法啥的，心里想我草，什么叫回调方法啊？然后自己就在网上找啊找啊找，找了很多也不是很明白，现在知道了，所谓回调：就是A类中调用B类中的某个方法C，然后B类中反过来调用A类中的方法D，D这个方法就叫回调方法，这样子说你是不是有点晕晕的，其实我刚开始也是这样不理解，看了人家说比较经典的回调方式：</p><ul><li>Class A实现接口CallBack callback——背景1</li><li>Class A中包含一个class B的引用b ——背景2</li><li>Class B有一个参数为callback的方法f(CallBack callback) ——背景3</li></ul><p>A的对象a调用B的方法 f(CallBack callback) ——A类调用B类的某个方法 C</p><p>然后b就可以在f(CallBack callback)方法中调用A的方法 ——B类调用A类的某个方法D</p><p>大家都喜欢用打电话的例子，好吧，为了跟上时代，我也用这个例子好了，我这个例子采用异步加回调:</p><p>有一天小王遇到一个很难的问题，问题是“1 + 1 = ?”，就打电话问小李，小李一下子也不知道，就跟小王说，等我办完手上的事情，就去想想答案，小王也不会傻傻的拿着电话去等小李的答案吧，于是小王就对小李说，我还要去逛街，你知道了答案就打我电话告诉我，于是挂了电话，自己办自己的事情，过了一个小时，小李打了小王的电话，告诉他答案是2.</p><pre><code>/** * 这是一个回调接口 * @author xiaanming */public interface CallBack {   /**     * 这个是小李知道答案时要调用的函数告诉小王，也就是回调函数    * @param result 是答案     */    public void solve(String result);}</code></pre><p>.</p><pre><code>/** * 这个是小王 * @author xiaanming * 实现了一个回调接口CallBack，相当于-----&gt;背景一 */public class Wang implements CallBack {    /**     * 小李对象的引用     * 相当于-----&gt;背景二     */    private Li li;     /**     * 小王的构造方法，持有小李的引用     * @param li     */    public Wang(Li li){        this.li = li;    }    /**     * 小王通过这个方法去问小李的问题     * @param question  就是小王要问的问题,1 + 1 = ?     */    public void askQuestion(final String question){        //这里用一个线程就是异步，        new Thread(new Runnable() {            @Override            public void run() {                /**                 * 小王调用小李中的方法，在这里注册回调接口                 * 这就相当于A类调用B的方法C                 */                li.executeMessage(Wang.this, question);             }        }).start();        //小网问完问题挂掉电话就去干其他的事情了，诳街去了        play();    }    public void play(){        System.out.println(&quot;我要逛街去了&quot;);    }    /**     * 小李知道答案后调用此方法告诉小王，就是所谓的小王的回调方法     */    @Override    public void solve(String result) {        System.out.println(&quot;小李告诉小王的答案是---&gt;&quot; + result);    }}</code></pre><p>.</p><pre><code>/** * 这个就是小李啦 * @author xiaanming * */public class Li {    /**     * 相当于B类有参数为CallBack callBack的f()----&gt;背景三     * @param callBack       * @param question  小王问的问题     */    public void executeMessage(CallBack callBack, String question){        System.out.println(&quot;小王问的问题---&gt;&quot; + question);        //模拟小李办自己的事情需要很长时间        for(int i=0; i&lt;10000;i++){        }        /**         * 小李办完自己的事情之后想到了答案是2         */        String result = &quot;答案是2&quot;;        /**         * 于是就打电话告诉小王，调用小王中的方法         * 这就相当于B类反过来调用A的方法D         */        callBack.solve(result);     }}</code></pre><p>.</p><pre><code>/*** 测试类* @author xiaanming*/public class Test {    public static void main(String[]args){        /**         * new 一个小李         */        Li li = new Li();        /**         * new 一个小王         */        Wang wang = new Wang(li);        /**         * 小王问小李问题         */        wang.askQuestion(&quot;1 + 1 = ?&quot;);    }}</code></pre><p>通过上面的那个例子你是不是差不多明白了回调机制呢，上面是一个异步回调，我们看看同步回调吧，onClick（）方法</p><p>现在来分析分析下Android View的点击方法onclick（）;我们知道onclick()是一个回调方法，当用户点击View就执行这个方法，我们用Button来举例好了:</p><pre><code>//这个是View的一个回调接口/** * Interface definition for a callback to be invoked when a view is clicked.  */public interface OnClickListener {    /**     * Called when a view has been clicked.     *     * @param v The view that was clicked.     */    void onClick(View v);}</code></pre><p>.</p><pre><code>package com.example.demoactivity;import android.app.Activity;import android.os.Bundle;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.Toast;/** * 这个就相当于Class A * @author xiaanming * 实现了 OnClickListener接口----&gt;背景一 */public class MainActivity extends Activity implements OnClickListener{    /**     * Class A 包含Class B的引用-----&gt;背景二     */    private Button button;    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        button = (Button)findViewById(R.id.button1);        /**         * Class A 调用View的方法,而Button extends View-----&gt;A类调用B类的某个方法 C         */        button.setOnClickListener(this);    }    /**     * 用户点击Button时调用的回调函数，你可以做你要做的事     * 这里我做的是用Toast提示OnClick     */    @Override    public void onClick(View v) {        Toast.makeText(getApplication(), &quot;OnClick&quot;, Toast.LENGTH_LONG).show();    }}</code></pre><p>下面是View类的setOnClickListener方法，就相当于B类咯，只把关键代码贴出来</p><pre><code>/**  * 这个View就相当于B类  * @author xiaanming  *  */public class View implements Drawable.Callback, KeyEvent.Callback, AccessibilityEventSource {    /**     * Listener used to dispatch click events.     * This field should be made private, so it is hidden from the SDK.     * {@hide}     */    protected OnClickListener mOnClickListener;    /**     * setOnClickListener()的参数是OnClickListener接口------&gt;背景三     * Register a callback to be invoked when this view is clicked. If this view is not     * clickable, it becomes clickable.     *     * @param l The callback that will run     *     * @see #setClickable(boolean)     */    public void setOnClickListener(OnClickListener l) {        if (!isClickable()) {            setClickable(true);        }        mOnClickListener = l;    }    /**     * Call this view&apos;s OnClickListener, if it is defined.     *     * @return True there was an assigned OnClickListener that was called, false     *         otherwise is returned.     */    public boolean performClick() {        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);        if (mOnClickListener != null) {            playSoundEffect(SoundEffectConstants.CLICK);            //这个不就是相当于B类调用A类的某个方法D，这个D就是所谓的回调方法咯            mOnClickListener.onClick(this);            return true;        }        return false;    }}</code></pre><p>这个例子就是Android典型的回调机制，看完这个你是不是更进一步的理解了回调机制呢？ 线程run()也是一个回调方法，当执行Thread的start（）方法就会回调这个run()方法，还有处理消息都比较经典等等</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/xiaanming/article/details/8703708&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/xiaanming/article/details/8703708&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="接口回调" scheme="https://mlone.top/tags/%E6%8E%A5%E5%8F%A3%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>上转型对象</title>
    <link href="https://mlone.top/post/56fd5bd6.html"/>
    <id>https://mlone.top/post/56fd5bd6.html</id>
    <published>2018-09-17T00:07:18.000Z</published>
    <updated>2019-02-25T10:34:05.450Z</updated>
    
    <content type="html"><![CDATA[<p>转自：<a href="https://blog.csdn.net/lyt_7cs1dn9/article/details/54908734" target="_blank" rel="noopener">https://blog.csdn.net/lyt_7cs1dn9/article/details/54908734</a></p><a id="more"></a><h2 id="1、-定义"><a href="#1、-定义" class="headerlink" title="1、 定义"></a>1、 定义</h2><p>如果B类是A类的子类或间接子类，当用B类创建对象b并将这个对象b的引用赋给A类对象a时，如：</p><pre><code>A a;a = new B();</code></pre><p>或者</p><pre><code>A a;B b = new B();a = b;</code></pre><p>则称A类对象a是子类B对象b的上转型对象。 </p><h2 id="2、-性质"><a href="#2、-性质" class="headerlink" title="2、 性质"></a>2、 性质</h2><ul><li><p>对象b的上转型a的实体是有子类B创建的，但是上转型对象会失去子类B的一些属性和功能。上转型对象具有以下特点：</p></li><li><p>上转型对象不能操作子类新增加的成员变量，不能使用子类新增的方法。即为较子类B失去一些属性和功能，这些属性和功能是新增的。 </p></li><li><p>上转型对象可以操作子类继承或隐藏的成员变量，也可以使用子类继承的或重写的方法。即为上转型对象可以操纵父类原有的属性和功能，无论这些方法是否被重写。</p></li><li><p>上转型对象调用方法时，就是调用子类继承和重写过的方法。而不会是新增的方法，也不是父类原有的方法。 </p></li><li><p>可以将对象的上转型对象再强制转换到一个子类对象，强制转换过的对象具有子类所有属性和功能。</p></li></ul><h2 id="3、举例"><a href="#3、举例" class="headerlink" title="3、举例"></a>3、举例</h2><p>如：</p><pre><code>OutputStream output;output = new FileOutputStream(filename);</code></pre><p>并且根据Java API知：</p><pre><code>java.lang.Object      java.io.OutputStream         java.io.FileOutputStream</code></pre><p>这时，output就是上转型对象啦。有什么特殊呢？就是output可以使用FileOutputStream从父类OutputStream那里继承来的方法和重写的方法，而不能使用子类FileOutputStream自己新增的方法啦。最后，这种方法是很常用的哦。。。当父类有很多子类时，就能实现方法的多态。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自：&lt;a href=&quot;https://blog.csdn.net/lyt_7cs1dn9/article/details/54908734&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/lyt_7cs1dn9/article/details/54908734&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="语法" scheme="https://mlone.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>java中的传值与传引用</title>
    <link href="https://mlone.top/post/92f278e5.html"/>
    <id>https://mlone.top/post/92f278e5.html</id>
    <published>2018-09-16T10:01:55.000Z</published>
    <updated>2019-02-25T10:25:33.778Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://www.cnblogs.com/zhangj95/p/4184180.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangj95/p/4184180.html</a></p><a id="more"></a><p>java函数中的传值和传引用问题一直是个比较“邪门”的问题，其实java函数中的参数都是传递值的，所不同的是对于基本数据类型传递的是参数的一份拷贝，对于类类型传递的是该类参数的引用的拷贝，当在函数体中修改参数值时，无论是基本类型的参数还是引用类型的参数，修改的只是该参数的拷贝，不影响函数实参的值，如果修改的是引用类型的成员值，则该实参引用的成员值是可以改变的，例子如下。</p><p>首先是定义改变参数的:</p><pre><code>public static void changeInt(int i) {// 改变int型变量的函数    i = 100;}public static void changeString(String s) {// 改变String型变量的函数    s = &quot;changeString&quot;;}public static void changeModel(Model model) {// 改变Model型变量的函数    model = new Model();    model.i = 1;    model.s = &quot;changeModel&quot;;}public static void changeModel2(Model model) {// 改变Model型变量的成员的函数    model.i = 1;    model.s = &quot;changeModel&quot;;}// 类Modelclass Model {    public int i = 0;    public String s = &quot;no value&quot;;}// 测试程序public static void main(String[] args) {    int i = 0;    String s = &quot;hello&quot;;    Model model = new Model();    Model model2 = new Model();    changeInt(i);    System.out.println(&quot;i=&quot; + i);    changeString(s);    System.out.println(&quot;s=&quot; + s);    changeModel(model);    System.out.println(&quot;model:&quot; + model.s);    changeModel2(model2);    System.out.println(&quot;model2:&quot; + model2.s);}</code></pre><p>测试结果：</p><p>   i=0</p><p>   s=hello</p><p>   model:no value</p><p>   model2:changeModel</p><p>可以看出i没有改变，s也没有改变，mode也没有改变，model2的s改变了。</p><p>总结：</p><p><strong>java中的形参是复制实参的一份拷贝（对于引用型则是复制引用的拷贝）（在栈中的拷贝）</strong>，所以在函数中改变形参是无法改变实参的值的，改变引用只是将形参所代表的引用指向另外的新的对象，而实参的引用还指向原来的对象，改变形参引用的成员当然会影响实参引用成员的值，因为他们的引用都指向同一个对象。</p><p>原文地址：<a href="http://blog.sina.com.cn/s/blog_5198c7370100dut4.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_5198c7370100dut4.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://www.cnblogs.com/zhangj95/p/4184180.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zhangj95/p/4184180.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="语法" scheme="https://mlone.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>匿名内部类访问方法成员变量需要加final的原因及证明</title>
    <link href="https://mlone.top/post/be65bf03.html"/>
    <id>https://mlone.top/post/be65bf03.html</id>
    <published>2018-09-15T11:52:19.000Z</published>
    <updated>2019-02-23T12:13:23.169Z</updated>
    
    <content type="html"><![CDATA[<p>转载自：<a href="https://blog.csdn.net/wjw521wjw521/article/details/77333820" target="_blank" rel="noopener">https://blog.csdn.net/wjw521wjw521/article/details/77333820</a><br><a id="more"></a></p><p>在java编程中，没用的类定义太多对系统来说也是一个负担，这时候我们可以通过定义匿名内部类来简化编程，但匿名内部类访问外部方法的成员变量时都要求外部成员变量添加final修饰符，final修饰变量代表该变量只能被初始化一次，以后不能被修改。但为什么匿名内部类访问外部成员变量就不允许他修改了呢？<br>接下来这个例子应该足够把这些说清楚了：<br>示例代码：</p><pre><code>public class InnerFinalTest {    private static Test test0= null;    public static void main(String[] args) {        new InnerFinalTest().method1();        System.out.println(&quot;-------&quot;);        test0.test();    }    public void method1(){        final Test  test = new Test();            test0 = new Test(){            @Override            public void test(){                                System.out.println(&quot;匿名内部类：&quot; + test);                Field[] field = this.getClass().getDeclaredFields();                for (int i = 0; i &lt; field.length; i++) {                    System.out.println(field[i].getName());                }                }        };        InnerFinalTest ift = new InnerFinalTest();        ift.innerFinalTest(test0);        System.out.println(&quot;外部直接访问变量：&quot;+ test);    }    public void innerFinalTest(Test test){        test.test();            }}</code></pre><p>Test类无关紧要，不过还是贴一下吧</p><pre><code>public class Test {    public void test(){        System.out.println(&quot;啊啊啊啊啊！&quot; );    }}</code></pre><p>说明：<br>为什么我们要将被匿名内部类访问的变量定义成final呢？<br>首先，我们在InnerFinalTest类中定义了一个static变量test0:</p><pre><code>private static Test test0= null;</code></pre><p>该语句说明test0的生命周期和类一样</p><p>接下来在main方法中调用method1（），在method1（）中将我们定义的匿名内部类赋给了test0,这说明如果test0不往别处指的话，我们匿名内部类将被一直引用着，如同吃了九转大金丹，与天地同寿，与日月齐光，匿名内部类生命周期和InnerFinalTest类（匿名类的天地）相同了。</p><p>但是，method1（）调用完了他要释放资源了，所以method1（）方法中：</p><pre><code>final Test  test = new Test();</code></pre><p>test变量也要被释放了，test没了，但匿名内部类引用了test，如果java编译器不搞点小动作，他就没法玩儿了，因为匿名类的生命周期长，还使用着test，而外部变量先撤了，背后捅了匿名内部类一刀子。。。</p><p>匿名内部类说，就防着你这一招呢，所以叫编译器大哥帮忙搞了个小动作，明修栈道暗度陈仓，编译的时候，我自己把你给我的变量备份了一份，表面上看是我引用了你的变量，其实在运行期间我就用我自己备份的了。但是别人表面上看不知道我备份了一份，还以为我用的你的，如果不定义成final，变量在外面被修改了，我没改，那我的结果就会和预期不同，为了防止出现这种情况，所以要被定义成final。</p><p>上面实例代码运行结果：</p><p>匿名内部类：Test@40e455bf</p><p>this$0</p><p>val$test</p><p>外部直接访问变量：Test@40e455bf</p><p>匿名内部类：Test@40e455bf</p><p>this$0</p><p>val$test</p><p>我用反射证明了匿名内部类存在外部变量的备份val$test，其中因为变量是默认类型，所以使用getDeclaredFields得到所有匿名内部类运行期间存在的成员属性。</p><p>（注意，该成员属性在编码期间是不存在的，是编译器主动为匿名内部类添加的成员属性，所以可以通过反射在运行期间一窥究竟。）</p><p>如果去掉匿名内部类对外部变量的引用，如去掉以下代码：</p><pre><code>System.out.println(&quot;匿名内部类：&quot; + test);</code></pre><p>运行结果中会没有了val$test，这也再次证明了以上结论：<strong>匿名内部类备份了变量。</strong></p><p>通过外部变量和内部变量打印内容相同，说明两个变量test和val$test的变量引用指向的内存区域是相同的，（这里可以参考一下原型模式浅克隆）。指向相同对象，虽然对象不能修改，但对象中的属性可以修改，而匿名内部类变量和外部变量指向相同，自然值也同步修改了。</p><p>总结一下，逻辑应该是这样的：<strong>为了解决生命周期不同的问题，匿名内部类备份了变量，为了解决备份变量引出的问题，外部变量要被定义成final。匿名内部类使用final不是怕修改，是怕不能同步修改。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自：&lt;a href=&quot;https://blog.csdn.net/wjw521wjw521/article/details/77333820&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/wjw521wjw521/article/details/77333820&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="内部类" scheme="https://mlone.top/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>字节流与字符流</title>
    <link href="https://mlone.top/post/2e5c77c2.html"/>
    <id>https://mlone.top/post/2e5c77c2.html</id>
    <published>2018-09-14T11:45:51.000Z</published>
    <updated>2019-02-25T14:42:03.788Z</updated>
    
    <content type="html"><![CDATA[<p>转载自:<a href="http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html" target="_blank" rel="noopener">http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html</a></p><a id="more"></a><p>先来看一下流的概念：</p><p>在程序中所有的数据都是以流的方式进行传输或保存的，程序需要数据的时候要使用输入流读取数据，而当程序需要将一些数据保存起来的时候，就要使用输出流完成。</p><p><strong>程序中的输入输出都是以流的形式保存的，流中保存的实际上全都是字节文件。</strong></p><h2 id="字节流与字符流"><a href="#字节流与字符流" class="headerlink" title="字节流与字符流"></a>字节流与字符流</h2><p>在java.io包中操作文件内容的主要有两大类：字节流、字符流，两类都分为输入和输出操作。在字节流中输出数据主要是使用OutputStream完成，输入使的是InputStream，在字符流中输出主要是使用Writer类完成，输入流主要使用Reader类完成。（这四个都是抽象类）</p><h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><p>在Java中IO操作也是有相应步骤的，以文件操作为例，主要的操作流程如下：</p><ol><li>使用File类打开一个文件</li><li>通过字节流或字符流的子类，指定输出的位置</li><li>进行读/写操作</li><li>关闭输入/输出</li></ol><p><strong>IO操作属于资源操作，一定要记得关闭</strong></p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流主要是操作byte类型数据，以byte数组为准，主要操作类就是OutputStream、InputStream</p><p>字节输出流：OutputStream</p><p>OutputStream是整个IO包中<strong>字节输出流的最大父类</strong>，此类的定义如下：</p><p><em>public abstract class OutputStream extends Object implements Closeable,Flushable</em></p><p>从以上的定义可以发现，此类是一个抽象类，如果想要使用此类的话，则首先必须通过子类实例化对象，那么如果现在要操作的是一个文件，则可以使用：FileOutputStream类。通过向上转型之后，可以为OutputStream实例化</p><p><strong>Closeable表示可以关闭的操作，因为程序运行到最后肯定要关闭</strong></p><p><strong>Flushable：表示刷新，清空内存中的数据</strong></p><p>FileOutputStream类的构造方法如下：</p><p>public FileOutputStream(File file)throws FileNotFoundException</p><p>写数据：</p><pre><code>import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建        String str=&quot;Hello World&quot;;        byte[] b=str.getBytes();        out.write(b);//因为是字节流，所以要转化成字节数组进行输出        out.close();    }}</code></pre><p>也可以一个字节一个字节进行输出，如下：</p><pre><code>import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        OutputStream out=new FileOutputStream(f);//如果文件不存在会自动创建        String str=&quot;Hello World&quot;;        byte[] b=str.getBytes();        for(int i=0;i&lt;b.length;i++){            out.write(b[i]);        }        out.close();    }}</code></pre><p>以上输出只会进行覆盖，如果要追加的话，请看FileOutputStream类的另一个构造方法：</p><p><strong>public FileOutputStream(File file,boolean append)throws FileNotFoundException</strong></p><p>在构造方法中，如果将append的值设置为true，则表示在文件的末尾追加内容。</p><pre><code>import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.io.OutputStream;public class Test11 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        OutputStream out=new FileOutputStream(f,true);//追加内容        String str=&quot;\r\nHello World&quot;;        byte[] b=str.getBytes();        for(int i=0;i&lt;b.length;i++){            out.write(b[i]);        }        out.close();    }}</code></pre><p><strong>文件中换行为：\r\n</strong></p><h3 id="字节输入流：InputStream"><a href="#字节输入流：InputStream" class="headerlink" title="字节输入流：InputStream"></a>字节输入流：InputStream</h3><p>既然程序可以向文件中写入内容，则就可以通过InputStream从文件中把内容读取进来，首先来看InputStream类的定义：</p><p><em>public abstract class InputStream extends Object implements Closeable</em></p><p>与OutputStream类一样，InputStream本身也是一个抽象类，必须依靠其子类，如果现在是从文件中读取，就用FileInputStream来实现。</p><p>观察FileInputStream类的构造方法：</p><p><em>public FileInputStream(File file)throws FileNotFoundException</em></p><p>读文件：</p><pre><code>import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test12 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        InputStream in=new FileInputStream(f);        byte[] b=new byte[1024];        int len=in.read(b);        in.close();        System.out.println(new String(b,0,len));    }}</code></pre><p>但以上方法是有问题的，用不用开辟这么大的一个字节数组，明显是浪费嘛，我们可以根据文件的大小来定义字节数组的大小，File类中的方法：public long length()</p><pre><code>import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test13 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        InputStream in=new FileInputStream(f);        byte[] b=new byte[(int) f.length()];        in.read(b);        in.close();        System.out.println(new String(b));    }}</code></pre><p>我们换种方式，一个字节一个字节读入~</p><pre><code>import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test14 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        InputStream in=new FileInputStream(f);        byte[] b=new byte[(int) f.length()];        for(int i=0;i&lt;b.length;i++){            b[i]=(byte) in.read();        }        in.close();        System.out.println(new String(b));    }}</code></pre><p>但以上情况只适合知道输入文件的大小，不知道的话用如下方法：</p><pre><code>import java.io.File;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;public class Test15 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        InputStream in=new FileInputStream(f);        byte[] b=new byte[1024];        int temp=0;        int len=0;        while((temp=in.read())!=-1){//-1为文件读完的标志            b[len]=(byte) temp;            len++;        }        in.close();        System.out.println(new String(b,0,len));    }}</code></pre><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>在程序中一个字符等于两个字节，那么java提供了Reader、Writer两个专门操作字符流的类。</p><h3 id="字符输出流：Writer"><a href="#字符输出流：Writer" class="headerlink" title="字符输出流：Writer"></a>字符输出流：Writer</h3><p>Writer本身是一个字符流的输出类，此类的定义如下：</p><p><em>public abstract class Writer extends Object implements Appendable，Closeable，Flushable</em></p><p>此类本身也是一个抽象类，如果要使用此类，则肯定要使用其子类，此时如果是向文件中写入内容，所以应该使用FileWriter的子类。</p><p>FileWriter类的构造方法定义如下：</p><p><em>public FileWriter(File file)throws IOException</em></p><p>字符流的操作比字节流操作好在一点，就是可以直接输出字符串了，不用再像之前那样进行转换操作了。</p><p>写文件：</p><pre><code>import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Test16 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        Writer out=new FileWriter(f);        String str=&quot;Hello World&quot;;        out.write(str);        out.close();    }}</code></pre><p>在默认情况下再次输出会覆盖，追加的方法也是在构造函数上加上追加标记</p><pre><code>import java.io.File;import java.io.FileWriter;import java.io.IOException;import java.io.Writer;public class Test17 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        Writer out=new FileWriter(f,true);//追加        String str=&quot;\r\nHello World&quot;;        out.write(str);        out.close();    }}</code></pre><h3 id="字符输入流：Reader"><a href="#字符输入流：Reader" class="headerlink" title="字符输入流：Reader"></a>字符输入流：Reader</h3><p>Reader是使用字符的方式从文件中取出数据，Reader类的定义如下：</p><p><em>public abstract class Reader extends Objects implements Readable，Closeable</em></p><p>Reader本身也是抽象类，如果现在要从文件中读取内容，则可以直接使用FileReader子类。</p><p>FileReader的构造方法定义如下：</p><p><em>public FileReader(File file)throws FileNotFoundException</em></p><p>以字符数组的形式读取出数据：</p><pre><code>import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class Test18 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        Reader input=new FileReader(f);        char[] c=new char[1024];        int len=input.read(c);        input.close();        System.out.println(new String(c,0,len));    }}</code></pre><p>也可以用循环方式，判断是否读到底：</p><pre><code>import java.io.File;import java.io.FileReader;import java.io.IOException;import java.io.Reader;public class Test19 {    public static void main(String[] args) throws IOException {        File f = new File(&quot;d:&quot; + File.separator+&quot;test.txt&quot;);        Reader input=new FileReader(f);        char[] c=new char[1024];        int temp=0;        int len=0;        while((temp=input.read())!=-1){            c[len]=(char) temp;            len++;        }        input.close();        System.out.println(new String(c,0,len));    }}</code></pre><h2 id="字节流与字符流的区别"><a href="#字节流与字符流的区别" class="headerlink" title="字节流与字符流的区别"></a>字节流与字符流的区别</h2><p>字节流和字符流使用是非常相似的，那么除了操作代码的不同之外，还有哪些不同呢？</p><p><em>字节流在操作的时候本身是不会用到缓冲区（内存）的，是与文件本身直接操作的，而字符流在操作的时候是使用到缓冲区的</em></p><p><em>字节流在操作文件时，即使不关闭资源（close方法），文件也能输出，但是如果字符流不使用close方法的话，则不会输出任何内容，说明字符流用的是缓冲区，并且可以使用flush方法强制进行刷新缓冲区，这时才能在不close的情况下输出内容</em></p><p><strong>那开发中究竟用字节流好还是用字符流好呢？</strong></p><p><em>在所有的硬盘上保存文件或进行传输的时候都是以字节的方法进行的，包括图片也是按字节完成，而字符是只有在内存中才会形成的，所以使用字节的操作是最多的。</em></p><p><strong>如果要java程序实现一个拷贝功能，应该选用字节流进行操作（可能拷贝的是图片），并且采用边读边写的方式（节省内存）。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自:&lt;a href=&quot;http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cnblogs.com/lich/archive/2011/12/11/2283700.html&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="语法" scheme="https://mlone.top/tags/%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>内部类</title>
    <link href="https://mlone.top/post/9bc01b38.html"/>
    <id>https://mlone.top/post/9bc01b38.html</id>
    <published>2018-09-14T11:38:39.000Z</published>
    <updated>2019-02-23T12:08:44.001Z</updated>
    
    <content type="html"><![CDATA[<p>内容来自：<a href="https://www.nowcoder.com/" target="_blank" rel="noopener">牛客网</a></p><a id="more"></a><h4 id="成员内部类："><a href="#成员内部类：" class="headerlink" title="成员内部类："></a>成员内部类：</h4><pre><code>可以访问外部所有资源，但是本身内部不可以有静态属性（因为自己本身就需要依靠外部类的实例化）。</code></pre><h4 id="局部内部类："><a href="#局部内部类：" class="headerlink" title="局部内部类："></a>局部内部类：</h4><pre><code>不可被访问修饰符和static修饰，且只能访问外部类的final变量和所在函数的形参。</code></pre><h4 id="匿名内部类："><a href="#匿名内部类：" class="headerlink" title="匿名内部类："></a>匿名内部类：</h4><pre><code>不可被访问修饰符和static修饰，且只能访问外部类的final变量和所在函数的形参；没有构造器，没有静态资源；只能创建一个实例；不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法</code></pre><p><img src="/assets/blogImg/4/1.png" alt="图片1"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内容来自：&lt;a href=&quot;https://www.nowcoder.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;牛客网&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://mlone.top/categories/Java/"/>
    
    
      <category term="内部类" scheme="https://mlone.top/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发需要学什么</title>
    <link href="https://mlone.top/post/a440b81f.html"/>
    <id>https://mlone.top/post/a440b81f.html</id>
    <published>2018-09-13T09:58:41.000Z</published>
    <updated>2019-02-23T10:08:53.101Z</updated>
    
    <content type="html"><![CDATA[<p>以下内容来源于百度知道：</p><a id="more"></a><h2 id="回答1："><a href="#回答1：" class="headerlink" title="回答1："></a>回答1：</h2><p>安卓开发首先第一阶段是要学习java，掌握java了对于安卓的开发就容易很多，然后在学习安卓的开发环境搭配和生命周期，给你分享一个学习的计划表吧。</p><p><img src="/assets/blogImg/3/1.jpg" alt="图1"></p><p><img src="/assets/blogImg/3/2.jpg" alt="图2"></p><h2 id="回答2："><a href="#回答2：" class="headerlink" title="回答2："></a>回答2：</h2><p>从事Android开发工作依次学习和掌握：</p><p>第一阶段：Java（基础语法、面向对象、IO流、多线程与Socket编程、数据库，网络传输和数据解析等）</p><p>第二阶段：Android应用开发（Android UI、Activity、Fragment碎片、屏幕适配、数据存储等）</p><p>第三阶段：Android高级开发（Volley框架、事件机制与手势识别、消息推送、多媒体等）<br>第四阶段：Android游戏开发（引擎系统，碰撞，音效等）</p><p>第五阶段：编写项目，综合练习掌握和未掌握的专业技术。<br>在学习过程中贯穿着代码实战。看的代码是别人的，动手写出来的是自己的。自己动手写代码，记忆更加深刻，效率更高。</p><h2 id="回答3："><a href="#回答3：" class="headerlink" title="回答3："></a>回答3：</h2><p>Android是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，如智能手机和平板电脑，关于安卓的学习需要学习很多的知识点，但是首先要把基础做好。安卓主要学习：</p><p>阶段一：Java编程开发</p><p><img src="/assets/blogImg/3/3.jpg" alt="图3"></p><p>阶段二：安卓基础开发</p><p><img src="/assets/blogImg/3/4.jpg" alt="图4"></p><p>阶段三：安卓高级开发</p><p><img src="/assets/blogImg/3/5.jpg" alt="图5"></p><p>阶段四：企业项目实战</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下内容来源于百度知道：&lt;/p&gt;
    
    </summary>
    
    
      <category term="安卓开发" scheme="https://mlone.top/tags/%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>周杰伦卖酸菜记</title>
    <link href="https://mlone.top/post/f8e64e55.html"/>
    <id>https://mlone.top/post/f8e64e55.html</id>
    <published>2018-09-13T08:10:15.000Z</published>
    <updated>2019-02-23T09:45:02.583Z</updated>
    
    <content type="html"><![CDATA[<h1 id="周杰伦卖酸菜记"><a href="#周杰伦卖酸菜记" class="headerlink" title="周杰伦卖酸菜记"></a>周杰伦卖酸菜记</h1><p>时间:2018-06-10 07:55:45 来源:中国古典小说网 作者: 中国古典小说网 点击:106次 </p><p>2012年5月4日，福布斯发布“2012年中国名人榜”，歌星周杰伦力压刘德华和姚明，成为华夏名人之首。这项评比，主要依据入选者的知名度和财富。5月7日，周杰伦的老朋友、台湾著名娱记吴乐平，在《旺报》上发表了题为“周杰伦的赚钱小把戏”专访文章。文中爆料，周杰伦在唱歌事业之外，还拥有多项生意，其中最著名的“胡也酸辣菜”生意正准备在新加坡上市发行股票。</p><p>阿婆家地窖的秘密<br><a id="more"></a><br>周杰伦生长在单亲家庭，由母亲抚养长大，生活十分艰辛。最底层市民吃的食物，他都吃过。有时家里没钱买不起肉和菜，母亲就腌制好多咸菜，小周杰伦常常就着咸菜吃米饭。所以，对于咸菜，他有着一种难以割舍的情结。</p><p>2010年夏天，周杰伦在录音棚里苦干两个月，录制出版了新歌辑《十字勋章》后，感到十分疲劳，于是，便和几个好友，悄悄来到阿里山脉的大武恋山区度假。</p><p>为了避来媒体的打扰，一行人住在一个名叫小坝上的小村子里。白天，大家一起去爬山，晚上就坐在农家小床上打牌。房东是一位80多岁的老奶奶，复姓胡也，周杰伦管她叫胡也阿婆。胡也阿婆是个神厨，会做好多阿里山特色饭菜。</p><p>有一天，周杰伦和朋友们在集市上买了一只野兔，胡也阿婆说：“野兔肉腥，需要配酸辣菜一起吃才好。我在地缸里腌了好些呢，今天拿出来给你们尝尝。”</p><p>周杰伦随阿婆来到仓库里，掀开地上的一块青石板，露出一口埋在地里的大缸。胡也阿婆用竹勺子捞上来几根深绿色的菜条，盛在盘子里。周杰伦尝了一口，只觉得一股微酸微辣的滋味，从舌根慢慢地向下滑去，那滋味爽极了，一盘酸辣菜端上桌子，大家瞬间就吃得精光，直呼“阿婆，再来一大盘”。</p><p>回到台北后，周杰伦一直忘不了酸辣菜，那种美的滋味记忆太深了。有一天，他独自开车回到小坝上村，他想跟胡也阿婆学学怎样腌制酸辣菜。</p><p>胡也阿婆告诉他，她祖上胡也清山是明朝万历年间宫廷御厨，后代也大多从事厨师行业。酸辣菜就是祖上传下来的。她家祖辈一直吃酸辣菜，据说里面有营养，能祛病长寿。所以，她的家族成员绝大部分活过了90岁。</p><p>胡也阿婆说：“小伙子，这个祖传秘方是不外传的，你喜欢吃，我可以给你带上好多回去吃。”</p><p>周杰伦带了满满一坛子酸辣菜回到台北，请好友们品尝。大家一片惊呼，著名导演李安吃过之后，对周杰伦说：“这个如果弄到市场上，一定会畅销。”</p><p>周杰伦认定这是一个难得的商机，除了可以赚钱，把这种有利于健康的食品推向市场，让更多人受益，也是个善行。几月后，他又来到小坝上村找胡也阿婆，想和阿婆合作生产这种酸辣菜。阿婆一听，大声呵责道：“你让我出卖老祖宗？”</p><p>周杰伦受到了训斥，心情沮丧地回到台北。一天，李安见到周杰伦，惊奇问他为什么脸色不好？周杰伦说了事情的经过。李安建议周杰伦去找阿婆的儿子或孙子商量。</p><p>经过多方努力，周杰伦终于与胡也阿婆的孙子、当地的一个小学体育教师胡也平取得了联系。胡也平很赞同周杰伦的想法，经过协商，决定由胡也平任总经理兼总技术督导，以技术入股，负责最关键的配方秘密，周杰伦任董事长，负责出资建厂以及产品的销售。因为这个协议执行过程中并无透露酸辣菜的配方，得到了胡也阿婆的许可。2011年元旦，位于台中市的“胡也酸辣菜”有限责任公司正式开工生产了。</p><p>大明星兜售小酸菜</p><p>第一批“胡也酸辣菜”试产品生产出来了，周杰伦一品尝，与胡也阿婆地窖里的酸辣菜毫无二致，他非常兴奋。与胡也平商量一番后，决定开始大批量投入生产。</p><p>一个月后，大批的“胡也酸辣菜”摆进了台中、台南等城市的商场贷架上。然而，现实与周杰伦的预测截然相反，顾客对这种新的咸菜并不感兴趣，有些商场里，一个星期才卖一两袋。有的产品被退了回来，有的经销商表示不愿再经销它。第一批生产的50吨酸辣菜全面滞销，一下损失了近千万新台币。胡也平受到了更大的刺激，因为他辞去了小学教师的公职，现在工厂又不行，他向周杰伦提出辞职。</p><p>胡也平一走，可就是釜底抽薪，一切都完蛋了。周杰伦怎么劝，胡也平也不听，一心要离开公司。周杰伦跑到小坝上村，找到胡也阿婆，经过阿婆的规劝，胡也平同意暂时留在公司里，危机总算化解了。</p><p>周杰伦很难过，也非常奇怪：为什么味美价廉的酸辣菜竟然无人问津？当初广告也打了，推介会也开了，产品包装也非常精美，为什么产生了这样的结果？</p><p>郁闷之中，周杰伦想到了好友前辈郭台铭先生。郭台铭在商界素以“智多星”著称，一定会有好主意给他。于是，周杰伦特地把郭台铭从台北请来台中市，向他请教。郭台铭看了工厂生产车间，品尝了“胡也酸辣菜”之后，不断点头称赞。他认为，产品非常好，关键是宣传做得不好。俗话说，酒好也怕巷子深。郭台铭说：“要吆喝，要向市场大声吆喝，更重要的是把你的产品和周杰伦这个名字联系起来。”</p><p>周杰伦一下子明白了其中的道理。他请来台湾最著名的广告策划人何进身先生，何先生帮周杰伦策划了一套宣传方案，周杰伦看了，连喊：“高明！高明！”</p><p>2011年3月，周杰伦接拍了松下公司的广告。双方谈妥的价格是3000万新台币，正在签单，周杰伦突然在谈判桌上提出“减到一半的价格”。这个提法令松下谈判代表惊诧不已。周杰伦谈了自己的条件：他想在广告发布会上吃自己的咸菜。松下的电子产品和民间小吃根本不矛盾，而且周杰伦此举定会引起媒体热议，无疑会加大松下公司的广告效应，松下谈判代表当即表示同意。</p><p>广告发布会在香港举行，有200多家媒体记者参加。当有记者问周杰伦最近有什么新歌推出时，周杰伦回答：“近三个月没有新歌推出，我正在生产一种小咸菜，厂址在台中。”好事的记者哪有不抱根问底的，于是 “胡也酸辣菜”发布了。</p><p>当晚，关于“周杰伦卖咸菜”的消息就在媒体上出现，人们非常好奇：周杰伦和咸菜有什么干系？一看报道，确确实实，周杰伦在生产一种名叫“胡也酸辣菜”的小咸菜。好奇的人们立即拥向商场，几天之内，滞销的50吨产品被一扫而光。各大商场纷纷打电话告急，脱销！脱销！原来心灰意冷的胡也平变得干劲十足，组织工人昼夜生产，大批酸辣菜源源不断地供应市场。仅仅在2010年第二季度，公司就进账5000万新台币。</p><p>周杰伦见东风好借力，马上追加5000万新台币投资扩建厂房，生产规模迅速扩大到月产600吨的规模。</p><p>不是广告胜似广告</p><p>其实周杰伦并没有意识到，与他一帆风顺的歌唱事业不同的是，商场风云变幻莫测，随时有翻船的危险。“胡也酸辣菜”在市场上亮相后，引起一片热议。有好多人认为周杰伦是歌星，与生产食品风马牛不相及，他搞出的咸菜什么水平，可想而知。2011年8月，一篇题为《腌制食品的亚硝酸盐对人体的危害》的文章，在《苹果日报》副刊发表，文中以“科学数据”论证了胡也酸辣菜的有害成分。</p><p>此文一出，胡也酸辣菜立即受到迎头痛击，几天之内销量下降一半。更为严重的是，刚刚生产出来的产品，积压库房，为防止超长期搁置产生变质，只好租用台中市一家大型冷库存放，每天租金高达50万台币。</p><p>怎么办？周杰伦焦虑万分，如果这样下去，公司很快就垮台。这时，吴宗宪从媒体上得知了消息，他打来电话，周杰伦连说三遍“情况危急”。吴宗宪想了想，建议他把“胡也酸辣菜”送到台北科学研究院进行化验，用“科学数据”来反击“科学数据”。周杰伦觉得这招可行，马上派人把样品送去检验。</p><p>三天后，检验结果出来了，结论是：内中所含微量亚硝盐并未超出一般酿造食品的含量，符合食品食用标准。周杰伦拿到这份检验结论，如获至宝，喜不自禁。他立即让助手邀请媒体，准备召开发布会。</p><p>2011年9月1日，精心筹备的“胡也酸辣菜”卫生检验结果发布会，在台北晶华大酒店隆重举行。预计上午10点开始，可是，周杰伦却没有到场，只有总经理胡也平在主持。前来抢歌星新闻的记者大失所望。面对吵吵嚷嚷大呼上当的记者，胡也平微笑着劝大家耐心等待，一定会有奇迹出现的。他说：“周杰伦永远是周杰伦嘛，他什么时候给过我们失望？”</p><p>尽管如此，周杰伦迟迟未现身，胡也平渐渐地压不住场了。10点半过后，有记者开始收拾长枪短炮，准备退场了。胡也平怎么挽留也没人听。就在这时，有人高呼：“周杰伦来了！”全场的视线一下子集中到台上，只见周杰伦面带微笑，扶着一位老奶奶，一步步走上台前。</p><p>原来，周杰伦昨晚和胡也平一起讨论明天的发布，直到深夜。一直忧心忡忡的周杰伦总是担心发布会的效果不好。胡也平劝他想开一点。忽然，周杰伦一拍大腿，他有了一个想法：把阿婆请到发布会上，现身说法！胡也平眼睛一亮，说：“我怎么没想到这招呢？”他立即打电话给奶奶，胡也阿婆本来不想来，但听孙子介绍了目前的严重情况后，老太太也着急了。于是，周杰伦立即雇了专机直飞台中市，然后乘出租车直达小坝上村，一路风尘，终于在发布会结前赶到了现场。</p><p>胡也阿婆虽然88岁了，但身板硬朗，声如洪钟。她大声对着全场记者说：“谁说我的酸辣菜有毒？我吃了一辈子，我被毒死了么？我们家族高祖在明朝是御厨，酸辣菜是我高祖发明的健身长寿菜，我们家族吃它吃了几百年了，不但没有一个得癌，反而个个高寿。我爷爷奶奶都活过了95岁，我母亲前年113岁才去世，连战先生在十年前还给我母亲授过奖呢。”</p><p>全场爆发出雷鸣般的掌声，周杰伦心里乐开了花，他明白，一切问题都迎刃而解了。</p><p>胡也酸辣菜恢复了往日的辉煌，东南亚好多国家的华商也开始经销。按周杰伦的想法，东南亚国家华裔市场极具潜力，且中国产食品的竞争远未达到大陆和港台的白热化程度，是一个最可开发的处女地市场。于是，他把“胡也酸辣菜”的市场重点推向了东南亚和北美的华裔市场。</p><p>由于周杰伦在华人中的巨大影响力，胡也酸辣菜顺利地在华人超市中站稳了脚根，销量以几何级数上升，2012年第一季度，产值高达到7亿新台币。</p><p>目前，周杰伦正在运作将“胡也酸辣菜”在新加坡发行股票，上市前的资本前期工作己经结束，周杰伦和他的团队相信，一只生产咸菜的股票不久后就会在股市上成为明星。</p><p>(责任编辑：中国古典小说网)<br>转载自<a href="https://www.seeol.com/chengyu-detail-32220.html" target="_blank" rel="noopener">https://www.seeol.com/chengyu-detail-32220.html</a></p>]]></content>
    
    <summary type="html">
    
      2012年5月4日，福布斯发布“2012年中国名人榜”，歌星周杰伦力压刘德华和姚明，成为华夏名人之首...
    
    </summary>
    
      <category term="杂记" scheme="https://mlone.top/categories/%E6%9D%82%E8%AE%B0/"/>
    
    
      <category term="杰伦" scheme="https://mlone.top/tags/%E6%9D%B0%E4%BC%A6/"/>
    
      <category term="酸菜" scheme="https://mlone.top/tags/%E9%85%B8%E8%8F%9C/"/>
    
  </entry>
  
  <entry>
    <title>忻钰坤第二弹--《心迷宫》简单解读[转载]</title>
    <link href="https://mlone.top/post/b690c376.html"/>
    <id>https://mlone.top/post/b690c376.html</id>
    <published>2018-09-11T07:22:43.000Z</published>
    <updated>2019-02-23T09:43:18.486Z</updated>
    
    <content type="html"><![CDATA[<p>电影前10分钟，留下了太多的悬念。这几个看似无关的“线头”故意“现出来”，稍后由它们牵扯出余下的“线”——一条条相互交缠。</p><a id="more"></a><p>那些可能永远无法解释的巧合，常常被称之为“命运”的东西，其实存在它的合理性——不过是每个人在衡量自己利益最大化之后的选择。这种趋利避害，也不过是生存的本能而已。</p><p><img src="/assets/blogImg/2/1.jpg" alt="剧照1"></p><h5 id="发生在村里的故事"><a href="#发生在村里的故事" class="headerlink" title="发生在村里的故事"></a>发生在村里的故事</h5><p>故事发生在村里。对这个地点，或者说这个组成社会的一个单位，村是一个极有意思的存在。说它有意思是因为，它的原始性、自然性和独特性。村，是社会化的产物，但同时它又不那么科学化、理性化、法制化。</p><p>在村之上乡镇、城市似乎都遵循着一个“法”，但村稍稍不同，它更本源的延续了人类凝聚之后的另一种约束方式——道德。在一个村之中，有时候是不讲法的，更多的是理、是信、是义，是约定俗成，是人情世故，是中庸之道。所以，这样一个近似荒诞，看似缺乏逻辑的存在，其实在村里是非常合理的存在。因为，村是自成运作系统的。</p><p>比如影片中村长的推选，便是建立在信义的基础上。在妻子口中我们知道，老村长为村子兢兢业业，从不贪图，所以换届选举完胜用金钱拉选票的人。在村民们眼中，能为自己办实事，人品上德高望重，办事上以村民利益为先的，便是好村长。而这种道德上的“选举”和“任命”无论在凝聚力上还是在民心所向上，无疑都是更加人性化的。结尾处，无论是老村长要辞去村长一职，还是去自首，其实都是内心中无法跨过道德这道坎。</p><p><img src="/assets/blogImg/2/2.jpg" alt="剧照2"></p><h5 id="村里的事都是稀里糊涂的"><a href="#村里的事都是稀里糊涂的" class="headerlink" title="村里的事都是稀里糊涂的"></a>村里的事都是稀里糊涂的</h5><p>要说人活着，大事小事有时候该糊涂的时候就得糊涂。很多事情都没办法钉是钉铆是铆的去深究。中国人有一句俗话叫“难得糊涂”，虽然是一个公认的可以称得上是知识分子的老先生郑板桥提出来的，但它恰好最大的体现在村里人中。</p><p>电影中的故事，可能有人会很不理解：怎么死了人，不报警、不验尸、不走法律程序呢？仅仅凭一句话就盖棺定论了呢？从第一个亡者开始，这种“约定俗成”便很好的说明了这个问题：村里的事儿，只要是大家认可了的，在村里就能解决，何必大动干戈？开篇的引子，已经为整部戏定下了基调：一个老头去烧山，结果自己没走出来烧死掉了。大家公认，合情合理，自然没有必要去报案。用棺材装了，停三天，埋了，大家吃个流水席。那么这件事在村里就算是了了。于是乎，当村里接二连三出现尸体的时候，只要有一个适当的解释，那么这自然就不是事。正所谓“民不举，官不究”。单反符合了村里大致的说法，完成了大家公认的程序，每个人都有一个知会，那么这便不再是个事儿。</p><p>令人感到好笑和荒诞的地方是，为什么最后根本没人深究死人究竟是谁？大家自己过上了自己想要的生活，那么好奇心只会平添烦恼，所以何必事事都要弄得请清除吃吃呢？如果影片最后没有出现那几行字的结局，仅仅是一具棺椁和三个人的心照不宣，村里的生活还将继续。可能过上几个月便是全村兴高采烈地喝上欢欢和和宗耀的喜酒也说不定哦！</p><p><img src="/assets/blogImg/2/3.jpg" alt="剧照3"></p><h5 id="村里的人都是精明智慧的"><a href="#村里的人都是精明智慧的" class="headerlink" title="村里的人都是精明智慧的"></a>村里的人都是精明智慧的</h5><p>要说这事情可能是糊涂，但这人却极为精明。村里是一个相对封闭的环境，人在这种氛围中几乎可以完全熟悉任意一个人的秘密。相处久了，基本上张家长李家短的，没有不知道的。所以，每个人心中都有一杆秤，衡量着自己，也衡量着别人。</p><p>之所以说越是底层人也是聪明，是因为他们可以循着本能取追求自己利益的最大化。几个镜头中出现的电视节目，播放的都是星星生活的场景，这并非巧合，而是一种映射——从本质上讲，人和动物没什么区别，生存才是最重要的。如何生活的更好，是每个人都追求的。我们完全可以看到，每个人的每条线都如此清晰的摆在眼前。他们的每一次选择都是按照如何最大限度实现自己利益为前提的。而人生，不过就是一次次选择的叠加，于是，每一次选择下来，人生的走向便有所不同。本片中，可笑的是，很多人的“最优选择”却导致的是“最惨后果”。但综合利弊，你却无法指责他每次选择上的正确性，或许这就是我们所说的“命”。</p><p>要说最智慧的存在，其实还是人民群众。电影展现的非常简洁，却真实的让人汗毛都能竖起来：人在生存的时候，无非就是见招拆招。或许这句话有些武侠化了，那么用普通话说，就是：出事儿，想辙。在事情发生的几乎不到48小时中，你听不到抱怨。事情出了，最简单直接的方式就是想办法解决。而这才是最普通却也是最值得竖起大拇指的行为。</p><p>人生其实很简单，就像我的曾经在牌桌上说的一句话：不要抱怨你手里的牌，重要的是如何打好一手烂牌。电影中每个人也都是如此，最原始的趋利避害，最原始的解决问题，最原始的寻找生存下来的途径。而这，就是人与生俱来的智慧所在。</p><p>在九百六十万平方公里的土地上，法律所及的地方太小。从根本上，这是一个讲情的国度，而这情，人类，其实就是这样祖祖辈辈生生不息的延续着。</p><p><img src="/assets/blogImg/2/4.jpg" alt="剧照4"></p><p>PS：</p><p>1、影片最后几行字的交代，应该并非原作者的本意吧。相信他应该也能明白，只留下最后一个镜头就好，整部影片的深意完完全全会提升两个档次！那种民族或人类最原始的东西都在涌动着。当然，为了能让更多人看到，加一个“尾巴”也可以理解。</p><p>2、人都是以自我为中心运转着，如果说每个人是一个小宇宙，那么可能你永远预料不到的是他人对你的影响，以及你背后更大的银河系发生着什么样的事。一切都是玄而又玄的，变数时时存在。</p><p>原文地址：<a href="http://i.mtime.com/5807981/blog/7926134/" target="_blank" rel="noopener">《心迷宫》：迷宫尽头是生存本能</a></p><h5 id="最后加几张电影海报"><a href="#最后加几张电影海报" class="headerlink" title="最后加几张电影海报"></a>最后加几张电影海报</h5><p><img src="/assets/blogImg/2/5.jpg" alt="剧照5"></p><p><img src="/assets/blogImg/2/6.jpg" alt="剧照6"></p><p><img src="/assets/blogImg/2/7.jpg" alt="剧照7"></p><p><img src="/assets/blogImg/2/8.jpg" alt="剧照8"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电影前10分钟，留下了太多的悬念。这几个看似无关的“线头”故意“现出来”，稍后由它们牵扯出余下的“线”——一条条相互交缠。&lt;/p&gt;
    
    </summary>
    
      <category term="影视" scheme="https://mlone.top/categories/%E5%BD%B1%E8%A7%86/"/>
    
    
      <category term="影视" scheme="https://mlone.top/tags/%E5%BD%B1%E8%A7%86/"/>
    
      <category term="真实" scheme="https://mlone.top/tags/%E7%9C%9F%E5%AE%9E/"/>
    
      <category term="生活" scheme="https://mlone.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="犯罪" scheme="https://mlone.top/tags/%E7%8A%AF%E7%BD%AA/"/>
    
      <category term="悬疑" scheme="https://mlone.top/tags/%E6%82%AC%E7%96%91/"/>
    
  </entry>
  
  <entry>
    <title>忻钰坤第一弹--《爆裂无声》深度解析[转载]</title>
    <link href="https://mlone.top/post/66b74461.html"/>
    <id>https://mlone.top/post/66b74461.html</id>
    <published>2018-09-10T07:00:10.000Z</published>
    <updated>2019-02-23T09:42:52.776Z</updated>
    
    <content type="html"><![CDATA[<p>电影《暴裂无声》是由忻钰坤执导的犯罪悬疑片，姜武、宋洋、袁文康、谭卓等主演。暴裂无声剧情讲述了在北方凛冽的冬天，一个牧羊少年带着自家的羊群在山里行走，…</p><a id="more"></a><h2 id="暴裂无声观影后细节分析"><a href="#暴裂无声观影后细节分析" class="headerlink" title="暴裂无声观影后细节分析"></a>暴裂无声观影后细节分析</h2><h6 id="不知道当你看完《暴裂无声》，是不是也和电影的主角一样，不想声，失语了……"><a href="#不知道当你看完《暴裂无声》，是不是也和电影的主角一样，不想声，失语了……" class="headerlink" title="不知道当你看完《暴裂无声》，是不是也和电影的主角一样，不想声，失语了……"></a>不知道当你看完《暴裂无声》，是不是也和电影的主角一样，不想声，失语了……</h6><p><img src="/assets/blogImg/1/1.jpg" alt="剧照1"><br>电影的剧情其实挺简单，《暴裂无声》的内容和片名一样，无声的暴力罢了。男主是哑者张保民，以拳头显示暴力，从头打到尾，只是这种近乎的暴力却只是最低能无力的；外表光鲜却身处灰色地带的徐律师，看似平静温文尔雅，沉默少言，他表现的暴力却最为阴冷可怕！当然还有强有力的施暴者姜武饰演的土豪金主昌老板，，他所表现出来的暴力是多元化，最全面的。记得电影里有一个场面：昌老板坐在一满桌切盘羊肉前吃着火锅，旁边机器在咔嚓咔嚓地切着羊肉，另一个矿主说自己信佛吃素，昌老板却淡然地讲到：“羊也是吃素的……”接着殴打，威胁，恐吓等等手段跃然而出，完胜！<br><img src="/assets/blogImg/1/2.jpg" alt="剧照2"><br>这三个男人唱出了一部完美诠释暴力，却控诉无声的悲剧！整部剧的精彩烧脑之处并不是通常悬疑剧的翻转结局，而是在好似不经意间表现出的一个个细节场景。所有细节场景的串联，才是这部烧脑片的精华所在。电影里的主角只是在引导着剧情的发展，而看懂细节，你才是真正的主角。不过，所有细节串联只有等到看完整部电影才会让你都明白过来。<br><img src="/assets/blogImg/1/3.jpg" alt="剧照3"></p><h4 id="细节一"><a href="#细节一" class="headerlink" title="细节一:"></a>细节一:</h4><p>张保民得知儿子失踪回家遇到村长，村长递给张保民抽的洋烟在后来昌老板的桌子上出现了。村长整车的往自己家运矿泉水。这两点说明了昌老板和村长之间的利益输送，村长明知道开矿污染了水源，却只顾自己的安危，贪图了昌老板的贿赂。</p><h4 id="细节二"><a href="#细节二" class="headerlink" title="细节二:"></a>细节二:</h4><p>昌老板非常喜欢射杀动物和吃羊肉，在最后要射杀张保民的打斗中又表现出了射击水平非常差，加上当手下打手为了威胁张保民交出律师女儿而谎称张保民的儿子在他手中，昌老板气急败坏之下的把手下打的奄奄一息，这些都表明了，徐律师帮昌老板做完伪证，昌老板给徐律师贿赂后心情大好，想要射杀小羊取乐享用，可是在远处放羊的张保民儿子不同意，保护着他心爱的小羊，昌老板依然射击了小羊，却误杀了张保民的儿子。</p><h4 id="细节三："><a href="#细节三：" class="headerlink" title="细节三："></a>细节三：</h4><p>昌老板的第一次露面，穿着一身干净的西装，站在校长室，一遍看着学生的照片，一遍吃着西红柿，吃相很难看，与他的穿着形成了鲜明的对比，这里解释一下为什么不吃苹果香蕉之类的而是吃西红柿，西红柿是红色的，象征着生命和鲜血，由于吃的太急，西红柿的汁流到了昌老板的衣服上，但昌老板用纸巾怎么擦也擦不掉，这也表达了做过坏事留下的痕迹是不容易抹去的。</p><h4 id="细节四"><a href="#细节四" class="headerlink" title="细节四:"></a>细节四:</h4><p>昌老板在练习弓箭的时候，弦已拉满，却又最终放弃了，虽然这时候导演并没有给出昌老板回忆的镜头，但不难看出，此时的昌老板内心世界是极其复杂的，他在收拾弓箭时，镜头中有一支箭是没有箭头的。箭头第一次出现是在张保民被绑在吉普车后备箱，张保民摸到了箭头并用它解开了脚上的绳子，还有是到结尾的时候，昌老板跟张保民发生冲突，昌老板快要包张保民勒断气的时候，张保民摸到昌老板口袋里的箭头，果断地把它刺进昌老板的大腿里，这才得以空隙出手反击。</p><p>这里要补充说明一下，昌老板一直向徐律师索要证据，而徐律师也一头雾水，徐律师其实是真不知道，因为昌老板杀人的证据一直被遗忘在他吉普车的后备箱里，就是那个箭头。这也解释了为什么昌老板会把那个箭头放在裤兜了，最后匆匆把它埋进土里。<br><img src="/assets/blogImg/1/4.jpg" alt="剧照4"></p><h4 id="细节五"><a href="#细节五" class="headerlink" title="细节五:"></a>细节五:</h4><p>张保民儿子的鬼魂出现在山洞里解开徐律师女儿的绳索和徐律师把女儿抱出山洞后，向着山洞深处的黑暗里偷偷看了一眼，表达了张磊的尸体就被埋在这个山洞深处，徐律师知道，却还是没有告诉张保民。这就和最后徐律师的一句：“没有。”相互辉映，揭示了人性的可怕。</p><h4 id="细节六"><a href="#细节六" class="headerlink" title="细节六:"></a>细节六:</h4><p>因为非法采矿，导致矿物污染，所有井水才会越来越难喝，村长才会 一车一车的运纯净水回家，张保民的妻子、栓子的母亲以及更多的村民才会得了怪病，失踪的张磊才会看见小鸟的尸体……</p><h4 id="细节七"><a href="#细节七" class="headerlink" title="细节七:"></a>细节七:</h4><p>酷爱吃羊肉的昌总为什么会掉那么多头发以导致前额发秃，因为他吃的也都是这个矿区的羊。</p><p>而这种“以彼之道还施彼身”巧妙且富有深意的设计，在电影中还有三处：</p><p>一是那枚要了人命、怎么也找不到的箭头，最终扎到了昌总自己身上！</p><p>二是律师跟着张保民来到藏护女儿的山洞，他开始恍惚、害怕，因为这个地方也藏着他的秘密！</p><p>三是羊肉店老板逼着张保民在拆迁补上签字，换来的不仅是自己瞎了一只眼，更是自己的儿子因为环境污染而精神失常。<br><img src="/assets/blogImg/1/5.jpg" alt="剧照5"></p><p>总结：虽然最后的结局是让人无言以对的可悲，各种暴力覆盖了一切！山的坍塌，张磊尸体的消失都揭露了黑暗的存在，但是剧中的细节已经表达过一个道理：恶有恶报！出来混总是要还的！</p><p>就让我们依靠着剧中曾经虚幻出的两个小孩纯真的站在山上俯瞰这个城市的场景，看出些许希望吧。</p><p><a href="https://baijiahao.baidu.com/s?id=1601128884575929109&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">转载自百家号：我爱烧脑之《暴裂无声》深度解析！这部悬疑电影你看懂了多少？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电影《暴裂无声》是由忻钰坤执导的犯罪悬疑片，姜武、宋洋、袁文康、谭卓等主演。暴裂无声剧情讲述了在北方凛冽的冬天，一个牧羊少年带着自家的羊群在山里行走，…&lt;/p&gt;
    
    </summary>
    
      <category term="影视" scheme="https://mlone.top/categories/%E5%BD%B1%E8%A7%86/"/>
    
    
      <category term="影视" scheme="https://mlone.top/tags/%E5%BD%B1%E8%A7%86/"/>
    
  </entry>
  
  <entry>
    <title>国内有哪些好的刷题网站</title>
    <link href="https://mlone.top/post/65ebe4d.html"/>
    <id>https://mlone.top/post/65ebe4d.html</id>
    <published>2018-09-10T01:31:10.000Z</published>
    <updated>2019-02-23T09:40:43.696Z</updated>
    
    <content type="html"><![CDATA[<p>来自：知乎<br>链接：<a href="https://www.zhihu.com/question/25574458" target="_blank" rel="noopener">https://www.zhihu.com/question/25574458</a></p><a id="more"></a><h3 id="1、Leetcode"><a href="#1、Leetcode" class="headerlink" title="1、Leetcode"></a>1、Leetcode</h3><p>鼎鼎大名的Leetcode，据不完全统计在上面被刷过的题可以围绕地球三圈。（没说赤道哈，就是这么严谨。）总之，很多国内外的码农在上面刷题。难度从easy到hard都有，而且覆盖面极广。现在还增加了数据库和shell，相匹配的论坛也可以多看看。很锻炼和国外码农沟通的能力，对于以后去混Github也有好处。</p><p>特点：各种语言支持很广泛，题型覆盖很广，测试数据集较弱。</p><h3 id="2、Codility"><a href="#2、Codility" class="headerlink" title="2、Codility"></a>2、Codility</h3><p>同样一家著名的国外刷题网站。和Leetcode不同，它是专门帮各大软件公司笔试用的，只是副业提供了一些面试题和挑战。但即使是训练模式都非常经典，很值得一做。而且测试数据集提供的非常完善，总能让你有想不到的边界情况。Take our free programming lessons</p><p>特点：很接近面试题的风格，训练模式也基本够用。</p><h3 id="3、Lintcode"><a href="#3、Lintcode" class="headerlink" title="3、Lintcode"></a>3、Lintcode</h3><p>可以称作中文版本的Leetcode，个人感觉最高难度比Leetcode高一些。这两个类似的网站，可以配套来刷。每个刷一遍，也能保持新鲜感。</p><p>特点：中文支持很好，和Leetcode有一部分题类似，可以和九章算法课程配合使用。</p><h3 id="4、Hihocoder"><a href="#4、Hihocoder" class="headerlink" title="4、Hihocoder"></a>4、Hihocoder</h3><p>来自于原北京大学POJ开发团队，网站一直在进步。最早是微软的在线笔试网站，现在网易也使用它进行在线笔试。题目侧重于较难题目，风格很像ACM比赛，要自己注意数据集的输入输出。</p><p>特点：每周一道算法题极难又有趣，可以用来扩展面试题思路。而且是网易、微软的在线笔试网站，有机会需要多练习。</p><h3 id="5、CC150"><a href="#5、CC150" class="headerlink" title="5、CC150"></a>5、CC150</h3><p>这不是网站，这是一本书。全称Cracking the coding interview，是国外找工作的神书，而且的确写的很好。里面除了算法题，还有计算机基础知识等内容，很不错。适合想去外企的人仔细阅读，而且最新版已经比150题多了。总之，外企必备！</p><p>特点：外企必备！外企必备！外企必备！想去外企的人，多看看书的配套答案也是好的</p><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>最后，经过公众号作者小分队的讨论，根据不同方向的工作，我们建议按照以下方式刷题：</p><p>国企、银行、科研单位<br>Leetcode简单、中等难度最好刷一遍，有时间再过一遍思路。</p><p>创业公司<br>Leetcode全部难度上机刷一遍，然后把不会的题纸上在重新写一下。<br>国内互联网</p><p>Leetcode全部难度上机刷一遍，纸上再写一遍。同时尽量涉及难度较高的平台（Codility），或者多去几家公司面试，以赛代练。</p><p>国内外企<br>Leetcode至少全难度刷一遍，CC150纸上写一遍。想提高Microsoft/Google等在线笔试通过率的，多去玩玩Hihocoder等在线笔试平台。</p><p>外企总部<br>Leetcode困难程度烂熟于心，尽量达到ACM入门标准，甚至稍高一点比较有把握。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来自：知乎&lt;br&gt;链接：&lt;a href=&quot;https://www.zhihu.com/question/25574458&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.zhihu.com/question/25574458&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="https://mlone.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>图片收藏</title>
    <link href="https://mlone.top/post/fda4c161.html"/>
    <id>https://mlone.top/post/fda4c161.html</id>
    <published>2018-09-01T00:30:20.000Z</published>
    <updated>2019-02-23T12:56:48.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="发现"><a href="#发现" class="headerlink" title="发现"></a>发现</h2><p>好多美女啊！！！</p><a id="more"></a><h3 id="美女1"><a href="#美女1" class="headerlink" title="美女1"></a>美女1</h3><blockquote><p>这里的图片链接不能写相对路径：./assets/blogImg/美女1.jpg<br>如果这样写的话，文章不展开时的图片是可以显示的，但当文章展开时，<br>所有的图片都无法找到路径了。(可见展开和不展开的页面代码文件并不在同一目录下)</p></blockquote><p><img src="/assets/blogImg/0/美女1.jpg" alt="美女1"></p><h3 id="美女2"><a href="#美女2" class="headerlink" title="美女2"></a>美女2</h3><p><img src="/assets/blogImg/0/美女2.jpg" alt="美女2"></p><h3 id="动图1"><a href="#动图1" class="headerlink" title="动图1"></a>动图1</h3><p><img src="/assets/blogImg/0/动图1.gif" alt="动图1"></p><h3 id="动图2"><a href="#动图2" class="headerlink" title="动图2"></a>动图2</h3><p><img src="/assets/blogImg/0/动图2.gif" alt="动图2"></p><h3 id="动图3"><a href="#动图3" class="headerlink" title="动图3"></a>动图3</h3><p><img src="/assets/blogImg/0/动图3.gif" alt="动图3"></p><h3 id="动图4"><a href="#动图4" class="headerlink" title="动图4"></a>动图4</h3><p><img src="/assets/blogImg/0/动图4.gif" alt="动图4"></p><h3 id="风景1"><a href="#风景1" class="headerlink" title="风景1"></a>风景1</h3><p><img src="/assets/blogImg/0/风景1.jpg" alt="风景1"></p><h3 id="风景2"><a href="#风景2" class="headerlink" title="风景2"></a>风景2</h3><p><img src="/assets/blogImg/0/风景2.jpg" alt="风景2"></p><h3 id="佩奇"><a href="#佩奇" class="headerlink" title="佩奇"></a>佩奇</h3><p><img src="/assets/blogImg/0/佩奇.jpeg" alt="佩奇"></p><h3 id="狗子"><a href="#狗子" class="headerlink" title="狗子"></a>狗子</h3><p><img src="/assets/blogImg/0/狗子.jpg" alt="狗子"></p>]]></content>
    
    <summary type="html">
    
      美女图片、动图、佩奇、狗子、风景
    
    </summary>
    
      <category term="随笔" scheme="https://mlone.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="图片" scheme="https://mlone.top/tags/%E5%9B%BE%E7%89%87/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Pages</title>
    <link href="https://mlone.top/post/5641fb4c.html"/>
    <id>https://mlone.top/post/5641fb4c.html</id>
    <published>2018-08-31T23:15:00.000Z</published>
    <updated>2019-02-23T09:42:10.030Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：<br><a id="more"></a></p><ol><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</li><li>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>等等；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;使用github pages服务搭建博客的好处有：&lt;br&gt;
    
    </summary>
    
      <category term="默认分类" scheme="https://mlone.top/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="随笔" scheme="https://mlone.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
