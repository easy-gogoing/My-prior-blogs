<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java中的finalize方法[转载]]]></title>
    <url>%2Fpost%2Fb52b9753.html</url>
    <content type="text"><![CDATA[[转载自：Java中的finalize()方法] Java中假定finalize的工作原理为：一旦垃圾回收器准备回收内存而释放对象所占内存的时候，会先调用该对象的finalize方法，然后在下一次再需要垃圾回收的时候才真正的回收对象！finalize()的作用：finalize用于在GC发生前事先调用去回收JNI调用中申请的特殊内存，下次GC发生时候保证GC后所有该对象的内存都释放了。 垃圾回收 Java的垃圾回收器只会释放由我们new出来的内存堆块，那些不是由new出来的“特殊内存”，垃圾回收器是不会管理的。 所谓的特殊内存指通过JNI用C/C++向系统申请的内存，这些内存如果不手动去清除就会一直占据在内存中。 而且，垃圾回收本身就有开销，所以虚拟机不会经常GC，只有当内存快要耗尽的时候JVM才会触发GC。 finalize()-由上，Java中的对象并不一定会被全部垃圾回收，当你不想要该对象的时候，你需要手动去处理那些“特殊内存”，java中没有析构，所以提供了一个finalize()方法让我们来执行清理工作。-当系统进行GC的时候会先调用finalize方法，然后再下次才会回收对象的内存。因为native中申请的内存，GC没有办法回收所以finalize被用来做垃圾回前的重要清理工作：释放特殊内存。 -所以finalize一般使用在使用了JNI的情景下，需要在finalize中调用native方法释放特殊内存，一般情况下不要使用finalize！-如果GC不发生那么finalize也不会发生，finalize是Object的protect方法，不可以在类族外访问。 不是析构函数 Java因为有GC机制，所以没有析构函数的概念！ finalize不是C++中的析构函数：析构函数肯定是会销毁该对象的，但是finalize因为gc机制不会经常发生，所以其被执行的是不确定的。（不知道是不是我没理解透，没觉得这两个有什么可比性，一个主动发生一个被动发生） 其他 调用System.gc()，可以强制让gc发生来触发finalize方法！但是GC也只是GC垃圾的对象（没有被引用的），非垃圾的对象的finalize不会被调用。程序终止和GC不是一个概念。 正常情况下你调用finalize(）都是直接super.finalize()使用父类的就行了。 finalize一般不用！被执行的不确定性太大。不要指望使用finalize来回收你的对象，它只会在系统进行GC的时候清理特殊内存，不受你的控制！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中HashMap的实现原理]]></title>
    <url>%2Fpost%2F1ed5a07.html</url>
    <content type="text"><![CDATA[转载自：https://www.cnblogs.com/yuanblog/p/4441017.html 一、Java中的hashCode和equals1、关于hashCode 1.hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的 2.如果两个对象相同，就是适用于equals(java.lang.Object) 方法，那么这两个对象的hashCode一定要相同 3.如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点 4.两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里” 再归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的。 以下对hashCode的解读摘自其他博客： 1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有 例如内存中有这样的位置 0 1 2 3 4 5 6 7 而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。 但如果用hashcode那就会使效率提高很多。 我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。 2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。 也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。 那么，重写了equals()，为什么还要重写hashCode()呢？ 想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊 2、关于equals1.equals和====用于比较引用和比较基本数据类型时具有不同的功能：比较基本数据类型，如果两个值相同，则结果为true而在比较引用时，如果引用指向内存中的同一对象，结果为true; equals()作为方法，实现对象的比较。由于==运算符不允许我们进行覆盖，也就是说它限制了我们的表达。因此我们复写equals()方法，达到比较对象内容是否相同的目的。而这些通过==运算符是做不到的。 2.object类的equals()方法的比较规则为：如果两个对象的类型一致，并且内容一致，则返回true,这些类有： java.io.file,java.util.Date,java.lang.string,包装类（Integer,Double等） String s1=new String(&quot;abc&quot;); String s2=new String(&quot;abc&quot;); System.out.println(s1==s2); System.out.println(s1.equals(s2)); 运行结果为false true 二、HashMap的实现原理1.HashMap概述 HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 在java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。 从上图中可以看出，HashMap底层就是一个数组结构，数组中的每一项又是一个链表。当新建一个HashMap的时候，就会初始化一个数组。 其中Java源码如下： /** * The table, resized as necessary. Length MUST Always be a power of two. */ transient Entry[] table; static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final K key; V value; Entry&lt;K,V&gt; next; final int hash; …… } 可以看出，Entry就是数组中的元素，每个 Map.Entry 其实就是一个key-value对，它持有一个指向下一个元素的引用，这就构成了链表。 2.HashMap实现存储和读取1）存储public V put(K key, V value) { // HashMap允许存放null键和null值。 // 当key为null时，调用putForNullKey方法，将value放置在数组第一个位置。 if (key == null) return putForNullKey(value); // 根据key的keyCode重新计算hash值。 int hash = hash(key.hashCode()); // 搜索指定hash值在对应table中的索引。 int i = indexFor(hash, table.length); // 如果 i 索引处的 Entry 不为 null，通过循环不断遍历 e 元素的下一个元素。 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) { // 如果发现已有该键值，则存储新的值，并返回原始值 V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } // 如果i索引处的Entry为null，表明此处还没有Entry。 modCount++; // 将key、value添加到i索引处。 addEntry(hash, key, value, i); return null; } 根据hash值得到这个元素在数组中的位置（即下标），如果数组该位置上已经存放有其他元素了，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。如果数组该位置上没有元素，就直接将该元素放到此数组中的该位置上。 hash(int h)方法根据key的hashCode重新计算一次散列。此算法加入了高位计算，防止低位不变，高位变化时，造成的hash冲突。 1 static int hash(int h) { 2 h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); 3 return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); 4 } 我们可以看到在HashMap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表，这样就大大优化了查询的效率。 根据上面 put 方法的源代码可以看出，当程序试图将一个key-value对放入HashMap中时，程序首先根据该 key的 hashCode() 返回值决定该 Entry 的存储位置：如果两个 Entry 的 key 的 hashCode() 返回值相同，那它们的存储位置相同。如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry的 value，但key不会覆盖。如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加的 Entry 位于 Entry 链的头部——具体说明继续看 addEntry() 方法的说明。 通过这种方式就可以高效的解决HashMap的冲突问题。 2）读取public V get(Object key) { if (key == null) return getForNullKey(); int hash = hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) { Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; } return null; } 从HashMap中get元素时，首先计算key的hashCode，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。 3）归纳起来简单地说:HashMap 在底层将 key-value 当成一个整体进行处理，这个整体就是一个 Entry 对象。HashMap 底层采用一个 Entry[] 数组来保存所有的 key-value 对，当需要存储一个 Entry 对象时，会根据hash算法来决定其在数组中的存储位置，在根据equals方法决定其在该数组位置上的链表中的存储位置；当需要取出一个Entry时，也会根据hash算法找到其在数组中的存储位置，再根据equals方法从该位置上的链表中取出该Entry。 3.HashMap的resize当hashmap中的元素越来越多的时候，碰撞的几率也就越来越高（因为数组的长度是固定的），所以为了提高查询的效率，就要对hashmap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，所以这是一个通用的操作，很多人对它的性能表示过怀疑，不过想想我们的“均摊”原理，就释然了，而在hashmap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。 那么hashmap什么时候进行扩容呢？当hashmap中的元素个数超过数组大小loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，也就是说，默认情况下，数组大小为16，那么当hashmap中元素个数超过160.75=12的时候，就把数组的大小扩展为216=32，即扩大一倍，然后重新计算每个元素在数组中的位置，而这是一个非常消耗性能的操作，所以如果我们已经预知hashmap中元素的个数，那么预设元素的个数能够有效的提高hashmap的性能。比如说，我们有1000个元素new HashMap(1000), 但是理论上来讲new HashMap(1024)更合适，不过上面annegu已经说过，即使是1000，hashmap也自动会将其设置为1024。 但是new HashMap(1024)还不是更合适的，因为0.751000 &lt; 1000, 也就是说为了让0.75 * size &gt; 1000, 我们必须这样new HashMap(2048)才最合适，既考虑了&amp;的问题，也避免了resize的问题。 总结：HashMap的实现原理： 1.利用key的hashCode重新hash计算出当前对象的元素在数组中的下标。 2.存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中。 3.获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。 4.理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Array and Collection Framework]]></title>
    <url>%2Fpost%2F5495d47.html</url>
    <content type="text"><![CDATA[转载自：https://blog.csdn.net/ada_dengpan/article/details/51200907 Array数组* （1）Array数组 * * 和C/C++以及其他语言一样，Java中的数组有差不多一样的语法 * 只是Java中除了8种基本类型，数组也是作为对象处理的，所以创建对象时也需要使用new关键字 * 和大多数编程语言一样，数组一旦创建，大小便不可改变 * Java中有一个Arrays封装类，专门用来操作基本数组 * Arrays中拥有一组static函数： * --equals():比较两个array是否相等。array拥有相同元素个数，且所有对应元素两两相等 * --fill():将指定的数据类型填入array数组中 * --sort():用来对array数组进行排序 * --binarySearch():在排好的array数组中寻找元素 * --System.arraycopy():array数组的复制 * * int [] intArr = new int[10]; * Collection集合框架概述* （2）Array是Java中随机访问一连串对象最有效率的数据结构，但很不灵活，大小固定，且不知道里面有多少元素 * 为此JDK（）已经为我们提供了一系列的类来实现功能强大且更灵活的基本数据结构，这些类均在java.util包中。 * 其继承结构如下： * --Collection（集合） * * --List（列表） * --LinkedList（链表：链式存储） * --ArrayList（线性表：顺序存储） * --Vector（矢量）（已淘汰） * --Stack（栈） * * --Set（集合） * --HashSet * --LinkedHashSet * * --TreeSet（实现了SortedSet接口） * * * --Queue（队列） * * --Map（图） * --HashTable（哈希表：散列表）（已淘汰） * --HashMap（哈希图；散列表） * --LinkedHashMap * --TreeMap * --WeakHashMap * List* （2.1）List * * List是一个接口，不能实例化，若要实例化要通过创建ArrayList或LinkedList * * （2.1.1）ArrayList里面的内部类实现，是通过一定的增长规则动态复制增加数组长度来实现动态增加元素的， * 如果在大量数据的情况下，在某一位置随机插入或删除元素，就会产生性能问题。 * * （2.1.2）LinkedList可以解决这类问题，但LinkedList在通过下标取元素的时候，一定要遍历整个链表节点匹配， * 在数据量大的情况下，效率不高。 * * （2.1.3）Vector是一种过时的动态数组，是线程同步的，效率很低，一般不赞成使用： * * Stack是Java实现了一个堆栈，先进后出（FILO）结构。 * * Set* * （2.2）Set * Set接口继承Collection接口，最大的特点是集合中的元素都是唯一的，没有重复元素。 * 它有两个类：HashSet和TreeSet * * （2.2.1）--HashSet * --不允许出现重复元素； * --不保证集合中元素的顺序都是哈希算法来的~ * --允许包含值为null的元素，但最多只能有一个null元素。 * * （2.2.2）--TreeSet * --不允许出现重复元素； * --集合中元素的顺序按某种规则进行排序； * --不允许包含值为null的元素 * * （2.2.3）遍历时删除问题 * 1、//使用迭代器遍历Set集合. * Iterator&lt;String&gt; it = set.iterator(); * while(it.hasNext()){ * String temp = it.next(); * System.out.println(&quot;元素：&quot;+ temp); * it.remove(); * } * 2、//使用增强for循环解决 （底层实现还是迭代器） * for(String item : set){ * System.out.println(&quot;元素：&quot;+ item); * } * * 使用增强for循环遍历List（所有实现子类ArrayList，Stack等）元素对其中元素进行删除， * 会抛出java.util.ConcurrentModificationException的异常�?? * 若使用下面这种方式： * for(int i= 0; i &lt; list.size(); i++){ * list.remove(i); * } * 则会删除下标为偶数的元素，因为每次删除后，后面的元素的下标全部减1,相当于元素位置全部左移一位， * 再次删除时，会跳过一个元素进行删除，这是非常不好的。 * 如果非要这样删除，可以倒着来： * for(int i = list.size()-1; i &gt;= 0; i--){ * list.remove(i); * } * 或者新建一个要删除的List，最后一起删除list.removeAll(deleteList); * * Map* * （2.3）Map * Map接口，没有继承Collection接口，它是一个独立的接口。使用key-value的键值对存储数据， * 常用的两个子类是HashMap和TreeMap。 * * （2.3.1）--HashMap：Map基于散列表的实现。插入和查询“键值对”的位置是固定的， * 可以通过构造器设置容量capacity和负载因子loadfactor，以调整容器的装载能力。 * * （2.3.2）--LinkedHashMap：类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序 * 或者是最近最少使用（LRU）的次序。只比HashMap慢一点， * 而在迭代访问时反而更快，因为它使用链表维护内部次序。 * * （2.3.3）--TreeMap：基于红黑树数据结构的实现的，查看“键”或“键值对”时，它们会被排序（次序由Comparabel或Comparator决定） * TreeMap的特点在于，你得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以返回一个子树。 * * （2.3.4）--WeakHashMap：弱键（weak key）Map，Map中使用的对象也被允许释放：这是为解决特殊问题设计的。 * 如果没有map之外的引用指向某个“键”，则此“键”可以被垃圾收集器回收。 * * （2.3.5）--IdentifyHashMap:使用==代替equals()对“键”作比较 hash map。专为解决特殊问题而设计的。 * 线程安全* （3）线程安全 * * Vector是线程同步的，也就是线程安全的，对多线程的操作采用了synchronized处理。但因为效率低已不建议使用， * 而ArrayList和LinkedList虽然是线程异步的、效率高，但都是线程不安全的，在多线程环境中，对数据的修改会造成错误的结果。 * * 有两种解决方案： * （3.1）使用同步包装器 * * List safedList = Collections.synchronizedList(new ArrayList()); * Set safedSet = Collections.synchronizedSet(new HashSet); * Map safedMap = Collections.synchronizedSet(new HashSet); * * 查看其源码，发现是Collections类给不安全的集合类包装了一层（即虚拟机自动给集合实现加锁接口），然后生成一个新的类 * 新类里面采用了synchronized对集合的操作进行了同步处理 * public int size(){ synchronized(mutex){return c.size();} } public boolean isEmpty(){ synchronized(mutex){return c.isEmpty();} } public boolean contains(Object o){ synchronized(mutex){return c.contains(o);} } public Object[] toArray(){ synchronized(mutex){return c.toArray();} } public &lt;T&gt; T[] toArray(T[] a){ synchronized(mutex){return c.toArray(a);} } public Iterator&lt;E&gt; iterator(){ return c.iterator(); //Must be manually synched by uers! //必须由用户手动同步 } public boolean add(E e){ synchronized(mutex){return c.add(e);} } public boolean remove(Object o){ synchronized(mutex){return c.remove(o);} } public boolean containsAll(Collection&lt;?&gt; coll){ synchronized(mutex){return c.containsAll(coll);} } public boolean addAll(Collection&lt;? extends E&gt; coll){ synchronized(mutex){return c.addAll(coll);} } public boolean removeAll(Collection&lt;?&gt; coll){ synchronized(mutex){return c.removeAll(coll);} } public boolean retainAll(Collection&lt;?&gt; coll){ synchronized(mutex){return c.retainAll(coll);} } public void clear(){ synchronized(mutex){c.clear();} } * * * * * （3.2）使用安全的集合： * Java5.0新加入的ConcurrentLinkedQueue、ConcurrentHashMap * CopyOnWriteArrayList和CopyOnWriteArraySet,这些集合类都是线程安全的。 * 都在java.util.concurrent包下。而至于这些新的类为什么能保证线程安全，这里不作详述。 * * PS:concurrent * adj.〈正式的;同时发生的;同时完成的;同时存在的。 * n.[数] 共点;同时发生的事情 */]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java RMI详解]]></title>
    <url>%2Fpost%2Fd2873939.html</url>
    <content type="text"><![CDATA[转载自：https://blog.csdn.net/a19881029/article/details/9465663 RMI:远程方法调用(Remote Method Invocation)：能够让在某个java虚拟机上的对象像调用本地对象一样调用另一个java 虚拟机中的对象上的方法。 RMI远程调用步骤： 1，客户对象调用客户端辅助对象上的方法 2，客户端辅助对象打包调用信息（变量，方法名），通过网络发送给服务端辅助对象 3，服务端辅助对象将客户端辅助对象发送来的信息解包，找出真正被调用的方法以及该方法所在对象 4，调用真正服务对象上的真正方法，并将结果返回给服务端辅助对象 5，服务端辅助对象将结果打包，发送给客户端辅助对象 6，客户端辅助对象将返回值解包，返回给客户对象 7，客户对象获得返回值 对于客户对象来说，步骤2-6是完全透明的 搭建一个RMI服务的过程分为以下7步; 1，创建远程方法接口，该接口必须继承自Remote接口Remote 接口是一个标识接口，用于标识所包含的方法可以从非本地虚拟机上调用的接口，Remote接口本身不包含任何方法 package server; import java.rmi.Remote; import java.rmi.RemoteException; public interface Hello extends Remote { public String sayHello(String name) throws RemoteException; } 由于远程方法调用的本质依然是网络通信，只不过隐藏了底层实现，网络通信是经常会出现异常的，所以接口的所有方法都必须抛出RemoteException以说明该方法是有风险的 2，创建远程方法接口实现类：UnicastRemoteObject类的构造函数抛出了RemoteException，故其继承类不能使用默认构造函数，继承类的构造函数必须也抛出RemoteException 由于方法参数与返回值最终都将在网络上传输，故必须是可序列化的 package server; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; public class HelloImpl extends UnicastRemoteObject implements Hello { private static final long serialVersionUID = -271947229644133464L; public HelloImpl() throws RemoteException{ super(); } public String sayHello(String name) throws RemoteException { return &quot;Hello,&quot;+name; } } 3，利用java自带rmic工具生成sutb存根类(jdk1.5.0_15/bin/rmic)jdk1.2以后的RMI可以通过反射API可以直接将请求发送给真实类，所以不需要skeleton类了 sutb存根为远程方法类在本地的代理，是在服务端代码的基础上生成的，需要HelloImpl.class文件，由于HelloImpl继承了Hello接口，故Hello.class文件也是不可少的 Test – server —- Hello.class —- HelloImpl.class 方式一： [name@name Test]$ cd /home/name/Test/ [name@name Test]$ rmic server.HelloImpl 方式二： [name@name Test]$ rmic -classpath /home/name/Test server.HelloImpl 运行成功后将会生成HelloImpl_Stub.class文件 4，启动RMI注册服务(jdk1.5.0_15/bin/rmiregistry)方式一：后台启动rmiregistry服务 [name@name jdk]$ jdk1.5.0_15/bin/rmiregistry 12312 &amp; [1] 22720 [name@name jdk]$ ps -ef|grep rmiregistry name 22720 13763 0 16:43 pts/3 00:00:00 jdk1.5.0_15/bin/rmiregistry 12312 name 22737 13763 0 16:43 pts/3 00:00:00 grep rmiregistry 如果不带具体端口号，则默认为1099 方式二：人工创建rmiregistry服务，需要在代码中添加： LocateRegistry.createRegistry(12312); 5，编写服务端代码package server; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class HelloServer { public static void main(String[] args) { try{ Hello h = new HelloImpl(); //创建并导出接受指定port请求的本地主机上的Registry实例。 //LocateRegistry.createRegistry(12312); /** Naming 类提供在对象注册表中存储和获得远程对远程对象引用的方法 * Naming 类的每个方法都可将某个名称作为其一个参数， * 该名称是使用以下形式的 URL 格式（没有 scheme 组件）的 java.lang.String: * //host:port/name * host：注册表所在的主机（远程或本地)，省略则默认为本地主机 * port：是注册表接受调用的端口号，省略则默认为1099，RMI注册表registry使用的著名端口 * name：是未经注册表解释的简单字符串 */ //Naming.bind(&quot;//host:port/name&quot;, h); Naming.bind(&quot;rmi://192.168.58.164:12312/Hello&quot;, h); System.out.println(&quot;HelloServer启动成功&quot;); }catch(Exception e){ e.printStackTrace(); } } } 先创建注册表，然后才能在注册表中存储远程对象信息 6，运行服务端（58.164）：Test – server —- Hello.class —- HelloImpl.class —- HelloServer.class [name@name ~]$ java server.HelloServer HelloServer 启动成功 当然/home/name/Test一定要在系统CLASSPATH中，否则会报找不到相应的.class文件 7，编写客户端代码package client; import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; import server.Hello; public class HelloClient { public static void main(String[] args) { try { Hello h = (Hello)Naming.lookup(&quot;rmi://192.168.58.164:12312/Hello&quot;); System.out.println(h.sayHello(&quot;zx&quot;)); } catch (MalformedURLException e) { System.out.println(&quot;url格式异常&quot;); } catch (RemoteException e) { System.out.println(&quot;创建对象异常&quot;); e.printStackTrace(); } catch (NotBoundException e) { System.out.println(&quot;对象未绑定&quot;); } } } 8，运行客户端（58.163）：Test – client —- HelloClient.class – server —- Hello.class —- HelloImpl_Stub.class//服务端生成的存根文件 [name@name client]$ java client.HelloClient Hello,zx 同服务器端，/home/name/Test一定要在系统CLASSPATH中 PS： 1，客户端所在服务和服务端所在的服务器网络一定要通（一开始浪费了很多时间，最后才发现是网络不通） 2，所有代码在jdk1.5.0_15，Linux服务器上调试通过 3，如果java命令运行提示找不到类文件，则为CLASSPATH配置问题 [name@name ~]$ vi .bash_profile JAVA_HOME=/home/name/jdk/jdk1.5.0_15 export JAVA_HOME PATH=$JAVA_HOME/bin:$PATH export PATH CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:/home/name/Test export CLASSPATH JAVA_HOME为jdk的根目录 PATH为java工具类路径(java，javac，rmic等) CLASSPATH为java .class文件的存放路径，使用java命令运行.class文件时即会在该参数配置的路径下寻找相应文件 java RMI的缺点：1，从代码中也可以看到，代码依赖于ip与端口 2，RMI依赖于Java远程消息交换协议JRMP（Java Remote Messaging Protocol），该协议为java定制，要求服务端与客户端都为java编写]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>RMI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java序列化(Serializable)的作用和反序列化]]></title>
    <url>%2Fpost%2F693bdb7c.html</url>
    <content type="text"><![CDATA[转载自：https://www.cnblogs.com/zero0/articles/1874841.html 这里转载一篇讲解java序列化(Serializable)和反序列化方面的感觉很好的文章。 1、序列化是干什么的？简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。 2、什么情况下需要序列化a）当你想把的内存中的对象状态保存到一个文件中或者数据库中时候； b）当你想用套接字在网络上传送对象的时候； c）当你想通过RMI传输对象的时候； 6、相关注意事项a）序列化时，只对对象的状态进行保存，而不管对象的方法； b）当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； c）当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； d）并非所有的对象都可以序列化。 至于为什么不可以，有很多原因了,比如： 1.安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行rmi传输 等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的。 2.资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现。 详细描述:序列化的过程就是对象写入字节流和从字节流中读取对象。将对象状态转换成字节流之后，可以用java.io包中的各种字节流类将其保存到文件中，管道到另一 线程中或通过网络连接将对象数据发送到另一主机。对象序列化功能非常简单、强大，在RMI、Socket、JMS、EJB都有应用。对象序列化问题在网络 编程中并不是最激动人心的课题，但却相当重要，具有许多实用意义。 一：对象序列化可以实现分布式对象。主要应用例如：RMI要利用对象序列化运行远程主机上的服务，就像在本地机上运行对象时一样。 二：java 对象序列化不仅保留一个对象的数据，而且递归保存对象引用的每个对象的数据。可以将整个对象层次写入字节流中，可以保存在文件中或在网络连接上传递。利用 对象序列化可以进行对象的“深复制”，即复制对象本身及引用的对象本身。序列化一个对象可能得到整个对象序列。 从上面的叙述中，我们知道了对象序列化是java编程中的必备武器，那么让我们从基础开始，好好学习一下它的机制和用法。 java序列化比较简单，通常不需要编写保存和恢复对象状态的定制代码。实现java.io.Serializable接口的类对象可以转换成字 节流或从 字节流恢复，不需要在类中增加任何代码。只有极少数情况下才需要定制代码保存或恢复对象状态。这里要注意：不是每个类都可序列化，有些类是不能序列化的， 例如涉及线程的类与特定JVM有非常复杂的关系。 序列化机制：序列化分为两大部分：序列化和反序列化。序列化是这 个过程的第一部分，将数据分解成字节流，以便存储在文件中或在网络上传输。反序列化就是打开字节流并重构对象。 对象序列化不仅要将基本数据类型转换成字节 表示，有时还要恢复数据。恢复数据要求有恢复数据的对象实例。ObjectOutputStream中的序列化过程与字节流连接，包括对象类型和版本信 息。 反序列化时，JVM用头信息生成对象实例，然后将对象字节流中的数据复制到对象数据成员中。下面我们分两大部分来阐述： 处理对象流：（序列化过程和反序列化过程） java.io包有两个序列化对象的类。ObjectOutputStream负责将对象写入字节流，ObjectInputStream从字节流重构对象。 我们先了解ObjectOutputStream类吧。ObjectOutputStream类扩展DataOutput接口。writeObject() 方法是最重要的方法，用于对象序列化。如果对象包含其他对象的引用，则writeObject()方法递归序列化这些对象。每个 ObjectOutputStream维护序列化的对象引用表，防止发送同一对象的多个拷贝。（这点很重要）由于writeObject()可以序列化整 组交叉引用的对象，因此同一ObjectOutputStream实例可能不小心被请求序列化同一对象。这时，进行反引用序列化，而不是再次写入对象字节 流。下面，让我们从例子中来了解ObjectOutputStream这个类吧。 // 序列化 today’s date 到一个文件中. FileOutputStream f = new FileOutputStream(“tmp”); //创建一个包含恢复对象(即对象进行反序列化信息)的”tmp”数据文件 ObjectOutputStream s = new ObjectOutputStream(f); s.writeObject(“Today”); //写入字符串对象; s.writeObject(new Date()); //写入瞬态对象; s.flush(); 现在，让我们来了解ObjectInputStream这个类。它与ObjectOutputStream相似。它扩展DataInput接口。 ObjectInputStream中的方法镜像DataInputStream中读取Java基本数据类型的公开方法。readObject()方法从 字节流中反序列化对象。每次调用readObject()方法都返回流中下一个Object。对象字节流并不传输类的字节码，而是包括类名及其签名。 readObject()收到对象时，JVM装入头中指定的类。如果找不到这个类，则readObject()抛出 ClassNotFoundException,如果需要传输对象数据和字节码，则可以用RMI框架。ObjectInputStream的其余方法用于 定制反序列化过程。例子如下： //从文件中反序列化 string 对象和 date 对象 FileInputStream in = new FileInputStream(“tmp”); ObjectInputStream s = new ObjectInputStream(in); String today = (String)s.readObject(); //恢复对象; Date date = (Date)s.readObject(); 定制序列化过程:序列化通常可以自动完成，但有时可能要对这个过程进行控制。java可以将类声明为serializable，但仍可手工控制声明为static或transient的数据成员。 例子：一个非常简单的序列化类。 public class simpleSerializableClass implements Serializable{ String sToday=”Today:”; transient Date dtToday=new Date(); } 序列化时，类的所有数据成员应可序列化除了声明为transient或static的成员。将变量声明为transient告诉JVM我们会负责将变元序列 化。将数据成员声明为transient后，序列化过程就无法将其加进对象字节流中，没有从transient数据成员发送的数据。后面数据反序列化时， 要重建数据成员（因为它是类定义的一部分），但不包含任何数据，因为这个数据成员不向流中写入任何数据。记住，对象流不序列化static或 transient。我们的类要用writeObject()与readObject()方法以处理这些数据成员。使用writeObject()与 readObject()方法时，还要注意按写入的顺序读取这些数据成员。 关于如何使用定制序列化的部分代码如下： //重写writeObject()方法以便处理transient的成员。 public void writeObject(ObjectOutputStream outputStream) throws IOException{ outputStream.defaultWriteObject(); //使定制的writeObject()方法可以利用自动序列化中内置的逻辑。 outputStream.writeObject(oSocket.getInetAddress()); outputStream.writeInt(oSocket.getPort()); } //重写readObject()方法以便接收transient的成员。 private void readObject(ObjectInputStream inputStream) throws IOException,ClassNotFoundException{ inputStream.defaultReadObject(); //defaultReadObject()补充自动序列化 InetAddress oAddress=(InetAddress)inputStream.readObject(); int iPort =inputStream.readInt(); oSocket = new Socket(oAddress,iPort); iID=getID(); dtToday =new Date(); } 完全定制序列化过程:如果一个类要完全负责自己的序列化，则实现Externalizable接口而不是Serializable接口。Externalizable接口定义包 括两个方法writeExternal()与readExternal()。利用这些方法可以控制对象数据成员如何写入字节流.类实现 Externalizable时，头写入对象流中，然后类完全负责序列化和恢复数据成员，除了头以外，根本没有自动序列化。这里要注意了。声明类实现 Externalizable接口会有重大的安全风险。writeExternal()与readExternal()方法声明为public，恶意类可 以用这些方法读取和写入对象数据。如果对象包含敏感信息，则要格外小心。这包括使用安全套接或加密整个字节流。 到此为至，我们学习了序列化的基础部分知识。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[早绑定与晚绑定]]></title>
    <url>%2Fpost%2F72dff8df.html</url>
    <content type="text"><![CDATA[静态绑定（早绑定）：程序在编译阶段根据参数个数确定调用哪个函数（重载）。动态绑定（晚绑定）：以封装和继承为基础，将成员函数和析构函数声明为虚函数（virtual）。构造函数不能声明为virtual： Shape *shape1 = new Circle(3.5, 4.0); shape -&gt; calcArea(); //父类指针调用子类面积函数delete Shape1；//先调用子类析构函数，再调用父类析构函数 shape1 = NULL; return 0; C++: virtual double cost()=0; //纯虚函数 纯虚函数在类内声明，在类内或类外定义函数，而纯虚函数无函数体。含有纯虚函数的类称为抽象类；只含有纯虚函数的类称为接口类（没有任何数据成员）。 Java: 通过”abstract”关键字实现多态。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[匿名内部类访问方法成员变量需要加final的原因及证明]]></title>
    <url>%2Fpost%2Fbe65bf03.html</url>
    <content type="text"><![CDATA[转载自：https://blog.csdn.net/wjw521wjw521/article/details/77333820 在java编程中，没用的类定义太多对系统来说也是一个负担，这时候我们可以通过定义匿名内部类来简化编程，但匿名内部类访问外部方法的成员变量时都要求外部成员变量添加final修饰符，final修饰变量代表该变量只能被初始化一次，以后不能被修改。但为什么匿名内部类访问外部成员变量就不允许他修改了呢？接下来这个例子应该足够把这些说清楚了：示例代码： public class InnerFinalTest { private static Test test0= null; public static void main(String[] args) { new InnerFinalTest().method1(); System.out.println(&quot;-------&quot;); test0.test(); } public void method1(){ final Test test = new Test(); test0 = new Test(){ @Override public void test(){ System.out.println(&quot;匿名内部类：&quot; + test); Field[] field = this.getClass().getDeclaredFields(); for (int i = 0; i &lt; field.length; i++) { System.out.println(field[i].getName()); } } }; InnerFinalTest ift = new InnerFinalTest(); ift.innerFinalTest(test0); System.out.println(&quot;外部直接访问变量：&quot;+ test); } public void innerFinalTest(Test test){ test.test(); } } Test类无关紧要，不过还是贴一下吧 public class Test { public void test(){ System.out.println(&quot;啊啊啊啊啊！&quot; ); } } 说明：为什么我们要将被匿名内部类访问的变量定义成final呢？首先，我们在InnerFinalTest类中定义了一个static变量test0: private static Test test0= null; 该语句说明test0的生命周期和类一样 接下来在main方法中调用method1（），在method1（）中将我们定义的匿名内部类赋给了test0,这说明如果test0不往别处指的话，我们匿名内部类将被一直引用着，如同吃了九转大金丹，与天地同寿，与日月齐光，匿名内部类生命周期和InnerFinalTest类（匿名类的天地）相同了。 但是，method1（）调用完了他要释放资源了，所以method1（）方法中： final Test test = new Test(); test变量也要被释放了，test没了，但匿名内部类引用了test，如果java编译器不搞点小动作，他就没法玩儿了，因为匿名类的生命周期长，还使用着test，而外部变量先撤了，背后捅了匿名内部类一刀子。。。 匿名内部类说，就防着你这一招呢，所以叫编译器大哥帮忙搞了个小动作，明修栈道暗度陈仓，编译的时候，我自己把你给我的变量备份了一份，表面上看是我引用了你的变量，其实在运行期间我就用我自己备份的了。但是别人表面上看不知道我备份了一份，还以为我用的你的，如果不定义成final，变量在外面被修改了，我没改，那我的结果就会和预期不同，为了防止出现这种情况，所以要被定义成final。 上面实例代码运行结果： 匿名内部类：Test@40e455bf this$0 val$test 外部直接访问变量：Test@40e455bf 匿名内部类：Test@40e455bf this$0 val$test 我用反射证明了匿名内部类存在外部变量的备份val$test，其中因为变量是默认类型，所以使用getDeclaredFields得到所有匿名内部类运行期间存在的成员属性。 （注意，该成员属性在编码期间是不存在的，是编译器主动为匿名内部类添加的成员属性，所以可以通过反射在运行期间一窥究竟。） 如果去掉匿名内部类对外部变量的引用，如去掉以下代码： System.out.println(&quot;匿名内部类：&quot; + test); 运行结果中会没有了val$test，这也再次证明了以上结论：匿名内部类备份了变量。 通过外部变量和内部变量打印内容相同，说明两个变量test和val$test的变量引用指向的内存区域是相同的，（这里可以参考一下原型模式浅克隆）。指向相同对象，虽然对象不能修改，但对象中的属性可以修改，而匿名内部类变量和外部变量指向相同，自然值也同步修改了。 总结一下，逻辑应该是这样的：为了解决生命周期不同的问题，匿名内部类备份了变量，为了解决备份变量引出的问题，外部变量要被定义成final。匿名内部类使用final不是怕修改，是怕不能同步修改。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部类]]></title>
    <url>%2Fpost%2F9bc01b38.html</url>
    <content type="text"><![CDATA[内容来自：牛客网 成员内部类：可以访问外部所有资源，但是本身内部不可以有静态属性（因为自己本身就需要依靠外部类的实例化）。 局部内部类：不可被访问修饰符和static修饰，且只能访问外部类的final变量和所在函数的形参。 匿名内部类：不可被访问修饰符和static修饰，且只能访问外部类的final变量和所在函数的形参； 没有构造器，没有静态资源； 只能创建一个实例； 不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>内部类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓开发需要学什么]]></title>
    <url>%2Fpost%2Fa440b81f.html</url>
    <content type="text"><![CDATA[以下内容来源于百度知道： 回答1：安卓开发首先第一阶段是要学习java，掌握java了对于安卓的开发就容易很多，然后在学习安卓的开发环境搭配和生命周期，给你分享一个学习的计划表吧。 回答2：从事Android开发工作依次学习和掌握： 第一阶段：Java（基础语法、面向对象、IO流、多线程与Socket编程、数据库，网络传输和数据解析等） 第二阶段：Android应用开发（Android UI、Activity、Fragment碎片、屏幕适配、数据存储等） 第三阶段：Android高级开发（Volley框架、事件机制与手势识别、消息推送、多媒体等）第四阶段：Android游戏开发（引擎系统，碰撞，音效等） 第五阶段：编写项目，综合练习掌握和未掌握的专业技术。在学习过程中贯穿着代码实战。看的代码是别人的，动手写出来的是自己的。自己动手写代码，记忆更加深刻，效率更高。 回答3：Android是一种基于Linux的自由及开放源代码的操作系统，主要使用于移动设备，如智能手机和平板电脑，关于安卓的学习需要学习很多的知识点，但是首先要把基础做好。安卓主要学习： 阶段一：Java编程开发 阶段二：安卓基础开发 阶段三：安卓高级开发 阶段四：企业项目实战]]></content>
      <tags>
        <tag>安卓开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周杰伦卖酸菜记]]></title>
    <url>%2Fpost%2Ff8e64e55.html</url>
    <content type="text"><![CDATA[周杰伦卖酸菜记时间:2018-06-10 07:55:45 来源:中国古典小说网 作者: 中国古典小说网 点击:106次 2012年5月4日，福布斯发布“2012年中国名人榜”，歌星周杰伦力压刘德华和姚明，成为华夏名人之首。这项评比，主要依据入选者的知名度和财富。5月7日，周杰伦的老朋友、台湾著名娱记吴乐平，在《旺报》上发表了题为“周杰伦的赚钱小把戏”专访文章。文中爆料，周杰伦在唱歌事业之外，还拥有多项生意，其中最著名的“胡也酸辣菜”生意正准备在新加坡上市发行股票。 阿婆家地窖的秘密周杰伦生长在单亲家庭，由母亲抚养长大，生活十分艰辛。最底层市民吃的食物，他都吃过。有时家里没钱买不起肉和菜，母亲就腌制好多咸菜，小周杰伦常常就着咸菜吃米饭。所以，对于咸菜，他有着一种难以割舍的情结。 2010年夏天，周杰伦在录音棚里苦干两个月，录制出版了新歌辑《十字勋章》后，感到十分疲劳，于是，便和几个好友，悄悄来到阿里山脉的大武恋山区度假。 为了避来媒体的打扰，一行人住在一个名叫小坝上的小村子里。白天，大家一起去爬山，晚上就坐在农家小床上打牌。房东是一位80多岁的老奶奶，复姓胡也，周杰伦管她叫胡也阿婆。胡也阿婆是个神厨，会做好多阿里山特色饭菜。 有一天，周杰伦和朋友们在集市上买了一只野兔，胡也阿婆说：“野兔肉腥，需要配酸辣菜一起吃才好。我在地缸里腌了好些呢，今天拿出来给你们尝尝。” 周杰伦随阿婆来到仓库里，掀开地上的一块青石板，露出一口埋在地里的大缸。胡也阿婆用竹勺子捞上来几根深绿色的菜条，盛在盘子里。周杰伦尝了一口，只觉得一股微酸微辣的滋味，从舌根慢慢地向下滑去，那滋味爽极了，一盘酸辣菜端上桌子，大家瞬间就吃得精光，直呼“阿婆，再来一大盘”。 回到台北后，周杰伦一直忘不了酸辣菜，那种美的滋味记忆太深了。有一天，他独自开车回到小坝上村，他想跟胡也阿婆学学怎样腌制酸辣菜。 胡也阿婆告诉他，她祖上胡也清山是明朝万历年间宫廷御厨，后代也大多从事厨师行业。酸辣菜就是祖上传下来的。她家祖辈一直吃酸辣菜，据说里面有营养，能祛病长寿。所以，她的家族成员绝大部分活过了90岁。 胡也阿婆说：“小伙子，这个祖传秘方是不外传的，你喜欢吃，我可以给你带上好多回去吃。” 周杰伦带了满满一坛子酸辣菜回到台北，请好友们品尝。大家一片惊呼，著名导演李安吃过之后，对周杰伦说：“这个如果弄到市场上，一定会畅销。” 周杰伦认定这是一个难得的商机，除了可以赚钱，把这种有利于健康的食品推向市场，让更多人受益，也是个善行。几月后，他又来到小坝上村找胡也阿婆，想和阿婆合作生产这种酸辣菜。阿婆一听，大声呵责道：“你让我出卖老祖宗？” 周杰伦受到了训斥，心情沮丧地回到台北。一天，李安见到周杰伦，惊奇问他为什么脸色不好？周杰伦说了事情的经过。李安建议周杰伦去找阿婆的儿子或孙子商量。 经过多方努力，周杰伦终于与胡也阿婆的孙子、当地的一个小学体育教师胡也平取得了联系。胡也平很赞同周杰伦的想法，经过协商，决定由胡也平任总经理兼总技术督导，以技术入股，负责最关键的配方秘密，周杰伦任董事长，负责出资建厂以及产品的销售。因为这个协议执行过程中并无透露酸辣菜的配方，得到了胡也阿婆的许可。2011年元旦，位于台中市的“胡也酸辣菜”有限责任公司正式开工生产了。 大明星兜售小酸菜 第一批“胡也酸辣菜”试产品生产出来了，周杰伦一品尝，与胡也阿婆地窖里的酸辣菜毫无二致，他非常兴奋。与胡也平商量一番后，决定开始大批量投入生产。 一个月后，大批的“胡也酸辣菜”摆进了台中、台南等城市的商场贷架上。然而，现实与周杰伦的预测截然相反，顾客对这种新的咸菜并不感兴趣，有些商场里，一个星期才卖一两袋。有的产品被退了回来，有的经销商表示不愿再经销它。第一批生产的50吨酸辣菜全面滞销，一下损失了近千万新台币。胡也平受到了更大的刺激，因为他辞去了小学教师的公职，现在工厂又不行，他向周杰伦提出辞职。 胡也平一走，可就是釜底抽薪，一切都完蛋了。周杰伦怎么劝，胡也平也不听，一心要离开公司。周杰伦跑到小坝上村，找到胡也阿婆，经过阿婆的规劝，胡也平同意暂时留在公司里，危机总算化解了。 周杰伦很难过，也非常奇怪：为什么味美价廉的酸辣菜竟然无人问津？当初广告也打了，推介会也开了，产品包装也非常精美，为什么产生了这样的结果？ 郁闷之中，周杰伦想到了好友前辈郭台铭先生。郭台铭在商界素以“智多星”著称，一定会有好主意给他。于是，周杰伦特地把郭台铭从台北请来台中市，向他请教。郭台铭看了工厂生产车间，品尝了“胡也酸辣菜”之后，不断点头称赞。他认为，产品非常好，关键是宣传做得不好。俗话说，酒好也怕巷子深。郭台铭说：“要吆喝，要向市场大声吆喝，更重要的是把你的产品和周杰伦这个名字联系起来。” 周杰伦一下子明白了其中的道理。他请来台湾最著名的广告策划人何进身先生，何先生帮周杰伦策划了一套宣传方案，周杰伦看了，连喊：“高明！高明！” 2011年3月，周杰伦接拍了松下公司的广告。双方谈妥的价格是3000万新台币，正在签单，周杰伦突然在谈判桌上提出“减到一半的价格”。这个提法令松下谈判代表惊诧不已。周杰伦谈了自己的条件：他想在广告发布会上吃自己的咸菜。松下的电子产品和民间小吃根本不矛盾，而且周杰伦此举定会引起媒体热议，无疑会加大松下公司的广告效应，松下谈判代表当即表示同意。 广告发布会在香港举行，有200多家媒体记者参加。当有记者问周杰伦最近有什么新歌推出时，周杰伦回答：“近三个月没有新歌推出，我正在生产一种小咸菜，厂址在台中。”好事的记者哪有不抱根问底的，于是 “胡也酸辣菜”发布了。 当晚，关于“周杰伦卖咸菜”的消息就在媒体上出现，人们非常好奇：周杰伦和咸菜有什么干系？一看报道，确确实实，周杰伦在生产一种名叫“胡也酸辣菜”的小咸菜。好奇的人们立即拥向商场，几天之内，滞销的50吨产品被一扫而光。各大商场纷纷打电话告急，脱销！脱销！原来心灰意冷的胡也平变得干劲十足，组织工人昼夜生产，大批酸辣菜源源不断地供应市场。仅仅在2010年第二季度，公司就进账5000万新台币。 周杰伦见东风好借力，马上追加5000万新台币投资扩建厂房，生产规模迅速扩大到月产600吨的规模。 不是广告胜似广告 其实周杰伦并没有意识到，与他一帆风顺的歌唱事业不同的是，商场风云变幻莫测，随时有翻船的危险。“胡也酸辣菜”在市场上亮相后，引起一片热议。有好多人认为周杰伦是歌星，与生产食品风马牛不相及，他搞出的咸菜什么水平，可想而知。2011年8月，一篇题为《腌制食品的亚硝酸盐对人体的危害》的文章，在《苹果日报》副刊发表，文中以“科学数据”论证了胡也酸辣菜的有害成分。 此文一出，胡也酸辣菜立即受到迎头痛击，几天之内销量下降一半。更为严重的是，刚刚生产出来的产品，积压库房，为防止超长期搁置产生变质，只好租用台中市一家大型冷库存放，每天租金高达50万台币。 怎么办？周杰伦焦虑万分，如果这样下去，公司很快就垮台。这时，吴宗宪从媒体上得知了消息，他打来电话，周杰伦连说三遍“情况危急”。吴宗宪想了想，建议他把“胡也酸辣菜”送到台北科学研究院进行化验，用“科学数据”来反击“科学数据”。周杰伦觉得这招可行，马上派人把样品送去检验。 三天后，检验结果出来了，结论是：内中所含微量亚硝盐并未超出一般酿造食品的含量，符合食品食用标准。周杰伦拿到这份检验结论，如获至宝，喜不自禁。他立即让助手邀请媒体，准备召开发布会。 2011年9月1日，精心筹备的“胡也酸辣菜”卫生检验结果发布会，在台北晶华大酒店隆重举行。预计上午10点开始，可是，周杰伦却没有到场，只有总经理胡也平在主持。前来抢歌星新闻的记者大失所望。面对吵吵嚷嚷大呼上当的记者，胡也平微笑着劝大家耐心等待，一定会有奇迹出现的。他说：“周杰伦永远是周杰伦嘛，他什么时候给过我们失望？” 尽管如此，周杰伦迟迟未现身，胡也平渐渐地压不住场了。10点半过后，有记者开始收拾长枪短炮，准备退场了。胡也平怎么挽留也没人听。就在这时，有人高呼：“周杰伦来了！”全场的视线一下子集中到台上，只见周杰伦面带微笑，扶着一位老奶奶，一步步走上台前。 原来，周杰伦昨晚和胡也平一起讨论明天的发布，直到深夜。一直忧心忡忡的周杰伦总是担心发布会的效果不好。胡也平劝他想开一点。忽然，周杰伦一拍大腿，他有了一个想法：把阿婆请到发布会上，现身说法！胡也平眼睛一亮，说：“我怎么没想到这招呢？”他立即打电话给奶奶，胡也阿婆本来不想来，但听孙子介绍了目前的严重情况后，老太太也着急了。于是，周杰伦立即雇了专机直飞台中市，然后乘出租车直达小坝上村，一路风尘，终于在发布会结前赶到了现场。 胡也阿婆虽然88岁了，但身板硬朗，声如洪钟。她大声对着全场记者说：“谁说我的酸辣菜有毒？我吃了一辈子，我被毒死了么？我们家族高祖在明朝是御厨，酸辣菜是我高祖发明的健身长寿菜，我们家族吃它吃了几百年了，不但没有一个得癌，反而个个高寿。我爷爷奶奶都活过了95岁，我母亲前年113岁才去世，连战先生在十年前还给我母亲授过奖呢。” 全场爆发出雷鸣般的掌声，周杰伦心里乐开了花，他明白，一切问题都迎刃而解了。 胡也酸辣菜恢复了往日的辉煌，东南亚好多国家的华商也开始经销。按周杰伦的想法，东南亚国家华裔市场极具潜力，且中国产食品的竞争远未达到大陆和港台的白热化程度，是一个最可开发的处女地市场。于是，他把“胡也酸辣菜”的市场重点推向了东南亚和北美的华裔市场。 由于周杰伦在华人中的巨大影响力，胡也酸辣菜顺利地在华人超市中站稳了脚根，销量以几何级数上升，2012年第一季度，产值高达到7亿新台币。 目前，周杰伦正在运作将“胡也酸辣菜”在新加坡发行股票，上市前的资本前期工作己经结束，周杰伦和他的团队相信，一只生产咸菜的股票不久后就会在股市上成为明星。 (责任编辑：中国古典小说网)转载自https://www.seeol.com/chengyu-detail-32220.html]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杰伦</tag>
        <tag>酸菜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[忻钰坤第二弹--《心迷宫》简单解读[转载]]]></title>
    <url>%2Fpost%2Fb690c376.html</url>
    <content type="text"><![CDATA[电影前10分钟，留下了太多的悬念。这几个看似无关的“线头”故意“现出来”，稍后由它们牵扯出余下的“线”——一条条相互交缠。 那些可能永远无法解释的巧合，常常被称之为“命运”的东西，其实存在它的合理性——不过是每个人在衡量自己利益最大化之后的选择。这种趋利避害，也不过是生存的本能而已。 发生在村里的故事故事发生在村里。对这个地点，或者说这个组成社会的一个单位，村是一个极有意思的存在。说它有意思是因为，它的原始性、自然性和独特性。村，是社会化的产物，但同时它又不那么科学化、理性化、法制化。 在村之上乡镇、城市似乎都遵循着一个“法”，但村稍稍不同，它更本源的延续了人类凝聚之后的另一种约束方式——道德。在一个村之中，有时候是不讲法的，更多的是理、是信、是义，是约定俗成，是人情世故，是中庸之道。所以，这样一个近似荒诞，看似缺乏逻辑的存在，其实在村里是非常合理的存在。因为，村是自成运作系统的。 比如影片中村长的推选，便是建立在信义的基础上。在妻子口中我们知道，老村长为村子兢兢业业，从不贪图，所以换届选举完胜用金钱拉选票的人。在村民们眼中，能为自己办实事，人品上德高望重，办事上以村民利益为先的，便是好村长。而这种道德上的“选举”和“任命”无论在凝聚力上还是在民心所向上，无疑都是更加人性化的。结尾处，无论是老村长要辞去村长一职，还是去自首，其实都是内心中无法跨过道德这道坎。 村里的事都是稀里糊涂的要说人活着，大事小事有时候该糊涂的时候就得糊涂。很多事情都没办法钉是钉铆是铆的去深究。中国人有一句俗话叫“难得糊涂”，虽然是一个公认的可以称得上是知识分子的老先生郑板桥提出来的，但它恰好最大的体现在村里人中。 电影中的故事，可能有人会很不理解：怎么死了人，不报警、不验尸、不走法律程序呢？仅仅凭一句话就盖棺定论了呢？从第一个亡者开始，这种“约定俗成”便很好的说明了这个问题：村里的事儿，只要是大家认可了的，在村里就能解决，何必大动干戈？开篇的引子，已经为整部戏定下了基调：一个老头去烧山，结果自己没走出来烧死掉了。大家公认，合情合理，自然没有必要去报案。用棺材装了，停三天，埋了，大家吃个流水席。那么这件事在村里就算是了了。于是乎，当村里接二连三出现尸体的时候，只要有一个适当的解释，那么这自然就不是事。正所谓“民不举，官不究”。单反符合了村里大致的说法，完成了大家公认的程序，每个人都有一个知会，那么这便不再是个事儿。 令人感到好笑和荒诞的地方是，为什么最后根本没人深究死人究竟是谁？大家自己过上了自己想要的生活，那么好奇心只会平添烦恼，所以何必事事都要弄得请清除吃吃呢？如果影片最后没有出现那几行字的结局，仅仅是一具棺椁和三个人的心照不宣，村里的生活还将继续。可能过上几个月便是全村兴高采烈地喝上欢欢和和宗耀的喜酒也说不定哦！ 村里的人都是精明智慧的要说这事情可能是糊涂，但这人却极为精明。村里是一个相对封闭的环境，人在这种氛围中几乎可以完全熟悉任意一个人的秘密。相处久了，基本上张家长李家短的，没有不知道的。所以，每个人心中都有一杆秤，衡量着自己，也衡量着别人。 之所以说越是底层人也是聪明，是因为他们可以循着本能取追求自己利益的最大化。几个镜头中出现的电视节目，播放的都是星星生活的场景，这并非巧合，而是一种映射——从本质上讲，人和动物没什么区别，生存才是最重要的。如何生活的更好，是每个人都追求的。我们完全可以看到，每个人的每条线都如此清晰的摆在眼前。他们的每一次选择都是按照如何最大限度实现自己利益为前提的。而人生，不过就是一次次选择的叠加，于是，每一次选择下来，人生的走向便有所不同。本片中，可笑的是，很多人的“最优选择”却导致的是“最惨后果”。但综合利弊，你却无法指责他每次选择上的正确性，或许这就是我们所说的“命”。 要说最智慧的存在，其实还是人民群众。电影展现的非常简洁，却真实的让人汗毛都能竖起来：人在生存的时候，无非就是见招拆招。或许这句话有些武侠化了，那么用普通话说，就是：出事儿，想辙。在事情发生的几乎不到48小时中，你听不到抱怨。事情出了，最简单直接的方式就是想办法解决。而这才是最普通却也是最值得竖起大拇指的行为。 人生其实很简单，就像我的曾经在牌桌上说的一句话：不要抱怨你手里的牌，重要的是如何打好一手烂牌。电影中每个人也都是如此，最原始的趋利避害，最原始的解决问题，最原始的寻找生存下来的途径。而这，就是人与生俱来的智慧所在。 在九百六十万平方公里的土地上，法律所及的地方太小。从根本上，这是一个讲情的国度，而这情，人类，其实就是这样祖祖辈辈生生不息的延续着。 PS： 1、影片最后几行字的交代，应该并非原作者的本意吧。相信他应该也能明白，只留下最后一个镜头就好，整部影片的深意完完全全会提升两个档次！那种民族或人类最原始的东西都在涌动着。当然，为了能让更多人看到，加一个“尾巴”也可以理解。 2、人都是以自我为中心运转着，如果说每个人是一个小宇宙，那么可能你永远预料不到的是他人对你的影响，以及你背后更大的银河系发生着什么样的事。一切都是玄而又玄的，变数时时存在。 原文地址：《心迷宫》：迷宫尽头是生存本能 最后加几张电影海报]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>影视</tag>
        <tag>真实</tag>
        <tag>生活</tag>
        <tag>犯罪</tag>
        <tag>悬疑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[忻钰坤第一弹--《爆裂无声》深度解析[转载]]]></title>
    <url>%2Fpost%2F66b74461.html</url>
    <content type="text"><![CDATA[电影《暴裂无声》是由忻钰坤执导的犯罪悬疑片，姜武、宋洋、袁文康、谭卓等主演。暴裂无声剧情讲述了在北方凛冽的冬天，一个牧羊少年带着自家的羊群在山里行走，… 暴裂无声观影后细节分析不知道当你看完《暴裂无声》，是不是也和电影的主角一样，不想声，失语了……电影的剧情其实挺简单，《暴裂无声》的内容和片名一样，无声的暴力罢了。男主是哑者张保民，以拳头显示暴力，从头打到尾，只是这种近乎的暴力却只是最低能无力的；外表光鲜却身处灰色地带的徐律师，看似平静温文尔雅，沉默少言，他表现的暴力却最为阴冷可怕！当然还有强有力的施暴者姜武饰演的土豪金主昌老板，，他所表现出来的暴力是多元化，最全面的。记得电影里有一个场面：昌老板坐在一满桌切盘羊肉前吃着火锅，旁边机器在咔嚓咔嚓地切着羊肉，另一个矿主说自己信佛吃素，昌老板却淡然地讲到：“羊也是吃素的……”接着殴打，威胁，恐吓等等手段跃然而出，完胜！这三个男人唱出了一部完美诠释暴力，却控诉无声的悲剧！整部剧的精彩烧脑之处并不是通常悬疑剧的翻转结局，而是在好似不经意间表现出的一个个细节场景。所有细节场景的串联，才是这部烧脑片的精华所在。电影里的主角只是在引导着剧情的发展，而看懂细节，你才是真正的主角。不过，所有细节串联只有等到看完整部电影才会让你都明白过来。 细节一:张保民得知儿子失踪回家遇到村长，村长递给张保民抽的洋烟在后来昌老板的桌子上出现了。村长整车的往自己家运矿泉水。这两点说明了昌老板和村长之间的利益输送，村长明知道开矿污染了水源，却只顾自己的安危，贪图了昌老板的贿赂。 细节二:昌老板非常喜欢射杀动物和吃羊肉，在最后要射杀张保民的打斗中又表现出了射击水平非常差，加上当手下打手为了威胁张保民交出律师女儿而谎称张保民的儿子在他手中，昌老板气急败坏之下的把手下打的奄奄一息，这些都表明了，徐律师帮昌老板做完伪证，昌老板给徐律师贿赂后心情大好，想要射杀小羊取乐享用，可是在远处放羊的张保民儿子不同意，保护着他心爱的小羊，昌老板依然射击了小羊，却误杀了张保民的儿子。 细节三：昌老板的第一次露面，穿着一身干净的西装，站在校长室，一遍看着学生的照片，一遍吃着西红柿，吃相很难看，与他的穿着形成了鲜明的对比，这里解释一下为什么不吃苹果香蕉之类的而是吃西红柿，西红柿是红色的，象征着生命和鲜血，由于吃的太急，西红柿的汁流到了昌老板的衣服上，但昌老板用纸巾怎么擦也擦不掉，这也表达了做过坏事留下的痕迹是不容易抹去的。 细节四:昌老板在练习弓箭的时候，弦已拉满，却又最终放弃了，虽然这时候导演并没有给出昌老板回忆的镜头，但不难看出，此时的昌老板内心世界是极其复杂的，他在收拾弓箭时，镜头中有一支箭是没有箭头的。箭头第一次出现是在张保民被绑在吉普车后备箱，张保民摸到了箭头并用它解开了脚上的绳子，还有是到结尾的时候，昌老板跟张保民发生冲突，昌老板快要包张保民勒断气的时候，张保民摸到昌老板口袋里的箭头，果断地把它刺进昌老板的大腿里，这才得以空隙出手反击。 这里要补充说明一下，昌老板一直向徐律师索要证据，而徐律师也一头雾水，徐律师其实是真不知道，因为昌老板杀人的证据一直被遗忘在他吉普车的后备箱里，就是那个箭头。这也解释了为什么昌老板会把那个箭头放在裤兜了，最后匆匆把它埋进土里。 细节五:张保民儿子的鬼魂出现在山洞里解开徐律师女儿的绳索和徐律师把女儿抱出山洞后，向着山洞深处的黑暗里偷偷看了一眼，表达了张磊的尸体就被埋在这个山洞深处，徐律师知道，却还是没有告诉张保民。这就和最后徐律师的一句：“没有。”相互辉映，揭示了人性的可怕。 细节六:因为非法采矿，导致矿物污染，所有井水才会越来越难喝，村长才会 一车一车的运纯净水回家，张保民的妻子、栓子的母亲以及更多的村民才会得了怪病，失踪的张磊才会看见小鸟的尸体…… 细节七:酷爱吃羊肉的昌总为什么会掉那么多头发以导致前额发秃，因为他吃的也都是这个矿区的羊。 而这种“以彼之道还施彼身”巧妙且富有深意的设计，在电影中还有三处： 一是那枚要了人命、怎么也找不到的箭头，最终扎到了昌总自己身上！ 二是律师跟着张保民来到藏护女儿的山洞，他开始恍惚、害怕，因为这个地方也藏着他的秘密！ 三是羊肉店老板逼着张保民在拆迁补上签字，换来的不仅是自己瞎了一只眼，更是自己的儿子因为环境污染而精神失常。 总结：虽然最后的结局是让人无言以对的可悲，各种暴力覆盖了一切！山的坍塌，张磊尸体的消失都揭露了黑暗的存在，但是剧中的细节已经表达过一个道理：恶有恶报！出来混总是要还的！ 就让我们依靠着剧中曾经虚幻出的两个小孩纯真的站在山上俯瞰这个城市的场景，看出些许希望吧。 转载自百家号：我爱烧脑之《暴裂无声》深度解析！这部悬疑电影你看懂了多少？]]></content>
      <categories>
        <category>影视</category>
      </categories>
      <tags>
        <tag>影视</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内有哪些好的刷题网站]]></title>
    <url>%2Fpost%2F65ebe4d.html</url>
    <content type="text"><![CDATA[来自：知乎链接：https://www.zhihu.com/question/25574458 1、Leetcode鼎鼎大名的Leetcode，据不完全统计在上面被刷过的题可以围绕地球三圈。（没说赤道哈，就是这么严谨。）总之，很多国内外的码农在上面刷题。难度从easy到hard都有，而且覆盖面极广。现在还增加了数据库和shell，相匹配的论坛也可以多看看。很锻炼和国外码农沟通的能力，对于以后去混Github也有好处。 特点：各种语言支持很广泛，题型覆盖很广，测试数据集较弱。 2、Codility同样一家著名的国外刷题网站。和Leetcode不同，它是专门帮各大软件公司笔试用的，只是副业提供了一些面试题和挑战。但即使是训练模式都非常经典，很值得一做。而且测试数据集提供的非常完善，总能让你有想不到的边界情况。Take our free programming lessons 特点：很接近面试题的风格，训练模式也基本够用。 3、Lintcode可以称作中文版本的Leetcode，个人感觉最高难度比Leetcode高一些。这两个类似的网站，可以配套来刷。每个刷一遍，也能保持新鲜感。 特点：中文支持很好，和Leetcode有一部分题类似，可以和九章算法课程配合使用。 4、Hihocoder来自于原北京大学POJ开发团队，网站一直在进步。最早是微软的在线笔试网站，现在网易也使用它进行在线笔试。题目侧重于较难题目，风格很像ACM比赛，要自己注意数据集的输入输出。 特点：每周一道算法题极难又有趣，可以用来扩展面试题思路。而且是网易、微软的在线笔试网站，有机会需要多练习。 5、CC150这不是网站，这是一本书。全称Cracking the coding interview，是国外找工作的神书，而且的确写的很好。里面除了算法题，还有计算机基础知识等内容，很不错。适合想去外企的人仔细阅读，而且最新版已经比150题多了。总之，外企必备！ 特点：外企必备！外企必备！外企必备！想去外企的人，多看看书的配套答案也是好的 结论：最后，经过公众号作者小分队的讨论，根据不同方向的工作，我们建议按照以下方式刷题： 国企、银行、科研单位Leetcode简单、中等难度最好刷一遍，有时间再过一遍思路。 创业公司Leetcode全部难度上机刷一遍，然后把不会的题纸上在重新写一下。国内互联网 Leetcode全部难度上机刷一遍，纸上再写一遍。同时尽量涉及难度较高的平台（Codility），或者多去几家公司面试，以赛代练。 国内外企Leetcode至少全难度刷一遍，CC150纸上写一遍。想提高Microsoft/Google等在线笔试通过率的，多去玩玩Hihocoder等在线笔试平台。 外企总部Leetcode困难程度烂熟于心，尽量达到ACM入门标准，甚至稍高一点比较有把握。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图片收藏]]></title>
    <url>%2Fpost%2Ffda4c161.html</url>
    <content type="text"><![CDATA[发现好多美女啊！！！ 美女1 这里的图片链接不能写相对路径：./assets/blogImg/美女1.jpg如果这样写的话，文章不展开时的图片是可以显示的，但当文章展开时，所有的图片都无法找到路径了。(可见展开和不展开的页面代码文件并不在同一目录下) 美女2 动图1 动图2 动图3 动图4 风景1 风景2 佩奇 狗子]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages]]></title>
    <url>%2Fpost%2F5641fb4c.html</url>
    <content type="text"><![CDATA[前言使用github pages服务搭建博客的好处有： 全是静态文件，访问速度快； 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台； 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的； 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行； 博客内容可以轻松打包、转移、发布到其它平台； 等等；]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
